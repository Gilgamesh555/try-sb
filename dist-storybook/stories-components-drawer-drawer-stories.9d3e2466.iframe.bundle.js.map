{"version":3,"file":"stories-components-drawer-drawer-stories.9d3e2466.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8QA;;AAcA;;;;;;;AAOA;AACA;AACA;;;AAGA;;;;;;;;AASA;;;;;;;;;;AAUA;;AAEA;;;;;;;;;;;;;AAeA","sources":["webpack://@koerber/uikit/./src/components/drawer/drawer.component.ts"],"sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { animateTo, stopAnimations } from '../../internal/animate';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { getAnimation, setDefaultAnimation } from '../../utilities/animation-registry';\nimport { HasSlotController } from '../../internal/slot';\nimport { html } from 'lit';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { LocalizeController } from '../../utilities/localize';\nimport { lockBodyScrolling, unlockBodyScrolling } from '../../internal/scroll';\nimport { property, query } from 'lit/decorators.js';\nimport { uppercaseFirstLetter } from '../../internal/string';\nimport { waitForEvent } from '../../internal/event';\nimport { watch } from '../../internal/watch';\nimport componentStyles from '../../styles/component.styles';\nimport IconButton from '../icon-button/icon-button.component';\nimport Modal from '../../internal/modal';\nimport styles from './drawer.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Drawers slide in from a container to expose additional options and information.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-drawer--docs\n * @status stable\n * @since 2.0\n *\n * @dependency koerber-icon-button\n *\n * @slot - The drawer's main content.\n * @slot icon - Optional icon to add to the icon before the label. Works best with `<koerber-icon>`.\n * @slot label - The drawer's label. Alternatively, you can use the `label` attribute.\n * @slot footer - The drawer's footer, usually one or more buttons representing various options.\n *\n * @event koerber-show - Emitted when the drawer opens.\n * @event koerber-after-show - Emitted after the drawer opens and all animations are complete.\n * @event koerber-hide - Emitted when the drawer closes.\n * @event koerber-after-hide - Emitted after the drawer closes and all animations are complete.\n * @event koerber-initial-focus - Emitted when the drawer opens and is ready to receive focus. Calling\n *   `event.preventDefault()` will prevent focusing and allow you to set it on a different element, such as an input.\n * @event koerber-request-close - Emitted when the user attempts to\n *   close the drawer by clicking the close button, clicking the overlay, or pressing escape. Calling\n *   `event.preventDefault()` will keep the drawer open. Avoid using this unless closing the drawer will result in\n *   destructive behavior such as data loss.\n *\n * @csspart base - The component's base wrapper.\n * @csspart overlay - The overlay that covers the screen behind the drawer.\n * @csspart panel - The drawer's panel (where the drawer and its content are rendered).\n * @csspart header - The drawer's header. This element wraps the title and header actions.\n * @csspart icon - Optional icon to add to the header before the label. Works best with `<koerber-icon>`.\n * @csspart title - The drawer's title.\n * @csspart close-button - The close button, an `<koerber-icon-button>`.\n * @csspart close-button__base - The close button's exported `base` part.\n * @csspart body - The drawer's body.\n * @csspart footer - The drawer's footer.\n *\n * @cssproperty --koerber-drawer-contained-z-index - The z-index for contained (non-modal) drawer.\n * @cssproperty --koerber-drawer-z-index - The z-index for modal drawer.\n * @cssproperty --koerber-drawer-small-max-width - The max width for drawer with small size.\n * @cssproperty --koerber-drawer-large-max-width - The max width for drawer with large size.\n * @cssproperty --koerber-drawer-header-spacing - The amount of padding to use for the header.\n * @cssproperty --koerber-drawer-body-spacing - The amount of padding to use for the body.\n * @cssproperty --koerber-drawer-footer-spacing - The amount of padding to use for the footer.\n * @cssproperty --koerber-drawer-panel-spacing: - The amount of margin to use for the panel.\n * @cssproperty --koerber-drawer-overlay-color - The background color of the overlay.\n * @cssproperty --koerber-drawer-overlay-opacity - The target opacity of the overlay in percents.\n *\n * @animation drawer.showEnd - The animation to use when showing a drawer with `end` placement.\n * @animation drawer.showStart - The animation to use when showing a drawer with `start` placement.\n * @animation drawer.hideEnd - The animation to use when hiding a drawer with `end` placement.\n * @animation drawer.hideStart - The animation to use when hiding a drawer with `start` placement.\n * @animation drawer.denyClose - The animation to use when a request to close the drawer is denied.\n * @animation drawer.overlay.show - The animation to use when showing the drawer's overlay.\n * @animation drawer.overlay.hide - The animation to use when hiding the drawer's overlay.\n *\n * @property modal - Exposes the internal modal utility that controls focus trapping. To temporarily disable focus\n *   trapping and allow third-party modals spawned from an active modal, call `modal.activateExternal()` when\n *   the third-party modal opens. Upon closing, call `modal.deactivateExternal()` to restore Shoelace's focus trapping.\n */\nclass Drawer extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.hasSlotController = new HasSlotController(this, 'footer', 'icon');\n        this.localize = new LocalizeController(this);\n        this.modal = new Modal(this);\n        /**\n         * Indicates whether or not the drawer is open. You can toggle this attribute to show and hide the drawer, or you can\n         * use the `show()` and `hide()` methods and this attribute will reflect the drawer's open state.\n         */\n        this.open = false;\n        /**\n         * The drawer's label as displayed in the header. You should always include a relevant label even when using\n         * `no-header`, as it is required for proper accessibility. If you need to display HTML, use the `label` slot instead.\n         */\n        this.label = '';\n        /** The direction from which the drawer will open. */\n        this.placement = 'end';\n        /** The drawer's size. */\n        this.size = 'small';\n        /**\n         * By default, the drawer slides out of its containing block (usually the viewport). To make the drawer slide out of\n         * its parent element, set this attribute and add `position: relative` to the parent.\n         */\n        this.contained = false;\n        /**\n         * Removes the header. This will also remove the default close button, so please ensure you provide an easy,\n         * accessible way for users to dismiss the drawer.\n         */\n        this.noHeader = false;\n        this.handleDocumentKeyDown = (event) => {\n            // Contained drawers aren't modal and don't response to the escape key\n            if (this.contained) {\n                return;\n            }\n            if (event.key === 'Escape' && this.modal.isActive() && this.open) {\n                event.stopImmediatePropagation();\n                this.requestClose('keyboard');\n            }\n        };\n    }\n    firstUpdated() {\n        this.drawer.hidden = !this.open;\n        if (this.open) {\n            this.addOpenListeners();\n            if (!this.contained) {\n                this.modal.activate();\n                lockBodyScrolling(this);\n            }\n        }\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        unlockBodyScrolling(this);\n    }\n    requestClose(source) {\n        const slRequestClose = this.emit('koerber-request-close', {\n            cancelable: true,\n            detail: { source }\n        });\n        if (slRequestClose.defaultPrevented) {\n            const animation = getAnimation(this, 'drawer.denyClose', { dir: this.localize.dir() });\n            animateTo(this.panel, animation.keyframes, animation.options);\n            return;\n        }\n        this.hide();\n    }\n    addOpenListeners() {\n        document.addEventListener('keydown', this.handleDocumentKeyDown);\n    }\n    removeOpenListeners() {\n        document.removeEventListener('keydown', this.handleDocumentKeyDown);\n    }\n    async handleOpenChange() {\n        if (this.open) {\n            // Show\n            this.emit('koerber-show');\n            this.addOpenListeners();\n            this.originalTrigger = document.activeElement;\n            // Lock body scrolling only if the drawer isn't contained\n            if (!this.contained) {\n                this.modal.activate();\n                lockBodyScrolling(this);\n            }\n            // When the drawer is shown, Safari will attempt to set focus on whatever element has autofocus. This causes the\n            // drawer's animation to jitter, so we'll temporarily remove the attribute, call `focus({ preventScroll: true })`\n            // ourselves, and add the attribute back afterwards.\n            //\n            // Related: https://github.com/shoelace-style/shoelace/issues/693\n            //\n            const autoFocusTarget = this.querySelector('[autofocus]');\n            if (autoFocusTarget) {\n                autoFocusTarget.removeAttribute('autofocus');\n            }\n            await Promise.all([stopAnimations(this.drawer), stopAnimations(this.overlay)]);\n            this.drawer.hidden = false;\n            // Set initial focus\n            requestAnimationFrame(() => {\n                const slInitialFocus = this.emit('koerber-initial-focus', { cancelable: true });\n                if (!slInitialFocus.defaultPrevented) {\n                    // Set focus to the autofocus target and restore the attribute\n                    if (autoFocusTarget) {\n                        autoFocusTarget.focus({ preventScroll: true });\n                    }\n                    else {\n                        this.panel.focus({ preventScroll: true });\n                    }\n                }\n                // Restore the autofocus attribute\n                if (autoFocusTarget) {\n                    autoFocusTarget.setAttribute('autofocus', '');\n                }\n            });\n            const panelAnimation = getAnimation(this, `drawer.show${uppercaseFirstLetter(this.placement)}`, {\n                dir: this.localize.dir()\n            });\n            const overlayAnimation = getAnimation(this, 'drawer.overlay.show', { dir: this.localize.dir() });\n            await Promise.all([\n                animateTo(this.panel, panelAnimation.keyframes, panelAnimation.options),\n                animateTo(this.overlay, overlayAnimation.keyframes, overlayAnimation.options)\n            ]);\n            this.emit('koerber-after-show');\n        }\n        else {\n            // Hide\n            this.emit('koerber-hide');\n            this.removeOpenListeners();\n            if (!this.contained) {\n                this.modal.deactivate();\n                unlockBodyScrolling(this);\n            }\n            await Promise.all([stopAnimations(this.drawer), stopAnimations(this.overlay)]);\n            const panelAnimation = getAnimation(this, `drawer.hide${uppercaseFirstLetter(this.placement)}`, {\n                dir: this.localize.dir()\n            });\n            const overlayAnimation = getAnimation(this, 'drawer.overlay.hide', { dir: this.localize.dir() });\n            // Animate the overlay and the panel at the same time. Because animation durations might be different, we need to\n            // hide each one individually when the animation finishes, otherwise the first one that finishes will reappear\n            // unexpectedly. We'll unhide them after all animations have completed.\n            await Promise.all([\n                animateTo(this.overlay, overlayAnimation.keyframes, overlayAnimation.options).then(() => {\n                    this.overlay.hidden = true;\n                }),\n                animateTo(this.panel, panelAnimation.keyframes, panelAnimation.options).then(() => {\n                    this.panel.hidden = true;\n                })\n            ]);\n            this.drawer.hidden = true;\n            // Now that the dialog is hidden, restore the overlay and panel for next time\n            this.overlay.hidden = false;\n            this.panel.hidden = false;\n            // Restore focus to the original trigger\n            const trigger = this.originalTrigger;\n            if (typeof (trigger === null || trigger === void 0 ? void 0 : trigger.focus) === 'function') {\n                setTimeout(() => trigger.focus());\n            }\n            this.emit('koerber-after-hide');\n        }\n    }\n    handleNoModalChange() {\n        if (this.open && !this.contained) {\n            this.modal.activate();\n            lockBodyScrolling(this);\n        }\n        if (this.open && this.contained) {\n            this.modal.deactivate();\n            unlockBodyScrolling(this);\n        }\n    }\n    /** Shows the drawer. */\n    async show() {\n        if (this.open) {\n            return undefined;\n        }\n        this.open = true;\n        return waitForEvent(this, 'koerber-after-show');\n    }\n    /** Hides the drawer */\n    async hide() {\n        if (!this.open) {\n            return undefined;\n        }\n        this.open = false;\n        return waitForEvent(this, 'koerber-after-hide');\n    }\n    render() {\n        return html `\r\n      <div\r\n        part=\"base\"\r\n        class=${classMap({\n            drawer: true,\n            'drawer--open': this.open,\n            'drawer--small': this.size === 'small',\n            'drawer--large': this.size === 'large',\n            'drawer--end': this.placement === 'end',\n            'drawer--start': this.placement === 'start',\n            'drawer--contained': this.contained,\n            'drawer--fixed': !this.contained,\n            'drawer--rtl': this.localize.dir() === 'rtl',\n            'drawer--has-footer': this.hasSlotController.test('footer'),\n            'drawer--has-icon': this.hasSlotController.test('icon')\n        })}\r\n      >\r\n        <div part=\"overlay\" class=\"drawer__overlay\" @click=${() => this.requestClose('overlay')} tabindex=\"-1\"></div>\r\n\r\n        <div\r\n          part=\"panel\"\r\n          class=\"drawer__panel\"\r\n          role=\"dialog\"\r\n          aria-modal=\"true\"\r\n          aria-hidden=${this.open ? 'false' : 'true'}\r\n          aria-label=${ifDefined(this.noHeader ? this.label : undefined)}\r\n          aria-labelledby=${ifDefined(!this.noHeader ? 'title' : undefined)}\r\n          tabindex=\"0\"\r\n        >\r\n          ${!this.noHeader\n            ? html `\r\n                <header part=\"header\" class=\"drawer__header\">\r\n                  <h2 part=\"title\" class=\"drawer__title\" id=\"title\">\r\n                    <div part=\"icon\" class=\"drawer__title-icon\">\r\n                      <slot name=\"icon\"></slot>\r\n                    </div>\r\n                    <!-- If there's no label, use an invisible character to prevent the header from collapsing -->\r\n                    <div part=\"title-label\" class=\"drawer__title-label\">\r\n                      <slot name=\"label\"> ${this.label.length > 0 ? this.label : String.fromCharCode(65279)} </slot>\r\n                    </div>\r\n                  </h2>\r\n                  <div class=\"drawer__header-actions\">\r\n                    <koerber-icon-button\r\n                      size=\"large\"\r\n                      part=\"close-button\"\r\n                      exportparts=\"base:close-button__base\"\r\n                      class=\"drawer__close\"\r\n                      name=\"close\"\r\n                      label=${this.localize.term('close')}\r\n                      library=\"system\"\r\n                      @click=${() => this.requestClose('close-button')}\r\n                    ></koerber-icon-button>\r\n                  </div>\r\n                </header>\r\n              `\n            : ''}\r\n\r\n          <slot part=\"body\" class=\"drawer__body\"></slot>\r\n\r\n          <footer part=\"footer\" class=\"drawer__footer\">\r\n            <slot name=\"footer\"></slot>\r\n          </footer>\r\n        </div>\r\n      </div>\r\n    `;\n    }\n}\nDrawer.styles = [componentStyles, styles];\nDrawer.dependencies = { 'koerber-icon-button': IconButton };\nexport default Drawer;\n__decorate([\n    query('.drawer')\n], Drawer.prototype, \"drawer\", void 0);\n__decorate([\n    query('.drawer__panel')\n], Drawer.prototype, \"panel\", void 0);\n__decorate([\n    query('.drawer__overlay')\n], Drawer.prototype, \"overlay\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Drawer.prototype, \"open\", void 0);\n__decorate([\n    property({ reflect: true })\n], Drawer.prototype, \"label\", void 0);\n__decorate([\n    property({ reflect: true })\n], Drawer.prototype, \"placement\", void 0);\n__decorate([\n    property({ reflect: true })\n], Drawer.prototype, \"size\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Drawer.prototype, \"contained\", void 0);\n__decorate([\n    property({ attribute: 'no-header', type: Boolean, reflect: true })\n], Drawer.prototype, \"noHeader\", void 0);\n__decorate([\n    watch('open', { waitUntilFirstUpdate: true })\n], Drawer.prototype, \"handleOpenChange\", null);\n__decorate([\n    watch('contained', { waitUntilFirstUpdate: true })\n], Drawer.prototype, \"handleNoModalChange\", null);\n// End\nsetDefaultAnimation('drawer.showEnd', {\n    keyframes: [\n        { opacity: 0, translate: '100%' },\n        { opacity: 1, translate: '0' }\n    ],\n    rtlKeyframes: [\n        { opacity: 0, translate: '-100%' },\n        { opacity: 1, translate: '0' }\n    ],\n    options: { duration: 250, easing: 'ease' }\n});\nsetDefaultAnimation('drawer.hideEnd', {\n    keyframes: [\n        { opacity: 1, translate: '0' },\n        { opacity: 0, translate: '100%' }\n    ],\n    rtlKeyframes: [\n        { opacity: 1, translate: '0' },\n        { opacity: 0, translate: '-100%' }\n    ],\n    options: { duration: 250, easing: 'ease' }\n});\n// Start\nsetDefaultAnimation('drawer.showStart', {\n    keyframes: [\n        { opacity: 0, translate: '-100%' },\n        { opacity: 1, translate: '0' }\n    ],\n    rtlKeyframes: [\n        { opacity: 0, translate: '100%' },\n        { opacity: 1, translate: '0' }\n    ],\n    options: { duration: 250, easing: 'ease' }\n});\nsetDefaultAnimation('drawer.hideStart', {\n    keyframes: [\n        { opacity: 1, translate: '0' },\n        { opacity: 0, translate: '-100%' }\n    ],\n    rtlKeyframes: [\n        { opacity: 1, translate: '0' },\n        { opacity: 0, translate: '100%' }\n    ],\n    options: { duration: 250, easing: 'ease' }\n});\n// Deny close\nsetDefaultAnimation('drawer.denyClose', {\n    keyframes: [{ scale: 1 }, { scale: 1.01 }, { scale: 1 }],\n    options: { duration: 250 }\n});\n// Overlay\nsetDefaultAnimation('drawer.overlay.show', {\n    keyframes: [{ opacity: 0 }, { opacity: 1 }],\n    options: { duration: 250 }\n});\nsetDefaultAnimation('drawer.overlay.hide', {\n    keyframes: [{ opacity: 1 }, { opacity: 0 }],\n    options: { duration: 250 }\n});\n"],"names":[],"sourceRoot":""}