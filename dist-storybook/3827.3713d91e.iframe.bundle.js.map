{"version":3,"file":"3827.3713d91e.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8FA;AACA;;AAEA;;AAGA;;;AAQA;;;AAKA;;;AAGA;;AAMA;AACA;AACA;AACA;;AAEA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjGA;;;AASA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACuCA;;AASA;;;AAGA;;AAKA;AACA;AAGA;;;AAKA;;AAGA;AC9GA;;;;;;;;;;;;AC4CA;;AAGA","sources":["webpack://@koerber/uikit/./src/components/avatar/avatar.component.ts","webpack://@koerber/uikit/./src/components/badge/badge.component.ts","webpack://@koerber/uikit/./src/components/list-item/list-item.component.ts","webpack://@koerber/uikit/./src/components/list/list.styles.ts","webpack://@koerber/uikit/./src/components/list/list.component.ts"],"sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { classMap } from 'lit/directives/class-map.js';\nimport { html } from 'lit';\nimport { property, query, state } from 'lit/decorators.js';\nimport { watch } from '../../internal/watch';\nimport Badge from '../badge/badge.component';\nimport componentStyles from '../../styles/component.styles';\nimport Icon from '../icon/icon.component';\nimport styles from './avatar.styles';\nimport UIKitElement from '../../internal/uikit-element';\nconst iconSizeParser = {\n    small: 'medium',\n    medium: 'large',\n    large: 'large'\n};\n/**\n * @summary Avatars are used to represent a person or object.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-avatar--docs\n * @status stable\n * @since 2.0\n *\n * @dependency koerber-icon\n * @dependency koerber-badge\n *\n * @slot icon - The default icon to use when no image or initials are present. Works best with `<koerber-icon>`.\n *\n * @csspart base - The component's base wrapper.\n * @csspart icon - The container that wraps the avatar's icon.\n * @csspart initials - The container that wraps the avatar's initials.\n * @csspart image - The avatar image. Only shown when the `image` attribute is set.\n *\n * @cssproperty --size - The size of the avatar.\n */\nclass Avatar extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        /** Check if the image has an error on its download */\n        this.hasError = false;\n        /** Focus state on component */\n        this.hasFocus = false;\n        /** The image source to use for the avatar. */\n        this.image = '';\n        /** Icon name attribute */\n        this.icon = 'account';\n        /** A label to use to describe the avatar to assistive devices. */\n        this.label = '';\n        /** Initials to use as a fallback when no image is available (1-2 characters max recommended). */\n        this.initials = '';\n        /** Indicates how the browser should load the image. */\n        this.loading = 'eager';\n        /** Indicates how the browser should load the image. */\n        this.size = 'medium';\n    }\n    handleImageChange() {\n        // Reset the error when a new image is provided\n        this.hasError = false;\n    }\n    handleClick() {\n        this.hasFocus = true;\n        this.emit('koerber-focus');\n        setTimeout(() => {\n            this.hasFocus = false;\n            this.emit('koerber-blur');\n        }, 100);\n    }\n    handleMouseUp() {\n        this.hasFocus = false;\n        this.emit('koerber-blur');\n    }\n    handleMouseDown() {\n        this.hasFocus = true;\n        this.emit('koerber-focus');\n    }\n    /** Simulates click on the component */\n    click() {\n        this.avatar.click();\n    }\n    /** Simulates the component press certain amount of time in mil-seconds */\n    press(time) {\n        this.handleMouseDown();\n        setTimeout(() => {\n            this.handleMouseUp();\n        }, time);\n    }\n    render() {\n        const avatarWithImage = html `\n      <img\n        part=\"image\"\n        class=\"avatar__image\"\n        src=\"${this.image}\"\n        loading=\"${this.loading}\"\n        alt=\"\"\n        @error=\"${() => (this.hasError = true)}\"\n      />\n    `;\n        let avatarWithoutImage = html ``;\n        if (this.initials) {\n            avatarWithoutImage = html `<div part=\"initials\" class=\"avatar__initials\">${this.initials}</div>`;\n        }\n        else {\n            avatarWithoutImage = html `\n        <div part=\"icon\" class=\"avatar__icon\" aria-hidden=\"true\">\n          <slot name=\"icon\">\n            <koerber-icon name=${this.icon} size=${iconSizeParser[this.size]}></koerber-icon>\n          </slot>\n        </div>\n      `;\n        }\n        return html `\n      <div\n        part=\"base\"\n        class=${classMap({\n            avatar: true,\n            [`avatar--${this.size}`]: true,\n            'avatar--focused': this.hasFocus\n        })}\n        role=\"img\"\n        aria-label=${this.label}\n        @click=${this.handleClick}\n        @mousedown=${this.handleMouseDown}\n        @mouseup=${this.handleMouseUp}\n      >\n        ${this.image && !this.hasError ? avatarWithImage : avatarWithoutImage}\n      </div>\n    `;\n    }\n}\nAvatar.styles = [componentStyles, styles];\nAvatar.dependencies = {\n    'koerber-icon': Icon,\n    'koerber-badge': Badge\n};\nexport default Avatar;\n__decorate([\n    query('.avatar')\n], Avatar.prototype, \"avatar\", void 0);\n__decorate([\n    state()\n], Avatar.prototype, \"hasError\", void 0);\n__decorate([\n    state()\n], Avatar.prototype, \"hasFocus\", void 0);\n__decorate([\n    property()\n], Avatar.prototype, \"image\", void 0);\n__decorate([\n    property()\n], Avatar.prototype, \"icon\", void 0);\n__decorate([\n    property()\n], Avatar.prototype, \"label\", void 0);\n__decorate([\n    property()\n], Avatar.prototype, \"initials\", void 0);\n__decorate([\n    property()\n], Avatar.prototype, \"loading\", void 0);\n__decorate([\n    property()\n], Avatar.prototype, \"size\", void 0);\n__decorate([\n    watch('image')\n], Avatar.prototype, \"handleImageChange\", null);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { classMap } from 'lit/directives/class-map.js';\nimport { html } from 'lit';\nimport { property } from 'lit/decorators.js';\nimport componentStyles from '../../styles/component.styles';\nimport styles from './badge.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Badges are used to draw attention and display statuses or counts.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-badge--docs\n * @status stable\n * @since 2.0\n *\n * @slot - The badge's content.\n *\n * @csspart base - The component's base wrapper.\n * @csspart label - The chip's label.\n */\nclass Badge extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        /** The badge's theme variant. */\n        this.size = 'medium';\n    }\n    render() {\n        return html `\n      <span\n        part=\"base\"\n        class=${classMap({\n            badge: true,\n            'badge--extra-small': this.size === 'extra-small',\n            'badge--small': this.size === 'small',\n            'badge--medium': this.size === 'medium',\n            'badge--large': this.size === 'large'\n        })}\n        role=\"status\"\n      >\n        ${this.size === 'large' ? html `<slot part=\"label\"></slot>` : ''}\n      </span>\n    `;\n    }\n}\nBadge.styles = [componentStyles, styles];\nexport default Badge;\n__decorate([\n    property({ reflect: true })\n], Badge.prototype, \"size\", void 0);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { classMap } from 'lit/directives/class-map.js';\nimport { html } from 'lit';\nimport { property, query } from 'lit/decorators.js';\nimport Avatar from '../avatar/avatar.component';\nimport Button from '../button/button.component';\nimport componentStyles from '../../styles/component.styles';\nimport Icon from '../icon/icon.component';\nimport styles from './list-item.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary list items provide options for the user to select in a list.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-list-item--docs\n *\n * @dependency koerber-icon\n * @dependency koerber-button\n * @dependency koerber-avatar\n *\n * @slot label - list item's label text.\n * @slot prefix - list item's prefix icon or avatar.\n * @slot secondary-text - secondary text to the list item.\n * @slot tertiary-text - tertiary text to the list item.\n * @slot suffix - list item's suffix icon-only button.\n *\n * @csspart base - The component's base wrapper.\n */\nclass ListItem extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        /** The label of the list item */\n        this.label = '';\n        /** The secondary text of the list item */\n        this.secondaryText = '';\n        /** The tertiary text of the list item */\n        this.tertiaryText = '';\n        /** The size of the list item */\n        this.size = 'medium';\n    }\n    connectedCallback() {\n        super.connectedCallback();\n    }\n    getPrefixIcon() {\n        return this.querySelector('koerber-icon');\n    }\n    getPrefixAvatar() {\n        return this.querySelector('koerber-avatar');\n    }\n    async syncPrefix() {\n        const icon = this.getPrefixIcon();\n        const avatar = this.getPrefixAvatar();\n        const hasSubtext = this.secondaryText || this.tertiaryText;\n        // Sync the size for prefix icon or avatar\n        if (icon) {\n            await icon.updateComplete;\n            icon.size = hasSubtext || this.size === 'large' ? 'large' : 'medium';\n        }\n        else if (avatar) {\n            await avatar.updateComplete;\n            avatar.size = 'small';\n        }\n    }\n    getSuffixButton() {\n        return this.querySelector('koerber-button');\n    }\n    async syncSuffixButton() {\n        const button = this.getSuffixButton();\n        // Sync the size, variant, and icon-only for suffix button\n        if (button) {\n            await button.updateComplete;\n            button.variant = 'ghost';\n            // add 'text-container-has-suffix' class  if the suffix button exists.\n            this.shadowRoot.querySelector('.text-container').classList.add('text-container-has-suffix');\n        }\n    }\n    render() {\n        const hasSubtext = this.secondaryText || this.tertiaryText;\n        return html `\r\n      <div\r\n        part=\"base\"\r\n        class=${classMap({\n            'list-item': true,\n            'line-item--has-subtext': hasSubtext,\n            'line-item--has-no-subtext': !hasSubtext,\n            'list-item--small': this.size === 'small',\n            'list-item--medium': this.size === 'medium',\n            'list-item--large': this.size === 'large'\n        })}\r\n      >\r\n        <slot name=\"prefix\" class=\"list-item__prefix\" @slotchange=${this.syncPrefix}></slot>\r\n\r\n        <div\r\n          class=${classMap({\n            'text-container': true,\n            'text-container--has-subtext': hasSubtext\n        })}\r\n        >\r\n          <slot name=\"label\" class=\"list-item__label-text\">${this.label}</slot>\r\n          ${this.secondaryText\n            ? html `<slot name=\"secondary-text\" class=\"list-item__secondary-text\">${this.secondaryText}</slot>`\n            : ''}\r\n          ${this.tertiaryText\n            ? html `<slot name=\"tertiary-text\" class=\"list-item__tertiary-text\">${this.tertiaryText}</slot>`\n            : ''}\r\n        </div>\r\n\r\n        <slot name=\"suffix\" class=\"list-item__suffix\" @slotchange=${this.syncSuffixButton}></slot>\r\n      </div>\r\n    `;\n    }\n}\nListItem.styles = [componentStyles, styles];\nListItem.dependencies = { 'koerber-avatar': Avatar, 'koerber-button': Button, 'koerber-icon': Icon };\nexport default ListItem;\n__decorate([\n    query('slot:not([name])')\n], ListItem.prototype, \"defaultSlot\", void 0);\n__decorate([\n    property()\n], ListItem.prototype, \"label\", void 0);\n__decorate([\n    property({ type: String, attribute: 'secondary-text' })\n], ListItem.prototype, \"secondaryText\", void 0);\n__decorate([\n    property({ type: String, attribute: 'tertiary-text' })\n], ListItem.prototype, \"tertiaryText\", void 0);\n__decorate([\n    property({ reflect: true })\n], ListItem.prototype, \"size\", void 0);\n__decorate([\n    property()\n], ListItem.prototype, \"value\", void 0);\n","import { css } from 'lit';\nimport componentStyles from '../../styles/component.styles';\nexport default css `\n  ${componentStyles}\n\n  :host {\n    display: block;\n  }\n\n  .list {\n    position: relative;\n    padding: var(--koerber-spacing-s);\n  }\n`;\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { html } from 'lit';\nimport { property, query } from 'lit/decorators.js';\nimport { watch } from '../../internal/watch';\nimport styles from './list.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary List is used for displaying single-level information/data.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-list--docs\n *\n * @slot - The list's content, includes only list items\n *\n * @csspart base - The component's base wrapper.\n */\nclass List extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        /** The list's size. This size will be applied to all child list-items. */\n        this.size = 'medium';\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.setAttribute('role', 'list');\n    }\n    getAllLists() {\n        return [...this.querySelectorAll('koerber-list-item')];\n    }\n    async syncListElements() {\n        const list_items = this.getAllLists();\n        await Promise.all(\n        // Sync the size for child list items\n        list_items.map(async (list_item) => {\n            await list_item.updateComplete;\n            list_item.size = this.size;\n        }));\n    }\n    handleSizeChange() {\n        this.syncListElements();\n    }\n    render() {\n        return html `\n      <div part=\"base\" class=\"list\">\n        <slot @slotchange=${this.syncListElements}></slot>\n      </div>\n    `;\n    }\n}\nList.styles = styles;\nexport default List;\n__decorate([\n    query('slot:not([name])')\n], List.prototype, \"defaultSlot\", void 0);\n__decorate([\n    property({ reflect: true })\n], List.prototype, \"size\", void 0);\n__decorate([\n    watch('size', { waitUntilFirstUpdate: true })\n], List.prototype, \"handleSizeChange\", null);\n"],"names":[],"sourceRoot":""}