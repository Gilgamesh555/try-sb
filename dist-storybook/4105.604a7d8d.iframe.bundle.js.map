{"version":3,"file":"4105.604a7d8d.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CA;;;AAGA;AAIA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACmEA;;AAGA;;AAIA;AACA;AACA;AACA;AAEA;;;;;AAKA;;;;;;AAMA;;AAEA;AAEA;AACA;AAGA;AACA;AAEA;;AAGA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzFA;;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;;AAGA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACkHA;;;;;AAUA;;AAgBA;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;AAMA;AACA;;;;AAIA;;;AAGA;AAEA;;AAGA;;AAEA;AAEA;;;;;AAMA;AACA;;;AAGA;;AAGA;;AAEA;;AAGA;;;;AAIA;AAEA;AAGA;;;;AAKA;AACA;;;AAGA;;;;;;;AAOA;AACA;;;AAGA;AACA;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC6EA;;;;AAIA;;;;;AAQA;;AAOA;AAGA;;;;AAOA;;AAGA;;AAKA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1TA;;;;;AAUA;;;;;;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;AAKA;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/BA;AAIA;AACA;AACA;AACA;;;;;;;;;;;;;;AAcA;;AAEA;;;AAIA","sources":["webpack://@koerber/uikit/./src/components/form-field-label/form-field-label.component.ts","webpack://@koerber/uikit/./src/components/form-field/form-field.component.ts","webpack://@koerber/uikit/./src/components/icon-button/icon-button.component.ts","webpack://@koerber/uikit/./src/components/input/input.component.ts","webpack://@koerber/uikit/./src/components/popup/popup.component.ts","webpack://@koerber/uikit/./src/components/textarea/textarea.component.ts","webpack://@koerber/uikit/./src/components/tooltip/tooltip.component.ts"],"sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { html } from 'lit';\nimport { property, query } from 'lit/decorators.js';\nimport { watch } from '../../internal/watch';\nimport Icon from '../icon/icon.component';\nimport styles from './form-field-label.styles';\nimport Tooltip from '../tooltip/tooltip.component';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net\n *\n * @slot - The Form field labelâ€™s main content.\n * @slot tooltip - Use to display tooltip content for the form field label.\n * @slot required - Use to mark the form field label as required.\n *\n * @dependency koerber-icon\n *\n * @csspart base - The component's base wrapper.\n * @csspart label - The form field label container.\n */\nclass FormFieldLabel extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        /** The label of the Form Field */\n        this.label = '';\n        /** The tooltip of the Form field label */\n        this.tooltip = '';\n        /** Makes the form field label a required field. */\n        this.required = false;\n        this.accessibleHidden = false;\n    }\n    handleRequiredChange() {\n        this.required = !this.required;\n    }\n    render() {\n        const infoIcon = this.tooltip.trim().length > 0\n            ? html `\r\n            <koerber-tooltip placement=\"top-start\" hoist content=${this.tooltip}>\r\n              <koerber-icon class=\"info_icon\" size=\"medium\" name=\"information\"></koerber-icon>\r\n            </koerber-tooltip>\r\n          `\n            : '';\n        return html `${this.label.trim().length > 0\n            ? html `\r\n          <div class=\"body\" aria-label=${this.label} ?aria-hidden=${this.accessibleHidden}>\r\n            ${this.required ? html `<span class=\"asterisk\">*</span>` : ''}\r\n            <span class=\"label_container\">${this.label}</span>\r\n            ${infoIcon}\r\n          </div>\r\n        `\n            : ''}`;\n    }\n}\nFormFieldLabel.styles = styles;\nFormFieldLabel.dependencies = { 'koerber-icon': Icon, 'koerber-tooltip': Tooltip };\nexport default FormFieldLabel;\n__decorate([\n    query('slot:not([name])')\n], FormFieldLabel.prototype, \"defaultSlot\", void 0);\n__decorate([\n    property()\n], FormFieldLabel.prototype, \"label\", void 0);\n__decorate([\n    property({ reflect: true })\n], FormFieldLabel.prototype, \"tooltip\", void 0);\n__decorate([\n    property({ reflect: true, type: Boolean })\n], FormFieldLabel.prototype, \"required\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true, attribute: 'accessible-hidden' })\n], FormFieldLabel.prototype, \"accessibleHidden\", void 0);\n__decorate([\n    watch('required', { waitUntilFirstUpdate: true })\n], FormFieldLabel.prototype, \"handleRequiredChange\", null);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { HasSlotController } from '../../internal/slot';\nimport { html } from 'lit';\nimport { property, query, queryAssignedElements } from 'lit/decorators.js';\nimport { watch } from '../../internal/watch';\nimport FormFieldError from '../form-field-error/form-field-error.component';\nimport FormFieldLabel from '../form-field-label/form-field-label.component';\nimport styles from './form-field.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net\n *\n * @slot (default) - form field control or a suitable display value if in readonly mode.\n * @slot prefix - provides custom content for the form field before field control. It is used to provide context or enhance functionality.\n * @slot suffix - provides custom content for the form field before field control. It is used to provide context or enhance functionality.\n * @slot help-text - custom content for help text.\n * @slot error - custom content for error messages below the field control. can be used to provide form field related error messages\n * @slot footer - custom content for form field footer. can be used to provide additional content after form field control and help-text area.\n *\n * @csspart base - The component's base wrapper.\n * @csspart form-control - The component's form control.\n * @csspart error - The component's error wrapper.\n */\nclass FormField extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.hasSlotController = new HasSlotController(this, 'label', 'error', 'footer');\n        /** The form-field's help text. If you need to display HTML, use the `help-text` slot instead. */\n        this.helpText = '';\n        /** The Value Hint of the component */\n        this.valueHint = '';\n        /** Sets if the user input is strictly required */\n        this.required = false;\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.updateComplete.then(() => {\n            // if suffix is slotted, add margin to the value hint to align with form-control.\n            if (this.suffixSlot) {\n                const suffix = this.suffixSlot.assignedElements({ flatten: true })[0];\n                const getSuffixAttribute = (attribute) => parseInt(getComputedStyle(suffix).getPropertyValue(attribute).replace('px', ''));\n                const valueHintElement = this.shadowRoot.querySelector('.value-hint');\n                if (suffix) {\n                    const suffixWidth = getSuffixAttribute('width') + getSuffixAttribute('margin-left') + getSuffixAttribute('margin-right');\n                    if (valueHintElement) {\n                        valueHintElement.style.marginRight = `${suffixWidth}px`;\n                    }\n                }\n            }\n        });\n    }\n    updated() {\n        this.handleSlotChange();\n    }\n    handleSlotChange() {\n        const [controlElement] = this._controlElements;\n        if (controlElement) {\n            this.setAccessibilityAttributes(controlElement);\n        }\n        this.setErrorOnControlElement(controlElement);\n    }\n    setAccessibilityAttributes(item) {\n        var _a;\n        // Set the accessible name and description to the form control component if form control attributes are being set\n        const itemFormControl = item;\n        if (!itemFormControl.accessibleName && this.label) {\n            itemFormControl.accessibleName = this.label;\n        }\n        if (!itemFormControl.accessibleDescription && this.helpText) {\n            itemFormControl.accessibleDescription = this.helpText;\n        }\n        // If the form control component has already an accessible name, we hide the label aria properties\n        if (itemFormControl.accessibleName) {\n            const [labelElement] = this._labelElements;\n            const labelItem = labelElement;\n            if (labelItem) {\n                labelItem.accessibleHidden = true;\n            }\n            else {\n                const defaultLabel = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('koerber-form-field-label');\n                if (defaultLabel) {\n                    defaultLabel.accessibleHidden = true;\n                }\n            }\n        }\n    }\n    setErrorOnControlElement(controlElement) {\n        var _a;\n        if (controlElement && ((_a = this.errors) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n            controlElement.setAttribute('error', 'true');\n        }\n        else {\n            controlElement === null || controlElement === void 0 ? void 0 : controlElement.removeAttribute('error');\n        }\n    }\n    handleErrorSlotChanged() {\n        const items = this.errorSlot.assignedElements({ flatten: true });\n        this.errors = items.map(item => item.textContent || '');\n    }\n    handleErrorsChanged() {\n        const [controlElement] = this._controlElements;\n        this.setErrorOnControlElement(controlElement);\n    }\n    /** Sets the errors for the form-field. */\n    setErrors(errors) {\n        this.errors = errors;\n    }\n    /** Clears the errors for the form-field. */\n    clearErrors() {\n        this.errors = [];\n    }\n    render() {\n        var _a;\n        return html `\r\n      <div part=\"base\" class=\"form-field\">\r\n        <div class=\"heading-container\">\r\n          ${this.hasSlotController.test('label')\n            ? html `<div class=\"label\" part=\"label\">\r\n                <slot name=\"label\"></slot>\r\n              </div>`\n            : this.label\n                ? html `<koerber-form-field-label\r\n                  class=\"label\"\r\n                  label=${this.label}\r\n                  tooltip=${this.tooltip}\r\n                  ?required=${this.required}\r\n                ></koerber-form-field-label>`\n                : ''}\r\n          ${this.valueHint ? html `<div class=\"value-hint\">${this.valueHint}</div>` : ''}\r\n        </div>\r\n        <div part=\"form-control\" class=\"form-control\">\r\n          <slot name=\"prefix\"></slot>\r\n          <div class=\"control\">\r\n            <slot @slotchange=${this.handleSlotChange}></slot>\r\n          </div>\r\n          <slot name=\"suffix\"></slot>\r\n        </div>\r\n\r\n        <!-- DO NOT TOUCH ARIA-HIDDEN PROPERTY -->\r\n        <slot name=\"help-text\" class=\"help-text\" aria-hidden>${this.helpText}</slot>\r\n\r\n        ${this.hasSlotController.test('error')\n            ? html `<div class=\"error\" part=\"error\">\r\n              <slot name=\"error\" @slotchange=${this.handleErrorSlotChanged}></slot>\r\n            </div>`\n            : this.errors && this.errors.length !== 0\n                ? html `<div class=\"error\" part=\"error\">\r\n                ${(_a = this.errors) === null || _a === void 0 ? void 0 : _a.map(error => html `<koerber-form-field-error class=\"error-message\">${error}</koerber-form-field-error>`)}\r\n              </div>`\n                : ''}\r\n        ${this.hasSlotController.test('footer')\n            ? html `<div class=\"footer\">\r\n              <slot name=\"footer\" part=\"form-field-footer\"></slot>\r\n            </div>`\n            : ''}\r\n      </div>\r\n    `;\n    }\n}\nFormField.styles = styles;\nFormField.dependencies = { 'koerber-form-field-label': FormFieldLabel, 'koerber-form-field-error': FormFieldError };\nexport default FormField;\n__decorate([\n    query('slot:not([name])')\n], FormField.prototype, \"defaultSlot\", void 0);\n__decorate([\n    query('slot[name=error]')\n], FormField.prototype, \"errorSlot\", void 0);\n__decorate([\n    query('slot[name=\"suffix\"]')\n], FormField.prototype, \"suffixSlot\", void 0);\n__decorate([\n    queryAssignedElements()\n], FormField.prototype, \"_controlElements\", void 0);\n__decorate([\n    queryAssignedElements({ slot: 'label' })\n], FormField.prototype, \"_labelElements\", void 0);\n__decorate([\n    property({ attribute: 'help-text' })\n], FormField.prototype, \"helpText\", void 0);\n__decorate([\n    property({ type: Array, reflect: true })\n], FormField.prototype, \"errors\", void 0);\n__decorate([\n    property({ reflect: true })\n], FormField.prototype, \"label\", void 0);\n__decorate([\n    property({ attribute: 'value-hint' })\n], FormField.prototype, \"valueHint\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], FormField.prototype, \"required\", void 0);\n__decorate([\n    property({ reflect: true })\n], FormField.prototype, \"tooltip\", void 0);\n__decorate([\n    watch('errors')\n], FormField.prototype, \"handleErrorsChanged\", null);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { classMap } from 'lit/directives/class-map.js';\nimport { html, literal } from 'lit/static-html.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { property, query, state } from 'lit/decorators.js';\nimport componentStyles from '../../styles/component.styles';\nimport Icon from '../icon/icon.component';\nimport styles from './icon-button.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Icons buttons are simple, icon-only buttons that can be used for actions and in toolbars.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net\n * @status stable\n * @since 2.0\n *\n * @dependency koerber-icon\n *\n * @event koerber-blur - Emitted when the icon button loses focus.\n * @event koerber-focus - Emitted when the icon button gains focus.\n *\n * @csspart base - The component's base wrapper.\n */\n// INTERNAL ONLY\nclass IconButton extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.hasFocus = false;\n        /** The icon's size. */\n        this.size = 'medium';\n        /**\n         * A description that gets read by assistive devices. For optimal accessibility, you should always include a label\n         * that describes what the icon button does.\n         */\n        this.label = '';\n        /** Disables the button. */\n        this.disabled = false;\n    }\n    handleBlur() {\n        this.hasFocus = false;\n        this.emit('koerber-blur');\n    }\n    handleFocus() {\n        this.hasFocus = true;\n        this.emit('koerber-focus');\n    }\n    handleClick(event) {\n        if (this.disabled) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    }\n    /** Simulates a click on the icon button. */\n    click() {\n        this.button.click();\n    }\n    /** Sets focus on the icon button. */\n    focus(options) {\n        this.button.focus(options);\n    }\n    /** Removes focus from the icon button. */\n    blur() {\n        this.button.blur();\n    }\n    render() {\n        const isLink = this.href ? true : false;\n        const tag = isLink ? literal `a` : literal `button`;\n        /* eslint-disable lit/binding-positions, lit/no-invalid-html */\n        return html `\r\n      <${tag}\r\n        part=\"base\"\r\n        class=${classMap({\n            'icon-button': true,\n            'icon-button--disabled': !isLink && this.disabled,\n            'icon-button--focused': this.hasFocus\n        })}\r\n        ?disabled=${ifDefined(isLink ? undefined : this.disabled)}\r\n        type=${ifDefined(isLink ? undefined : 'button')}\r\n        href=${ifDefined(isLink ? this.href : undefined)}\r\n        target=${ifDefined(isLink ? this.target : undefined)}\r\n        download=${ifDefined(isLink ? this.download : undefined)}\r\n        rel=${ifDefined(isLink && this.target ? 'noreferrer noopener' : undefined)}\r\n        role=${ifDefined(isLink ? undefined : 'button')}\r\n        aria-disabled=${this.disabled ? 'true' : 'false'}\r\n        aria-label=\"${this.label}\"\r\n        tabindex=${this.disabled ? '-1' : '0'}\r\n        @blur=${this.handleBlur}\r\n        @focus=${this.handleFocus}\r\n        @click=${this.handleClick}\r\n      >\r\n        <koerber-icon\r\n          size=${ifDefined(this.size)}\r\n          class=\"icon-button__icon\"\r\n          name=${ifDefined(this.name)}\r\n          library=${ifDefined(this.library)}\r\n          src=${ifDefined(this.src)}\r\n          aria-hidden=\"true\"\r\n        ></koerber-icon>\r\n      </${tag}>\r\n    `;\n    }\n}\nIconButton.styles = [componentStyles, styles];\nIconButton.dependencies = { 'koerber-icon': Icon };\nexport default IconButton;\n__decorate([\n    query('.icon-button')\n], IconButton.prototype, \"button\", void 0);\n__decorate([\n    state()\n], IconButton.prototype, \"hasFocus\", void 0);\n__decorate([\n    property()\n], IconButton.prototype, \"name\", void 0);\n__decorate([\n    property()\n], IconButton.prototype, \"library\", void 0);\n__decorate([\n    property()\n], IconButton.prototype, \"src\", void 0);\n__decorate([\n    property()\n], IconButton.prototype, \"href\", void 0);\n__decorate([\n    property()\n], IconButton.prototype, \"target\", void 0);\n__decorate([\n    property()\n], IconButton.prototype, \"download\", void 0);\n__decorate([\n    property({ reflect: true })\n], IconButton.prototype, \"size\", void 0);\n__decorate([\n    property()\n], IconButton.prototype, \"label\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], IconButton.prototype, \"disabled\", void 0);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/** Exception due eslint doesn't support WAI-ARIA 1.3 that supports aria-description attr */\n/* eslint-disable lit-a11y/aria-attrs */\nimport Divider from '../divider/divider.component';\nimport Icon from '../icon/icon.component';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { html } from 'lit';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { live } from 'lit/directives/live.js';\nimport { property, query, state } from 'lit/decorators.js';\nimport { defaultValue } from '../../internal/default-value';\nimport { LocalizeController } from '../../utilities/localize';\nimport { watch } from '../../internal/watch';\nimport componentStyles from '../../styles/component.styles';\nimport formControlStyles from '../../styles/form-control.styles';\nimport styles from './input.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Inputs collect data from the user.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-input--docs\n * @status stable\n * @since 2.0\n *\n * @dependency koerber-icon\n *\n * @slot prefix - Used to prepend a presentational icon or similar element to the input.\n * @slot suffix - Used to append a presentational icon or similar element to the input.\n * @slot clear-icon - An icon to use in lieu of the default clear icon.\n * @slot show-password-icon - An icon to use in lieu of the default show password icon.\n * @slot hide-password-icon - An icon to use in lieu of the default hide password icon.\n *\n * @event koerber-blur - Emitted when the control loses focus.\n * @event koerber-change - Emitted when an alteration to the control's value is committed by the user.\n * @event koerber-clear - Emitted when the clear button is activated.\n * @event koerber-focus - Emitted when the control gains focus.\n * @event koerber-input - Emitted when the control receives input.\n *\n * @csspart base - The component's base wrapper.\n * @csspart input - The internal `<input>` control.\n * @csspart prefix - The container that wraps the prefix.\n * @csspart clear-button - The clear button.\n * @csspart password-toggle-button - The password toggle button.\n * @csspart suffix - The container that wraps the suffix.\n\n */\nclass Input extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.localize = new LocalizeController(this);\n        this.hasFocus = false;\n        this.title = ''; // make reactive to pass through\n        /**\n         * The type of input. Works the same as a native `<input>` element, but only a subset of types are supported. Defaults\n         * to `text`.\n         */\n        this.type = 'text';\n        /** The name of the input, submitted as a name/value pair with form data. */\n        this.name = '';\n        /** The current value of the input, submitted as a name/value pair with form data. */\n        this.value = '';\n        /** The default value of the form control. Primarily used for resetting the form control. */\n        this.defaultValue = '';\n        /** The input's size. */\n        this.size = 'medium';\n        /** Adds a clear button when the input is not empty. */\n        this.clearable = false;\n        /** Disables the input. */\n        this.disabled = false;\n        /** Placeholder text to show as a hint when the input is empty. */\n        this.placeholder = '';\n        /** Makes the input readonly. */\n        this.readonly = false;\n        /** Adds a button to toggle the password's visibility. Only applies to password types. */\n        this.passwordToggle = false;\n        /** Determines whether or not the password is currently visible. Only applies to password input types. */\n        this.passwordVisible = false;\n        /** Enables spell checking on the input. */\n        this.spellcheck = true;\n        /**\n         * Used to indicate that the input has some error based on some rule.\n         */\n        this.error = false;\n        /**\n         * Used to define an Icon as a prefix of Input\n         */\n        this.prefixIcon = '';\n        /** Used to define an Icon as a suffix of Input */\n        this.suffixIcon = '';\n    }\n    /** Gets or sets the current value as a `Date` object. Returns `null` if the value can't be converted. */\n    get valueAsDate() {\n        var _a, _b;\n        return (_b = (_a = this.input) === null || _a === void 0 ? void 0 : _a.valueAsDate) !== null && _b !== void 0 ? _b : null;\n    }\n    set valueAsDate(newValue) {\n        // We use an in-memory input instead of the one in the template because the property can be set before render\n        const input = document.createElement('input');\n        input.type = 'date';\n        input.valueAsDate = newValue;\n        this.value = input.value;\n    }\n    /** Gets or sets the current value as a number. Returns `NaN` if the value can't be converted. */\n    get valueAsNumber() {\n        var _a, _b;\n        return (_b = (_a = this.input) === null || _a === void 0 ? void 0 : _a.valueAsNumber) !== null && _b !== void 0 ? _b : parseFloat(this.value);\n    }\n    set valueAsNumber(newValue) {\n        // We use an in-memory input instead of the one in the template because the property can be set before render\n        const input = document.createElement('input');\n        input.type = 'number';\n        input.valueAsNumber = newValue;\n        this.value = input.value;\n    }\n    handleBlur() {\n        this.hasFocus = false;\n        this.emit('koerber-blur');\n    }\n    handleChange() {\n        this.value = this.input.value;\n        this.emit('koerber-change');\n    }\n    handleClearClick(event) {\n        this.value = '';\n        this.emit('koerber-clear');\n        this.emit('koerber-input');\n        this.emit('koerber-change');\n        this.input.focus();\n        event.stopPropagation();\n    }\n    handleIncreaseValueClick(event) {\n        this.stepUp();\n        this.emit('koerber-input');\n        this.emit('koerber-change');\n        this.input.focus();\n        event.stopPropagation();\n    }\n    handleDecreaseValueClick(event) {\n        this.stepDown();\n        this.emit('koerber-input');\n        this.emit('koerber-change');\n        this.input.focus();\n        event.stopPropagation();\n    }\n    handleFocus() {\n        this.hasFocus = true;\n        this.emit('koerber-focus');\n    }\n    handleInput() {\n        this.value = this.input.value;\n        this.emit('koerber-input');\n    }\n    handlePasswordToggle() {\n        this.passwordVisible = !this.passwordVisible;\n    }\n    handleStepChange() {\n        // If step changes, the value may become invalid so we need to recheck after the update. We set the new step\n        // imperatively so we don't have to wait for the next render to report the updated validity.\n        this.input.step = String(this.step);\n    }\n    async handleValueChange() {\n        await this.updateComplete;\n    }\n    /** Sets focus on the input. */\n    focus(options) {\n        this.input.focus(options);\n    }\n    /** Removes focus from the input. */\n    blur() {\n        this.input.blur();\n    }\n    /** Selects all the text in the input. */\n    select() {\n        this.input.select();\n    }\n    /** Sets the start and end positions of the text selection (0-based). */\n    setSelectionRange(selectionStart, selectionEnd, selectionDirection = 'none') {\n        this.input.setSelectionRange(selectionStart, selectionEnd, selectionDirection);\n    }\n    /** Replaces a range of text with a new string. */\n    setRangeText(replacement, start, end, selectMode) {\n        // @ts-expect-error - start, end, and selectMode are optional\n        this.input.setRangeText(replacement, start, end, selectMode);\n        if (this.value !== this.input.value) {\n            this.value = this.input.value;\n        }\n    }\n    /** Displays the browser picker for an input element (only works if the browser supports it for the input type). */\n    showPicker() {\n        if ('showPicker' in HTMLInputElement.prototype) {\n            this.input.showPicker();\n        }\n    }\n    /** Increments the value of a numeric input type by the value of the step attribute. */\n    stepUp() {\n        this.input.stepUp();\n        if (this.value !== this.input.value) {\n            this.value = this.input.value;\n        }\n    }\n    /** Decrements the value of a numeric input type by the value of the step attribute. */\n    stepDown() {\n        this.input.stepDown();\n        if (this.value !== this.input.value) {\n            this.value = this.input.value;\n        }\n    }\n    render() {\n        const hasClearIcon = this.clearable && !this.disabled && !this.readonly && (typeof this.value === 'number' || this.value.length > 0);\n        /* icon size supports only medium and large sizes*/\n        const iconSize = this.size === 'small' ? 'medium' : this.size;\n        return html `\r\n      <div\r\n        part=\"form-control\"\r\n        class=${classMap({\n            'form-control': true,\n            'form-control--small': this.size === 'small',\n            'form-control--medium': this.size === 'medium',\n            'form-control--large': this.size === 'large'\n        })}\r\n      >\r\n        <div part=\"form-control-input\" class=\"form-control-input\">\r\n          <div\r\n            part=\"base\"\r\n            class=${classMap({\n            input: true,\n            // Sizes\n            'input--small': this.size === 'small',\n            'input--medium': this.size === 'medium',\n            'input--large': this.size === 'large',\n            // States\n            'input--standard': true,\n            'input--disabled': this.disabled,\n            'input--focused': this.hasFocus,\n            'input--empty': !this.value,\n            'input--no-spin-buttons': this.type === 'number',\n            // add error\n            'input--error': this.error\n        })}\r\n          >\r\n        ${this.prefixIcon\n            ? html `<koerber-icon size=${iconSize} class=\"input__prefix\" name=${this.prefixIcon}></koerber-icon>`\n            : ''}\r\n\r\n            <input\r\n              part=\"input\"\r\n              id=\"input\"\r\n              class=\"input__control\"\r\n              type=${this.type === 'password' && this.passwordVisible ? 'text' : this.type}\r\n              title=${this.title /* An empty title prevents browser validation tooltips from appearing on hover */}\r\n              name=${ifDefined(this.name)}\r\n              aria-label=${ifDefined(this.accessibleName)}\r\n              aria-description=${ifDefined(this.accessibleDescription)}\r\n              ?disabled=${this.disabled}\r\n              ?readonly=${this.readonly}\r\n              placeholder=${ifDefined(this.placeholder)}\r\n              step=${ifDefined(this.step)}\r\n              .value=${live(this.value)}\r\n              autocapitalize=${ifDefined(this.autocapitalize)}\r\n              autocomplete=${ifDefined(this.autocomplete)}\r\n              autocorrect=${ifDefined(this.autocorrect)}\r\n              ?autofocus=${this.autofocus}\r\n              spellcheck=${this.spellcheck}\r\n              enterkeyhint=${ifDefined(this.enterkeyhint)}\r\n              inputmode=${ifDefined(this.inputmode)}\r\n              @change=${this.handleChange}\r\n              @input=${this.handleInput}\r\n              @focus=${this.handleFocus}\r\n              @blur=${this.handleBlur}\r\n            />\r\n\r\n            ${hasClearIcon\n            ? html `\r\n                    <button\r\n                      part=\"clear-button\"\r\n                      class=\"input__clear\"\r\n                      type=\"button\"\r\n                      aria-label=${this.localize.term('clearEntry')}\r\n                      @click=${this.handleClearClick}\r\n                      tabindex=\"-1\"\r\n                    >\r\n                      <slot name=\"clear-icon\">\r\n                        <koerber-icon name=\"close\" library=\"system\" size=${iconSize}></koerber-icon>\r\n                      </slot>\r\n                    </button>\r\n                  `\n            : ''}\r\n              ${this.error\n            ? html `\r\n                      <div class=\"input-error-icon-slot\">\r\n                        <koerber-icon class=\"input-error-icon\" name=\"alert\" size=${iconSize}></koerber-icon>\r\n                      </div>\r\n                    `\n            : ''}\r\n            ${this.type === 'password' && this.passwordToggle && !this.disabled\n            ? html `\r\n                    <button\r\n                      part=\"password-toggle-button\"\r\n                      class=\"input__password-toggle\"\r\n                      type=\"button\"\r\n                      aria-label=${this.localize.term(this.passwordVisible ? 'hidePassword' : 'showPassword')}\r\n                      @click=${this.handlePasswordToggle}\r\n                      tabindex=\"-1\"\r\n                    >\r\n                      ${this.passwordVisible\n                ? html `\r\n                            <slot name=\"show-password-icon\">\r\n                              <koerber-icon name=\"eye-off\" library=\"system\" size=${iconSize}></koerber-icon>\r\n                            </slot>\r\n                          `\n                : html `\r\n                            <slot name=\"hide-password-icon\">\r\n                              <koerber-icon name=\"eye\" library=\"system\" size=${iconSize}></koerber-icon>\r\n                            </slot>\r\n                          `}\r\n                    </button>\r\n                  `\n            : ''}\r\n          ${this.suffixIcon\n            ? html ` <koerber-icon size=${iconSize} class=\"input__suffix\" name=${this.suffixIcon}></koerber-icon>`\n            : ''}\r\n          ${this.type === 'number'\n            ? html ` <button\r\n                    part=\"decrease-button\"\r\n                    class=\"input__decrease\"\r\n                    type=\"button\"\r\n                    aria-label=${this.localize.term('decreaseValue')}\r\n                    @click=${this.handleDecreaseValueClick}\r\n                    tabindex=\"-1\"\r\n                  >\r\n                    <koerber-icon name=\"minus\" library=\"system\" size=${iconSize}></koerber-icon>\r\n                  </button>\r\n                  <koerber-divider class=\"divider__vertical\" vertical></koerber-divider>\r\n                  <button\r\n                    part=\"increase-button\"\r\n                    class=\"input__increase\"\r\n                    type=\"button\"\r\n                    aria-label=${this.localize.term('increaseValue')}\r\n                    @click=${this.handleIncreaseValueClick}\r\n                    tabindex=\"-1\"\r\n                  >\r\n                    <koerber-icon name=\"plus\" library=\"system\" size=${iconSize}></koerber-icon>\r\n                  </button>`\n            : ''}\r\n          </div>\r\n        </div>\r\n        </div>\r\n      </div>\r\n    `;\n    }\n}\nInput.styles = [componentStyles, formControlStyles, styles];\nInput.dependencies = { 'koerber-icon': Icon, 'koerber-divider': Divider };\nexport default Input;\n__decorate([\n    query('.input__control')\n], Input.prototype, \"input\", void 0);\n__decorate([\n    state()\n], Input.prototype, \"hasFocus\", void 0);\n__decorate([\n    property()\n], Input.prototype, \"title\", void 0);\n__decorate([\n    property({ reflect: true })\n], Input.prototype, \"type\", void 0);\n__decorate([\n    property()\n], Input.prototype, \"name\", void 0);\n__decorate([\n    property()\n], Input.prototype, \"value\", void 0);\n__decorate([\n    defaultValue()\n], Input.prototype, \"defaultValue\", void 0);\n__decorate([\n    property({ reflect: true })\n], Input.prototype, \"size\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Input.prototype, \"clearable\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Input.prototype, \"disabled\", void 0);\n__decorate([\n    property()\n], Input.prototype, \"placeholder\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Input.prototype, \"readonly\", void 0);\n__decorate([\n    property({ attribute: 'password-toggle', type: Boolean })\n], Input.prototype, \"passwordToggle\", void 0);\n__decorate([\n    property({ attribute: 'password-visible', type: Boolean })\n], Input.prototype, \"passwordVisible\", void 0);\n__decorate([\n    property()\n], Input.prototype, \"step\", void 0);\n__decorate([\n    property()\n], Input.prototype, \"autocapitalize\", void 0);\n__decorate([\n    property()\n], Input.prototype, \"autocorrect\", void 0);\n__decorate([\n    property()\n], Input.prototype, \"autocomplete\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Input.prototype, \"autofocus\", void 0);\n__decorate([\n    property()\n], Input.prototype, \"enterkeyhint\", void 0);\n__decorate([\n    property({\n        type: Boolean,\n        converter: {\n            // Allow \"true|false\" attribute values but keep the property boolean\n            fromAttribute: value => (!value || value === 'false' ? false : true),\n            toAttribute: value => (value ? 'true' : 'false')\n        }\n    })\n], Input.prototype, \"spellcheck\", void 0);\n__decorate([\n    property()\n], Input.prototype, \"inputmode\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Input.prototype, \"error\", void 0);\n__decorate([\n    property({ attribute: 'prefix-icon' })\n], Input.prototype, \"prefixIcon\", void 0);\n__decorate([\n    property({ attribute: 'suffix-icon' })\n], Input.prototype, \"suffixIcon\", void 0);\n__decorate([\n    property({ attribute: 'accessible-name', reflect: true })\n], Input.prototype, \"accessibleName\", void 0);\n__decorate([\n    property({ attribute: 'accessible-description', reflect: true })\n], Input.prototype, \"accessibleDescription\", void 0);\n__decorate([\n    watch('step', { waitUntilFirstUpdate: true })\n], Input.prototype, \"handleStepChange\", null);\n__decorate([\n    watch('value', { waitUntilFirstUpdate: true })\n], Input.prototype, \"handleValueChange\", null);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { arrow, autoUpdate, computePosition, flip, offset, platform, shift, size } from '@floating-ui/dom';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { html } from 'lit';\nimport { offsetParent } from 'composed-offset-position';\nimport { property, query } from 'lit/decorators.js';\nimport componentStyles from '../../styles/component.styles';\nimport styles from './popup.styles';\nimport UIKitElement from '../../internal/uikit-element';\nfunction isVirtualElement(e) {\n    return e !== null && typeof e === 'object' && 'getBoundingClientRect' in e;\n}\n/**\n * @summary Popup is a utility that lets you declaratively anchor \"popup\" containers to another element.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-popup--docs\n * @status stable\n * @since 2.0\n *\n * @event koerber-reposition - Emitted when the popup is repositioned. This event can fire a lot, so avoid putting expensive\n *  operations in your listener or consider debouncing it.\n *\n * @slot - The popup's content.\n * @slot anchor - The element the popup will be anchored to. If the anchor lives outside of the popup, you can use the\n *  `anchor` attribute or property instead.\n *\n * @csspart arrow - The arrow's container. Avoid setting `top|bottom|left|right` properties, as these values are\n *  assigned dynamically as the popup moves. This is most useful for applying a background color to match the popup, and\n *  maybe a border or box shadow.\n * @csspart popup - The popup's container. Useful for setting a background color, box shadow, etc.\n * @csspart hover-bridge - The hover bridge element. Only available when the `hover-bridge` option is enabled.\n *\n * @cssproperty [--arrow-size=6px] - The size of the arrow. Note that an arrow won't be shown unless the `arrow`\n *  attribute is used.\n * @cssproperty [--arrow-color=var(--koerber-color-neutral-0)] - The color of the arrow.\n * @cssproperty [--auto-size-available-width] - A read-only custom property that determines the amount of width the\n *  popup can be before overflowing. Useful for positioning child elements that need to overflow. This property is only\n *  available when using `auto-size`.\n * @cssproperty [--auto-size-available-height] - A read-only custom property that determines the amount of height the\n *  popup can be before overflowing. Useful for positioning child elements that need to overflow. This property is only\n *  available when using `auto-size`.\n */\nclass Popup extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * Activates the positioning logic and shows the popup. When this attribute is removed, the positioning logic is torn\n         * down and the popup will be hidden.\n         */\n        this.active = false;\n        /**\n         * The color variant of the popup. Valid options are `default`, `unstyled`, and `interactive`.\n         */\n        this.colorVariant = 'unstyled';\n        /**\n         * The preferred placement of the popup. Note that the actual placement will vary as configured to keep the\n         * panel inside of the viewport.\n         */\n        this.placement = 'top';\n        /**\n         * Determines how the popup is positioned. The `absolute` strategy works well in most cases, but if overflow is\n         * clipped, using a `fixed` position strategy can often workaround it.\n         */\n        this.strategy = 'absolute';\n        /** The distance in pixels from which to offset the panel along its anchor. */\n        this.skidding = 0;\n        /**\n         * Attaches an arrow to the popup. The arrow's size and color can be customized using the `--arrow-size` and\n         * `--arrow-color` custom properties. For additional customizations, you can also target the arrow using\n         * `::part(arrow)` in your stylesheet.\n         */\n        this.arrow = false;\n        /**\n         * The placement of the arrow. The default is `anchor`, which will align the arrow as close to the center of the\n         * anchor as possible, considering available space and `arrow-padding`. A value of `start`, `end`, or `center` will\n         * align the arrow to the start, end, or center of the popover instead.\n         */\n        this.arrowPlacement = 'anchor';\n        /**\n         * The amount of padding between the arrow and the edges of the popup. If the popup has a border-radius, for example,\n         * this will prevent it from overflowing the corners.\n         */\n        this.arrowPadding = 10;\n        /**\n         * When set, placement of the popup will flip to the opposite site to keep it in view. You can use\n         * `flipFallbackPlacements` to further configure how the fallback placement is determined.\n         */\n        this.flip = false;\n        /**\n         * If the preferred placement doesn't fit, popup will be tested in these fallback placements until one fits. Must be a\n         * string of any number of placements separated by a space, e.g. \"top bottom left\". If no placement fits, the flip\n         * fallback strategy will be used instead.\n         * */\n        this.flipFallbackPlacements = '';\n        /**\n         * When neither the preferred placement nor the fallback placements fit, this value will be used to determine whether\n         * the popup should be positioned using the best available fit based on available space or as it was initially\n         * preferred.\n         */\n        this.flipFallbackStrategy = 'best-fit';\n        /** The amount of padding, in pixels, to exceed before the flip behavior will occur. */\n        this.flipPadding = 0;\n        /** Moves the popup along the axis to keep it in view when clipped. */\n        this.shift = false;\n        /** The amount of padding, in pixels, to exceed before the shift behavior will occur. */\n        this.shiftPadding = 0;\n        /** The amount of padding, in pixels, to exceed before the auto-size behavior will occur. */\n        this.autoSizePadding = 0;\n        /**\n         * When a gap exists between the anchor and the popup element, this option will add a \"hover bridge\" that fills the\n         * gap using an invisible element. This makes listening for events such as `mouseenter` and `mouseleave` more sane\n         * because the pointer never technically leaves the element. The hover bridge will only be drawn when the popover is\n         * active.\n         */\n        this.hoverBridge = false;\n        this.updateHoverBridge = () => {\n            if (this.hoverBridge && this.anchorEl) {\n                const anchorRect = this.anchorEl.getBoundingClientRect();\n                const popupRect = this.popup.getBoundingClientRect();\n                const isVertical = this.placement.includes('top') || this.placement.includes('bottom');\n                let topLeftX = 0;\n                let topLeftY = 0;\n                let topRightX = 0;\n                let topRightY = 0;\n                let bottomLeftX = 0;\n                let bottomLeftY = 0;\n                let bottomRightX = 0;\n                let bottomRightY = 0;\n                if (isVertical) {\n                    if (anchorRect.top < popupRect.top) {\n                        // Anchor is above\n                        topLeftX = anchorRect.left;\n                        topLeftY = anchorRect.bottom;\n                        topRightX = anchorRect.right;\n                        topRightY = anchorRect.bottom;\n                        bottomLeftX = popupRect.left;\n                        bottomLeftY = popupRect.top;\n                        bottomRightX = popupRect.right;\n                        bottomRightY = popupRect.top;\n                    }\n                    else {\n                        // Anchor is below\n                        topLeftX = popupRect.left;\n                        topLeftY = popupRect.bottom;\n                        topRightX = popupRect.right;\n                        topRightY = popupRect.bottom;\n                        bottomLeftX = anchorRect.left;\n                        bottomLeftY = anchorRect.top;\n                        bottomRightX = anchorRect.right;\n                        bottomRightY = anchorRect.top;\n                    }\n                }\n                else {\n                    if (anchorRect.left < popupRect.left) {\n                        // Anchor is on the left\n                        topLeftX = anchorRect.right;\n                        topLeftY = anchorRect.top;\n                        topRightX = popupRect.left;\n                        topRightY = popupRect.top;\n                        bottomLeftX = anchorRect.right;\n                        bottomLeftY = anchorRect.bottom;\n                        bottomRightX = popupRect.left;\n                        bottomRightY = popupRect.bottom;\n                    }\n                    else {\n                        // Anchor is on the right\n                        topLeftX = popupRect.right;\n                        topLeftY = popupRect.top;\n                        topRightX = anchorRect.left;\n                        topRightY = anchorRect.top;\n                        bottomLeftX = popupRect.right;\n                        bottomLeftY = popupRect.bottom;\n                        bottomRightX = anchorRect.left;\n                        bottomRightY = anchorRect.bottom;\n                    }\n                }\n                this.style.setProperty('--hover-bridge-top-left-x', `${topLeftX}px`);\n                this.style.setProperty('--hover-bridge-top-left-y', `${topLeftY}px`);\n                this.style.setProperty('--hover-bridge-top-right-x', `${topRightX}px`);\n                this.style.setProperty('--hover-bridge-top-right-y', `${topRightY}px`);\n                this.style.setProperty('--hover-bridge-bottom-left-x', `${bottomLeftX}px`);\n                this.style.setProperty('--hover-bridge-bottom-left-y', `${bottomLeftY}px`);\n                this.style.setProperty('--hover-bridge-bottom-right-x', `${bottomRightX}px`);\n                this.style.setProperty('--hover-bridge-bottom-right-y', `${bottomRightY}px`);\n            }\n        };\n    }\n    async connectedCallback() {\n        super.connectedCallback();\n        // Start the positioner after the first update\n        await this.updateComplete;\n        this.start();\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this.stop();\n    }\n    async updated(changedProps) {\n        super.updated(changedProps);\n        // Start or stop the positioner when active changes\n        if (changedProps.has('active')) {\n            if (this.active) {\n                this.start();\n            }\n            else {\n                this.stop();\n            }\n        }\n        // Change distance was not set by user\n        if (!this.hasAttribute('distance')) {\n            this.distance = this.arrow ? 10 : 4;\n        }\n        // Make sure the popup is repositioned when the anchor changes\n        if (changedProps.has('anchor')) {\n            await this.handleAnchorChange();\n        }\n        // All other properties will trigger a reposition when active\n        if (this.active) {\n            await this.updateComplete;\n            this.reposition();\n        }\n    }\n    async handleAnchorChange() {\n        await this.stop();\n        if (this.anchor && typeof this.anchor === 'string') {\n            // Locate the anchor by id\n            const root = this.getRootNode();\n            this.anchorEl = root.getElementById(this.anchor);\n        }\n        else if (this.anchor instanceof Element || isVirtualElement(this.anchor)) {\n            // Use the anchor's reference\n            this.anchorEl = this.anchor;\n        }\n        else {\n            // Look for a slotted anchor\n            this.anchorEl = this.querySelector('[slot=\"anchor\"]');\n        }\n        // If the anchor is a <slot>, we'll use the first assigned element as the target since slots use `display: contents`\n        // and positioning can't be calculated on them\n        if (this.anchorEl instanceof HTMLSlotElement) {\n            this.anchorEl = this.anchorEl.assignedElements({ flatten: true })[0];\n        }\n        // If the anchor is valid, start it up\n        if (this.anchorEl) {\n            this.start();\n        }\n        else {\n            throw new Error('Invalid anchor element: no anchor could be found using the anchor slot or the anchor attribute.');\n        }\n    }\n    start() {\n        // We can't start the positioner without an anchor\n        if (!this.anchorEl) {\n            return;\n        }\n        this.cleanup = autoUpdate(this.anchorEl, this.popup, () => {\n            this.reposition();\n        });\n    }\n    async stop() {\n        return new Promise(resolve => {\n            if (this.cleanup) {\n                this.cleanup();\n                this.cleanup = undefined;\n                this.removeAttribute('data-current-placement');\n                this.style.removeProperty('--auto-size-available-width');\n                this.style.removeProperty('--auto-size-available-height');\n                requestAnimationFrame(() => resolve());\n            }\n            else {\n                resolve();\n            }\n        });\n    }\n    /** Forces the popup to recalculate and reposition itself. */\n    reposition() {\n        // Nothing to do if the popup is inactive or the anchor doesn't exist\n        if (!this.active || !this.anchorEl) {\n            return;\n        }\n        //\n        // NOTE: Floating UI middlewares are order dependent: https://floating-ui.com/docs/middleware\n        //\n        const middleware = [\n            // The offset middleware goes first\n            offset({ mainAxis: this.distance, crossAxis: this.skidding })\n        ];\n        // First we sync width/height\n        if (this.sync) {\n            middleware.push(size({\n                apply: ({ rects }) => {\n                    const syncWidth = this.sync === 'width' || this.sync === 'both';\n                    const syncHeight = this.sync === 'height' || this.sync === 'both';\n                    this.popup.style.width = syncWidth ? `${rects.reference.width}px` : '';\n                    this.popup.style.height = syncHeight ? `${rects.reference.height}px` : '';\n                }\n            }));\n        }\n        else {\n            // Cleanup styles if we're not matching width/height\n            this.popup.style.width = '';\n            this.popup.style.height = '';\n        }\n        // Then we flip\n        if (this.flip) {\n            middleware.push(flip({\n                boundary: this.flipBoundary,\n                // @ts-expect-error - We're converting a string attribute to an array here\n                fallbackPlacements: this.flipFallbackPlacements,\n                fallbackStrategy: this.flipFallbackStrategy === 'best-fit' ? 'bestFit' : 'initialPlacement',\n                padding: this.flipPadding\n            }));\n        }\n        // Then we shift\n        if (this.shift) {\n            middleware.push(shift({\n                boundary: this.shiftBoundary,\n                padding: this.shiftPadding\n            }));\n        }\n        // Now we adjust the size as needed\n        if (this.autoSize) {\n            middleware.push(size({\n                boundary: this.autoSizeBoundary,\n                padding: this.autoSizePadding,\n                apply: ({ availableWidth, availableHeight }) => {\n                    if (this.autoSize === 'vertical' || this.autoSize === 'both') {\n                        this.style.setProperty('--auto-size-available-height', `${availableHeight}px`);\n                    }\n                    else {\n                        this.style.removeProperty('--auto-size-available-height');\n                    }\n                    if (this.autoSize === 'horizontal' || this.autoSize === 'both') {\n                        this.style.setProperty('--auto-size-available-width', `${availableWidth}px`);\n                    }\n                    else {\n                        this.style.removeProperty('--auto-size-available-width');\n                    }\n                }\n            }));\n        }\n        else {\n            // Cleanup styles if we're no longer using auto-size\n            this.style.removeProperty('--auto-size-available-width');\n            this.style.removeProperty('--auto-size-available-height');\n        }\n        // Finally, we add an arrow\n        if (this.arrow) {\n            middleware.push(arrow({\n                element: this.arrowEl,\n                padding: this.arrowPadding\n            }));\n        }\n        //\n        // Use custom positioning logic if the strategy is absolute. Otherwise, fall back to the default logic.\n        //\n        // More info: https://github.com/shoelace-style/shoelace/issues/1135\n        //\n        const getOffsetParent = this.strategy === 'absolute'\n            ? (element) => platform.getOffsetParent(element, offsetParent)\n            : platform.getOffsetParent;\n        computePosition(this.anchorEl, this.popup, {\n            placement: this.placement,\n            middleware,\n            strategy: this.strategy,\n            platform: Object.assign(Object.assign({}, platform), { getOffsetParent })\n        }).then(({ x, y, middlewareData, placement }) => {\n            //\n            // Even though we have our own localization utility, it uses different heuristics to determine RTL. Because of\n            // that, we'll use the same approach that Floating UI uses.\n            //\n            // Source: https://github.com/floating-ui/floating-ui/blob/cb3b6ab07f95275730d3e6e46c702f8d4908b55c/packages/dom/src/utils/getDocumentRect.ts#L31\n            //\n            const isRtl = getComputedStyle(this).direction === 'rtl';\n            const staticSide = { top: 'bottom', right: 'left', bottom: 'top', left: 'right' }[placement.split('-')[0]];\n            this.setAttribute('data-current-placement', placement);\n            Object.assign(this.popup.style, {\n                left: `${x}px`,\n                top: `${y}px`\n            });\n            if (this.arrow) {\n                const arrowX = middlewareData.arrow.x;\n                const arrowY = middlewareData.arrow.y;\n                let top = '';\n                let right = '';\n                let bottom = '';\n                let left = '';\n                if (this.arrowPlacement === 'start') {\n                    // Start\n                    const value = typeof arrowX === 'number' ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : '';\n                    top = typeof arrowY === 'number' ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : '';\n                    right = isRtl ? value : '';\n                    left = isRtl ? '' : value;\n                }\n                else if (this.arrowPlacement === 'end') {\n                    // End\n                    const value = typeof arrowX === 'number' ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : '';\n                    right = isRtl ? '' : value;\n                    left = isRtl ? value : '';\n                    bottom = typeof arrowY === 'number' ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : '';\n                }\n                else if (this.arrowPlacement === 'center') {\n                    // Center\n                    left = typeof arrowX === 'number' ? `calc(50% - var(--arrow-size-diagonal))` : '';\n                    top = typeof arrowY === 'number' ? `calc(50% - var(--arrow-size-diagonal))` : '';\n                }\n                else {\n                    // Anchor (default)\n                    left = typeof arrowX === 'number' ? `${arrowX}px` : '';\n                    top = typeof arrowY === 'number' ? `${arrowY}px` : '';\n                }\n                Object.assign(this.arrowEl.style, {\n                    top,\n                    right,\n                    bottom,\n                    left,\n                    [staticSide]: 'calc(var(--arrow-size-diagonal) * -1)'\n                });\n            }\n        });\n        // Wait until the new position is drawn before updating the hover bridge, otherwise it can get out of sync\n        requestAnimationFrame(() => this.updateHoverBridge());\n        this.emit('koerber-reposition');\n    }\n    render() {\n        return html `\n      <slot name=\"anchor\" @slotchange=${this.handleAnchorChange}></slot>\n\n      <span\n        part=\"hover-bridge\"\n        class=${classMap({\n            'popup-hover-bridge': true,\n            'popup-hover-bridge--visible': this.hoverBridge && this.active\n        })}\n      ></span>\n\n      <div\n        part=\"popup\"\n        class=${classMap({\n            popup: true,\n            'popup--active': this.active,\n            'popup--fixed': this.strategy === 'fixed',\n            'popup--has-arrow': this.arrow\n        })}\n      >\n        ${this.colorVariant === 'unstyled'\n            ? html `<slot></slot>`\n            : html `<div\n              class=${classMap({\n                popup__body: true,\n                [`popup__body--${this.colorVariant}`]: true\n            })}\n            >\n              <slot></slot>\n            </div>`}\n        ${this.arrow\n            ? html `<div\n              part=\"arrow\"\n              class=${classMap({\n                popup__arrow: true,\n                [`popup__arrow--${this.colorVariant}`]: true\n            })}\n              role=\"presentation\"\n            ></div>`\n            : ''}\n      </div>\n    `;\n    }\n}\nPopup.styles = [componentStyles, styles];\nexport default Popup;\n__decorate([\n    query('.popup')\n], Popup.prototype, \"popup\", void 0);\n__decorate([\n    query('.popup__arrow')\n], Popup.prototype, \"arrowEl\", void 0);\n__decorate([\n    property()\n], Popup.prototype, \"anchor\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Popup.prototype, \"active\", void 0);\n__decorate([\n    property({ attribute: 'color-variant', reflect: true })\n], Popup.prototype, \"colorVariant\", void 0);\n__decorate([\n    property({ reflect: true })\n], Popup.prototype, \"placement\", void 0);\n__decorate([\n    property({ reflect: true })\n], Popup.prototype, \"strategy\", void 0);\n__decorate([\n    property({ type: Number })\n], Popup.prototype, \"distance\", void 0);\n__decorate([\n    property({ type: Number })\n], Popup.prototype, \"skidding\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Popup.prototype, \"arrow\", void 0);\n__decorate([\n    property({ attribute: 'arrow-placement' })\n], Popup.prototype, \"arrowPlacement\", void 0);\n__decorate([\n    property({ attribute: 'arrow-padding', type: Number })\n], Popup.prototype, \"arrowPadding\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Popup.prototype, \"flip\", void 0);\n__decorate([\n    property({\n        attribute: 'flip-fallback-placements',\n        converter: {\n            fromAttribute: (value) => {\n                return value\n                    .split(' ')\n                    .map(p => p.trim())\n                    .filter(p => p !== '');\n            },\n            toAttribute: (value) => {\n                return value.join(' ');\n            }\n        }\n    })\n], Popup.prototype, \"flipFallbackPlacements\", void 0);\n__decorate([\n    property({ attribute: 'flip-fallback-strategy' })\n], Popup.prototype, \"flipFallbackStrategy\", void 0);\n__decorate([\n    property({ type: Object })\n], Popup.prototype, \"flipBoundary\", void 0);\n__decorate([\n    property({ attribute: 'flip-padding', type: Number })\n], Popup.prototype, \"flipPadding\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Popup.prototype, \"shift\", void 0);\n__decorate([\n    property({ type: Object })\n], Popup.prototype, \"shiftBoundary\", void 0);\n__decorate([\n    property({ attribute: 'shift-padding', type: Number })\n], Popup.prototype, \"shiftPadding\", void 0);\n__decorate([\n    property({ attribute: 'auto-size' })\n], Popup.prototype, \"autoSize\", void 0);\n__decorate([\n    property()\n], Popup.prototype, \"sync\", void 0);\n__decorate([\n    property({ type: Object })\n], Popup.prototype, \"autoSizeBoundary\", void 0);\n__decorate([\n    property({ attribute: 'auto-size-padding', type: Number })\n], Popup.prototype, \"autoSizePadding\", void 0);\n__decorate([\n    property({ attribute: 'hover-bridge', type: Boolean })\n], Popup.prototype, \"hoverBridge\", void 0);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/** Exception due eslint doesn't support WAI-ARIA 1.3 that supports aria-description attr */\n/* eslint-disable lit-a11y/aria-attrs */\nimport Icon from '../icon/icon.component';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { defaultValue } from '../../internal/default-value';\nimport { html } from 'lit';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { live } from 'lit/directives/live.js';\nimport { property, query, state } from 'lit/decorators.js';\nimport { watch } from '../../internal/watch';\nimport componentStyles from '../../styles/component.styles';\nimport formControlStyles from '../../styles/form-control.styles';\nimport styles from './textarea.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Textareas collect data from the user and allow multiple lines of text.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-textarea--docs\n * @status stable\n * @since 2.0\n *\n * @event koerber-blur - Emitted when the control loses focus.\n * @event koerber-change - Emitted when an alteration to the control's value is committed by the user.\n * @event koerber-focus - Emitted when the control gains focus.\n * @event koerber-input - Emitted when the control receives input.\n *\n * @csspart base - The component's base wrapper.\n * @csspart textarea - The internal `<textarea>` control.\n */\nclass Textarea extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.hasFocus = false;\n        this.title = ''; // make reactive to pass through\n        /** The name of the textarea, submitted as a name/value pair with form data. */\n        this.name = '';\n        /** The current value of the textarea, submitted as a name/value pair with form data. */\n        this.value = '';\n        /** The textarea's size. */\n        this.size = 'medium';\n        /** Placeholder text to show as a hint when the input is empty. */\n        this.placeholder = '';\n        /** The number of rows to display by default. */\n        this.rows = 4;\n        /** Controls how the textarea can be resized. */\n        this.resize = 'none';\n        /** Disables the textarea. */\n        this.disabled = false;\n        /** Makes the textarea readonly. */\n        this.readonly = false;\n        /** Makes the textarea a required field. */\n        this.required = false;\n        /** The current character count in the textarea. */\n        this.characterCount = 0;\n        /** Enables spell checking on the textarea. */\n        this.spellcheck = true;\n        /** The default value of the form control. Primarily used for resetting the form control. */\n        this.defaultValue = '';\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.resizeObserver = new ResizeObserver(() => this.setTextareaHeight());\n        this.updateComplete.then(() => {\n            this.setTextareaHeight();\n            this.resizeObserver.observe(this.input);\n        });\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this.resizeObserver.unobserve(this.input);\n    }\n    handleBlur() {\n        this.hasFocus = false;\n        this.emit('koerber-blur');\n    }\n    handleChange() {\n        this.value = this.input.value;\n        this.characterCount = this.value.length;\n        this.setTextareaHeight();\n        this.emit('koerber-change');\n    }\n    handleFocus() {\n        this.hasFocus = true;\n        this.emit('koerber-focus');\n    }\n    handleInput() {\n        this.value = this.input.value;\n        this.characterCount = this.value.length;\n        this.emit('koerber-input');\n    }\n    setTextareaHeight() {\n        if (this.resize === 'auto') {\n            this.input.style.height = 'auto';\n            this.input.style.height = `${this.input.scrollHeight}px`;\n        }\n        else {\n            this.input.style.height = undefined;\n        }\n    }\n    handleRowsChange() {\n        this.setTextareaHeight();\n    }\n    async handleValueChange() {\n        await this.updateComplete;\n        this.setTextareaHeight();\n    }\n    /** Sets focus on the textarea. */\n    focus(options) {\n        this.input.focus(options);\n    }\n    /** Removes focus from the textarea. */\n    blur() {\n        this.input.blur();\n    }\n    /** Selects all the text in the textarea. */\n    select() {\n        this.input.select();\n    }\n    /** Gets or sets the textarea's scroll position. */\n    scrollPosition(position) {\n        if (position) {\n            if (typeof position.top === 'number')\n                this.input.scrollTop = position.top;\n            if (typeof position.left === 'number')\n                this.input.scrollLeft = position.left;\n            return undefined;\n        }\n        return {\n            top: this.input.scrollTop,\n            left: this.input.scrollTop\n        };\n    }\n    /** Sets the start and end positions of the text selection (0-based). */\n    setSelectionRange(selectionStart, selectionEnd, selectionDirection = 'none') {\n        this.input.setSelectionRange(selectionStart, selectionEnd, selectionDirection);\n    }\n    /** Replaces a range of text with a new string. */\n    setRangeText(replacement, start, end, selectMode) {\n        // @ts-expect-error - start, end, and selectMode are optional\n        this.input.setRangeText(replacement, start, end, selectMode);\n        if (this.value !== this.input.value) {\n            this.value = this.input.value;\n        }\n        if (this.value !== this.input.value) {\n            this.value = this.input.value;\n            this.setTextareaHeight();\n        }\n    }\n    render() {\n        return html `\r\n      <div\r\n        part=\"form-control\"\r\n        class=${classMap({\n            'form-control': true,\n            'form-control--small': this.size === 'small',\n            'form-control--medium': this.size === 'medium',\n            'form-control--large': this.size === 'large'\n        })}\r\n      >\r\n        <div part=\"form-control-input\" class=\"form-control-input\">\r\n          <div\r\n            part=\"base\"\r\n            class=${classMap({\n            textarea: true,\n            'textarea--small': this.size === 'small',\n            'textarea--medium': this.size === 'medium',\n            'textarea--large': this.size === 'large',\n            'textarea--standard': true,\n            'textarea--disabled': this.disabled,\n            'textarea--focused': this.hasFocus,\n            'textarea--empty': !this.value,\n            'textarea--resize-none': this.resize === 'none',\n            'textarea--resize-vertical': this.resize === 'vertical',\n            'textarea--resize-auto': this.resize === 'auto',\n            'textarea--error': this.error\n        })}\r\n          >\r\n            <textarea\r\n              part=\"textarea\"\r\n              id=\"input\"\r\n              class=\"textarea__control\"\r\n              title=${this.title /* An empty title prevents browser validation tooltips from appearing on hover */}\r\n              name=${ifDefined(this.name)}\r\n              aria-label=${ifDefined(this.accessibleName)}\r\n              aria-description=${ifDefined(this.accessibleDescription)}\r\n              .value=${live(this.value)}\r\n              ?disabled=${this.disabled}\r\n              ?readonly=${this.readonly}\r\n              ?required=${this.required}\r\n              placeholder=${ifDefined(this.placeholder)}\r\n              rows=${ifDefined(this.rows)}\r\n              autocapitalize=${ifDefined(this.autocapitalize)}\r\n              autocorrect=${ifDefined(this.autocorrect)}\r\n              ?autofocus=${this.autofocus}\r\n              spellcheck=${ifDefined(this.spellcheck)}\r\n              enterkeyhint=${ifDefined(this.enterkeyhint)}\r\n              inputmode=${ifDefined(this.inputmode)}\r\n              @change=${this.handleChange}\r\n              @input=${this.handleInput}\r\n              @focus=${this.handleFocus}\r\n              @blur=${this.handleBlur}\r\n            ></textarea>\r\n\r\n            ${this.error\n            ? html `\r\n                  <div class=\"textarea-error-icon-container\">\r\n                    <koerber-icon class=\"textarea-error-icon\" name=\"alert\"></koerber-icon>\r\n                  </div>\r\n                `\n            : ''}\r\n          </div>\r\n        </div>\r\n      </div>\r\n    `;\n    }\n}\nTextarea.styles = [componentStyles, formControlStyles, styles];\nTextarea.dependencies = { 'koerber-icon': Icon };\nexport default Textarea;\n__decorate([\n    query('.textarea__control')\n], Textarea.prototype, \"input\", void 0);\n__decorate([\n    state()\n], Textarea.prototype, \"hasFocus\", void 0);\n__decorate([\n    property()\n], Textarea.prototype, \"title\", void 0);\n__decorate([\n    property()\n], Textarea.prototype, \"name\", void 0);\n__decorate([\n    property()\n], Textarea.prototype, \"value\", void 0);\n__decorate([\n    property({ reflect: true })\n], Textarea.prototype, \"size\", void 0);\n__decorate([\n    property()\n], Textarea.prototype, \"placeholder\", void 0);\n__decorate([\n    property({ type: Number })\n], Textarea.prototype, \"rows\", void 0);\n__decorate([\n    property()\n], Textarea.prototype, \"resize\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Textarea.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Textarea.prototype, \"readonly\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Textarea.prototype, \"required\", void 0);\n__decorate([\n    state()\n], Textarea.prototype, \"characterCount\", void 0);\n__decorate([\n    property()\n], Textarea.prototype, \"autocapitalize\", void 0);\n__decorate([\n    property()\n], Textarea.prototype, \"autocorrect\", void 0);\n__decorate([\n    property()\n], Textarea.prototype, \"autocomplete\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Textarea.prototype, \"autofocus\", void 0);\n__decorate([\n    property()\n], Textarea.prototype, \"enterkeyhint\", void 0);\n__decorate([\n    property({\n        type: Boolean,\n        converter: {\n            // Allow \"true|false\" attribute values but keep the property boolean\n            fromAttribute: value => (!value || value === 'false' ? false : true),\n            toAttribute: value => (value ? 'true' : 'false')\n        }\n    })\n], Textarea.prototype, \"spellcheck\", void 0);\n__decorate([\n    property()\n], Textarea.prototype, \"inputmode\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Textarea.prototype, \"error\", void 0);\n__decorate([\n    defaultValue()\n], Textarea.prototype, \"defaultValue\", void 0);\n__decorate([\n    property({ attribute: 'accessible-name', reflect: true })\n], Textarea.prototype, \"accessibleName\", void 0);\n__decorate([\n    property({ attribute: 'accessible-description', reflect: true })\n], Textarea.prototype, \"accessibleDescription\", void 0);\n__decorate([\n    watch('rows', { waitUntilFirstUpdate: true })\n], Textarea.prototype, \"handleRowsChange\", null);\n__decorate([\n    watch('value', { waitUntilFirstUpdate: true })\n], Textarea.prototype, \"handleValueChange\", null);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport Popup from '../popup/popup.component';\nimport { animateTo, parseDuration, stopAnimations } from '../../internal/animate';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { getAnimation, setDefaultAnimation } from '../../utilities/animation-registry';\nimport { html } from 'lit';\nimport { LocalizeController } from '../../utilities/localize';\nimport { property, query } from 'lit/decorators.js';\nimport { waitForEvent } from '../../internal/event';\nimport { watch } from '../../internal/watch';\nimport componentStyles from '../../styles/component.styles';\nimport styles from './tooltip.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Tooltips display additional information based on a specific action.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-tooltip--docs\n * @status stable\n * @since 2.0\n *\n * @dependency koerber-popup\n *\n * @slot - The tooltip's target element. Avoid slotting in more than one element, as subsequent ones will be ignored.\n * @slot content - The content to render in the tooltip. Alternatively, you can use the `content` attribute.\n *\n * @event koerber-show - Emitted when the tooltip begins to show.\n * @event koerber-after-show - Emitted after the tooltip has shown and all animations are complete.\n * @event koerber-hide - Emitted when the tooltip begins to hide.\n * @event koerber-after-hide - Emitted after the tooltip has hidden and all animations are complete.\n *\n * @csspart base - The component's base wrapper, an `<koerber-popup>` element.\n * @csspart base__popup - The popup's exported `popup` part. Use this to target the tooltip's popup container.\n * @csspart base__arrow - The popup's exported `arrow` part. Use this to target the tooltip's arrow.\n * @csspart body - The tooltip's body where its content is rendered.\n *\n * @cssproperty --max-width - The maximum width of the tooltip before its content will wrap.\n * @cssproperty --hide-delay - The amount of time to wait before hiding the tooltip when hovering.\n * @cssproperty --show-delay - The amount of time to wait before showing the tooltip when hovering.\n *\n * @animation tooltip.show - The animation to use when showing the tooltip.\n * @animation tooltip.hide - The animation to use when hiding the tooltip.\n */\nclass Tooltip extends UIKitElement {\n    constructor() {\n        super();\n        this.localize = new LocalizeController(this);\n        /** The distance in pixels from which to offset the tooltip away from its target. */\n        this.distance = 8;\n        /** The distance in pixels from which to offset the tooltip along its target. */\n        this.skidding = 0;\n        /**\n         * Controls how the tooltip is activated. Possible options include `click`, `hover`, `focus`, and `manual`. Multiple\n         * options can be passed by separating them with a space. When manual is used, the tooltip must be activated\n         * programmatically.\n         */\n        this.trigger = 'hover focus';\n        /** The tooltip's content. If you need to display HTML, use the `content` slot instead. */\n        this.content = '';\n        /**\n         * The preferred placement of the tooltip. Note that the actual placement may vary as needed to keep the tooltip\n         * inside of the viewport.\n         */\n        this.placement = 'top';\n        /** Indicates whether or not the tooltip is open. You can use this in lieu of the show/hide methods. */\n        this.open = false;\n        /**\n         * Enable this option to prevent the tooltip from being clipped when the component is placed inside a container with\n         * `overflow: auto|hidden|scroll`. Hoisting uses a fixed positioning strategy that works in many, but not all,\n         * scenarios.\n         */\n        this.hoist = false;\n        this.handleBlur = () => {\n            if (this.hasTrigger('focus')) {\n                this.hide();\n            }\n        };\n        this.handleFocus = () => {\n            if (this.hasTrigger('focus')) {\n                this.show();\n            }\n        };\n        this.handleDocumentKeyDown = (event) => {\n            // Pressing escape when a tooltip is open should dismiss it\n            if (event.key === 'Escape') {\n                event.stopPropagation();\n                this.hide();\n            }\n        };\n        this.handleMouseOver = () => {\n            if (this.hasTrigger('hover')) {\n                const delay = parseDuration(getComputedStyle(this).getPropertyValue('--show-delay'));\n                clearTimeout(this.hoverTimeout);\n                this.hoverTimeout = window.setTimeout(() => this.show(), delay);\n            }\n        };\n        this.handleMouseOut = () => {\n            if (this.hasTrigger('hover')) {\n                const delay = parseDuration(getComputedStyle(this).getPropertyValue('--hide-delay'));\n                clearTimeout(this.hoverTimeout);\n                this.hoverTimeout = window.setTimeout(() => this.hide(), delay);\n            }\n        };\n        this.addEventListener('blur', this.handleBlur, true);\n        this.addEventListener('focus', this.handleFocus, true);\n        this.addEventListener('mouseover', this.handleMouseOver);\n        this.addEventListener('mouseout', this.handleMouseOut);\n    }\n    disconnectedCallback() {\n        // Cleanup this event in case the tooltip is removed while open\n        document.removeEventListener('keydown', this.handleDocumentKeyDown);\n    }\n    firstUpdated() {\n        this.body.hidden = !this.open;\n        // If the tooltip is visible on init, update its position\n        if (this.open) {\n            this.popup.active = true;\n            this.popup.reposition();\n        }\n    }\n    hasTrigger(triggerType) {\n        const triggers = this.trigger.split(' ');\n        return triggers.includes(triggerType);\n    }\n    async handleOpenChange() {\n        if (this.open) {\n            // Show\n            this.emit('koerber-show');\n            document.addEventListener('keydown', this.handleDocumentKeyDown);\n            await stopAnimations(this.body);\n            this.body.hidden = false;\n            this.popup.active = true;\n            const { keyframes, options } = getAnimation(this, 'tooltip.show', { dir: this.localize.dir() });\n            await animateTo(this.popup.popup, keyframes, options);\n            this.popup.reposition();\n            this.emit('koerber-after-show');\n        }\n        else {\n            // Hide\n            this.emit('koerber-hide');\n            document.removeEventListener('keydown', this.handleDocumentKeyDown);\n            await stopAnimations(this.body);\n            const { keyframes, options } = getAnimation(this, 'tooltip.hide', { dir: this.localize.dir() });\n            await animateTo(this.popup.popup, keyframes, options);\n            this.popup.active = false;\n            this.body.hidden = true;\n            this.emit('koerber-after-hide');\n        }\n    }\n    async handleOptionsChange() {\n        if (this.hasUpdated) {\n            await this.updateComplete;\n            this.popup.reposition();\n        }\n    }\n    /** Shows the tooltip. */\n    async show() {\n        if (this.open) {\n            return undefined;\n        }\n        this.open = true;\n        return waitForEvent(this, 'koerber-after-show');\n    }\n    /** Hides the tooltip */\n    async hide() {\n        if (!this.open) {\n            return undefined;\n        }\n        this.open = false;\n        return waitForEvent(this, 'koerber-after-hide');\n    }\n    //\n    // NOTE: Tooltip is a bit unique in that we're using aria-live instead of aria-labelledby to trick screen readers into\n    // announcing the content. It works really well, but it violates an accessibility rule. We're also adding the\n    // aria-describedby attribute to a slot, which is required by <koerber-popup> to correctly locate the first assigned\n    // element, otherwise positioning is incorrect.\n    //\n    render() {\n        return html `\n      <koerber-popup\n        part=\"base\"\n        exportparts=\"\n          popup:base__popup,\n          arrow:base__arrow\n        \"\n        class=${classMap({\n            tooltip: true,\n            'tooltip--open': this.open\n        })}\n        placement=${this.placement}\n        distance=${this.distance}\n        skidding=${this.skidding}\n        strategy=${this.hoist ? 'fixed' : 'absolute'}\n        flip\n        shift\n        arrow\n        hover-bridge\n      >\n        <slot slot=\"anchor\" aria-describedby=\"tooltip\"></slot>\n\n        <slot\n          name=\"content\"\n          part=\"body\"\n          id=\"tooltip\"\n          class=\"tooltip__body\"\n          role=\"tooltip\"\n          aria-live=${this.open ? 'polite' : 'off'}\n        >\n          ${this.content}\n        </slot>\n      </koerber-popup>\n    `;\n    }\n}\nTooltip.styles = [componentStyles, styles];\nTooltip.dependencies = { 'koerber-popup': Popup };\nexport default Tooltip;\n__decorate([\n    query('slot:not([name])')\n], Tooltip.prototype, \"defaultSlot\", void 0);\n__decorate([\n    query('.tooltip__body')\n], Tooltip.prototype, \"body\", void 0);\n__decorate([\n    query('koerber-popup')\n], Tooltip.prototype, \"popup\", void 0);\n__decorate([\n    property({ type: String, attribute: 'content' })\n], Tooltip.prototype, \"content\", void 0);\n__decorate([\n    property()\n], Tooltip.prototype, \"placement\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Tooltip.prototype, \"open\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Tooltip.prototype, \"hoist\", void 0);\n__decorate([\n    watch('open', { waitUntilFirstUpdate: true })\n], Tooltip.prototype, \"handleOpenChange\", null);\n__decorate([\n    watch(['content', 'distance', 'hoist', 'placement', 'skidding'])\n], Tooltip.prototype, \"handleOptionsChange\", null);\nsetDefaultAnimation('tooltip.show', {\n    keyframes: [\n        { opacity: 0, scale: 0.8 },\n        { opacity: 1, scale: 1 }\n    ],\n    options: { duration: 150, easing: 'ease' }\n});\nsetDefaultAnimation('tooltip.hide', {\n    keyframes: [\n        { opacity: 1, scale: 1 },\n        { opacity: 0, scale: 0.8 }\n    ],\n    options: { duration: 150, easing: 'ease' }\n});\n"],"names":[],"sourceRoot":""}