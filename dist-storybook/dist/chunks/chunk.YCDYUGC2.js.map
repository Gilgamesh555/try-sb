{
  "version": 3,
  "sources": ["../../src/internal/uikit-element.ts"],
  "sourcesContent": ["import { LitElement } from 'lit';\r\nimport { property } from 'lit/decorators.js';\r\n\r\n// Match event type name strings that are registered on GlobalEventHandlersEventMap...\r\ntype EventTypeRequiresDetail<T> = T extends keyof GlobalEventHandlersEventMap\r\n  ? // ...where the event detail is an object...\r\n    GlobalEventHandlersEventMap[T] extends CustomEvent<Record<PropertyKey, unknown>>\r\n    ? // ...that is non-empty...\r\n      GlobalEventHandlersEventMap[T] extends CustomEvent<Record<PropertyKey, never>>\r\n      ? never\r\n      : // ...and has at least one non-optional property\r\n        Partial<GlobalEventHandlersEventMap[T]['detail']> extends GlobalEventHandlersEventMap[T]['detail']\r\n        ? never\r\n        : T\r\n    : never\r\n  : never;\r\n\r\n// The inverse of the above (match any type that doesn't match EventTypeRequiresDetail)\r\ntype EventTypeDoesNotRequireDetail<T> = T extends keyof GlobalEventHandlersEventMap\r\n  ? GlobalEventHandlersEventMap[T] extends CustomEvent<Record<PropertyKey, unknown>>\r\n    ? GlobalEventHandlersEventMap[T] extends CustomEvent<Record<PropertyKey, never>>\r\n      ? T\r\n      : Partial<GlobalEventHandlersEventMap[T]['detail']> extends GlobalEventHandlersEventMap[T]['detail']\r\n        ? T\r\n        : never\r\n    : T\r\n  : T;\r\n\r\n// `keyof EventTypesWithRequiredDetail` lists all registered event types that require detail\r\ntype EventTypesWithRequiredDetail = {\r\n  [EventType in keyof GlobalEventHandlersEventMap as EventTypeRequiresDetail<EventType>]: true;\r\n};\r\n\r\n// `keyof EventTypesWithoutRequiredDetail` lists all registered event types that do NOT require detail\r\ntype EventTypesWithoutRequiredDetail = {\r\n  [EventType in keyof GlobalEventHandlersEventMap as EventTypeDoesNotRequireDetail<EventType>]: true;\r\n};\r\n\r\n// Helper to make a specific property of an object non-optional\r\ntype WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };\r\n\r\n// Given an event name string, get a valid type for the options to initialize the event that is more restrictive than\r\n// just CustomEventInit when appropriate (validate the type of the event detail, and require it to be provided if the\r\n// event requires it)\r\ntype SlEventInit<T> = T extends keyof GlobalEventHandlersEventMap\r\n  ? GlobalEventHandlersEventMap[T] extends CustomEvent<Record<PropertyKey, unknown>>\r\n    ? GlobalEventHandlersEventMap[T] extends CustomEvent<Record<PropertyKey, never>>\r\n      ? CustomEventInit<GlobalEventHandlersEventMap[T]['detail']>\r\n      : Partial<GlobalEventHandlersEventMap[T]['detail']> extends GlobalEventHandlersEventMap[T]['detail']\r\n        ? CustomEventInit<GlobalEventHandlersEventMap[T]['detail']>\r\n        : WithRequired<CustomEventInit<GlobalEventHandlersEventMap[T]['detail']>, 'detail'>\r\n    : CustomEventInit\r\n  : CustomEventInit;\r\n\r\n// Given an event name string, get the type of the event\r\ntype GetCustomEventType<T> = T extends keyof GlobalEventHandlersEventMap\r\n  ? GlobalEventHandlersEventMap[T] extends CustomEvent<unknown>\r\n    ? GlobalEventHandlersEventMap[T]\r\n    : CustomEvent<unknown>\r\n  : CustomEvent<unknown>;\r\n\r\n// `keyof ValidEventTypeMap` is equivalent to `keyof GlobalEventHandlersEventMap` but gives a nicer error message\r\ntype ValidEventTypeMap = EventTypesWithRequiredDetail | EventTypesWithoutRequiredDetail;\r\n\r\nexport default class UIKitElement extends LitElement {\r\n  // Make localization attributes reactive\r\n  @property() dir: string;\r\n  @property() lang: string;\r\n\r\n  /** Emits a custom event with more convenient defaults. */\r\n  emit<T extends string & keyof EventTypesWithoutRequiredDetail>(\r\n    name: EventTypeDoesNotRequireDetail<T>,\r\n    options?: SlEventInit<T> | undefined\r\n  ): GetCustomEventType<T>;\r\n  emit<T extends string & keyof EventTypesWithRequiredDetail>(\r\n    name: EventTypeRequiresDetail<T>,\r\n    options: SlEventInit<T>\r\n  ): GetCustomEventType<T>;\r\n  emit<T extends string & keyof ValidEventTypeMap>(\r\n    name: T,\r\n    options?: SlEventInit<T> | undefined\r\n  ): GetCustomEventType<T> {\r\n    const event = new CustomEvent(name, {\r\n      bubbles: true,\r\n      cancelable: false,\r\n      composed: true,\r\n      detail: {},\r\n      ...options\r\n    });\r\n\r\n    this.dispatchEvent(event);\r\n\r\n    return event as GetCustomEventType<T>;\r\n  }\r\n\r\n  /* eslint-disable */\r\n  // @ts-expect-error This is auto-injected at build time.\r\n  static version = \"3.0.0-prealpha.0\";\r\n  /* eslint-enable */\r\n\r\n  static define(name: string, elementConstructor = this, options: ElementDefinitionOptions = {}) {\r\n    const currentlyRegisteredConstructor = customElements.get(name) as CustomElementConstructor | typeof UIKitElement;\r\n\r\n    if (!currentlyRegisteredConstructor) {\r\n      customElements.define(name, class extends elementConstructor {} as unknown as CustomElementConstructor, options);\r\n      return;\r\n    }\r\n\r\n    let newVersion = ' (unknown version)';\r\n    let existingVersion = newVersion;\r\n\r\n    if ('version' in elementConstructor && elementConstructor.version) {\r\n      newVersion = ' v' + elementConstructor.version;\r\n    }\r\n\r\n    if ('version' in currentlyRegisteredConstructor && currentlyRegisteredConstructor.version) {\r\n      existingVersion = ' v' + currentlyRegisteredConstructor.version;\r\n    }\r\n\r\n    // Need to make sure we're not working with null or empty strings before doing version comparisons.\r\n    if (newVersion && existingVersion && newVersion === existingVersion) {\r\n      // If versions match, we don't need to warn anyone. Carry on.\r\n      return;\r\n    }\r\n\r\n    console.warn(\r\n      `Attempted to register <${name}>${newVersion}, but <${name}>${existingVersion} has already been registered.`\r\n    );\r\n  }\r\n\r\n  static dependencies: Record<string, typeof UIKitElement> = {};\r\n\r\n  constructor() {\r\n    super();\r\n    Object.entries((this.constructor as typeof UIKitElement).dependencies).forEach(([name, component]) => {\r\n      (this.constructor as typeof UIKitElement).define(name, component);\r\n    });\r\n  }\r\n}\r\n\r\nexport interface UIKitFormControl extends UIKitElement {\r\n  // Form attributes\r\n  name: string;\r\n  value: unknown;\r\n  disabled?: boolean;\r\n  defaultValue?: unknown;\r\n  defaultChecked?: boolean;\r\n\r\n  // Accessibility attributes\r\n  accessibleName?: string;\r\n  accessibleDescription?: string;\r\n\r\n  // Constraint validation attributes\r\n  step?: number | 'any';\r\n  required?: boolean;\r\n}\r\n"],
  "mappings": ";;;;;;AAAA,SAAS,kBAAkB;AAC3B,SAAS,gBAAgB;AA+DzB,IAAqB,eAArB,cAA0C,WAAW;AAAA,EAcnD,KACE,MACA,SACuB;AACvB,UAAM,QAAQ,IAAI,YAAY,MAAM;AAAA,MAClC,SAAS;AAAA,MACT,YAAY;AAAA,MACZ,UAAU;AAAA,MACV,QAAQ,CAAC;AAAA,OACN,QACJ;AAED,SAAK,cAAc,KAAK;AAExB,WAAO;AAAA,EACT;AAAA;AAAA,EAOA,OAAO,OAAO,MAAc,qBAAqB,MAAM,UAAoC,CAAC,GAAG;AAC7F,UAAM,iCAAiC,eAAe,IAAI,IAAI;AAE9D,QAAI,CAAC,gCAAgC;AACnC,qBAAe,OAAO,MAAM,cAAc,mBAAmB;AAAA,MAAC,GAA0C,OAAO;AAC/G;AAAA,IACF;AAEA,QAAI,aAAa;AACjB,QAAI,kBAAkB;AAEtB,QAAI,aAAa,sBAAsB,mBAAmB,SAAS;AACjE,mBAAa,OAAO,mBAAmB;AAAA,IACzC;AAEA,QAAI,aAAa,kCAAkC,+BAA+B,SAAS;AACzF,wBAAkB,OAAO,+BAA+B;AAAA,IAC1D;AAGA,QAAI,cAAc,mBAAmB,eAAe,iBAAiB;AAEnE;AAAA,IACF;AAEA,YAAQ;AAAA,MACN,0BAA0B,IAAI,IAAI,UAAU,UAAU,IAAI,IAAI,eAAe;AAAA,IAC/E;AAAA,EACF;AAAA,EAIA,cAAc;AACZ,UAAM;AACN,WAAO,QAAS,KAAK,YAAoC,YAAY,EAAE,QAAQ,CAAC,CAAC,MAAM,SAAS,MAAM;AACpG,MAAC,KAAK,YAAoC,OAAO,MAAM,SAAS;AAAA,IAClE,CAAC;AAAA,EACH;AACF;AAAA;AAAA;AA1EqB,aAiCZ,UAAU;AAjCE,aAkEZ,eAAoD,CAAC;AAhEhD;AAAA,EAAX,SAAS;AAAA,GAFS,aAEP;AACA;AAAA,EAAX,SAAS;AAAA,GAHS,aAGP;",
  "names": []
}
