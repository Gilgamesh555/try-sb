{
  "version": 3,
  "sources": ["../../src/internal/tabbable.ts"],
  "sourcesContent": ["/** Determines if the specified element is tabbable using heuristics inspired by https://github.com/focus-trap/tabbable */\nfunction isTabbable(el: HTMLElement) {\n  const tag = el.tagName.toLowerCase();\n\n  // Elements with a -1 tab index are not tabbable\n  if (el.getAttribute('tabindex') === '-1') {\n    return false;\n  }\n\n  // Elements with a disabled attribute are not tabbable\n  if (el.hasAttribute('disabled')) {\n    return false;\n  }\n\n  // Elements with aria-disabled are not tabbable\n  if (el.hasAttribute('aria-disabled') && el.getAttribute('aria-disabled') !== 'false') {\n    return false;\n  }\n\n  // Radios without a checked attribute are not tabbable\n  if (tag === 'input' && el.getAttribute('type') === 'radio' && !el.hasAttribute('checked')) {\n    return false;\n  }\n\n  // Elements that are hidden have no offsetParent and are not tabbable\n  if (el.offsetParent === null) {\n    return false;\n  }\n\n  // Elements without visibility are not tabbable\n  if (window.getComputedStyle(el).visibility === 'hidden') {\n    return false;\n  }\n\n  // Audio and video elements with the controls attribute are tabbable\n  if ((tag === 'audio' || tag === 'video') && el.hasAttribute('controls')) {\n    return true;\n  }\n\n  // Elements with a tabindex other than -1 are tabbable\n  if (el.hasAttribute('tabindex')) {\n    return true;\n  }\n\n  // Elements with a contenteditable attribute are tabbable\n  if (el.hasAttribute('contenteditable') && el.getAttribute('contenteditable') !== 'false') {\n    return true;\n  }\n\n  // At this point, the following elements are considered tabbable\n  return ['button', 'input', 'select', 'textarea', 'a', 'audio', 'video', 'summary'].includes(tag);\n}\n\n/**\n * Returns the first and last bounding elements that are tabbable. This is more performant than checking every single\n * element because it short-circuits after finding the first and last ones.\n */\nexport function getTabbableBoundary(root: HTMLElement | ShadowRoot) {\n  const allElements: HTMLElement[] = [];\n\n  function walk(el: HTMLElement | ShadowRoot) {\n    if (el instanceof HTMLElement) {\n      allElements.push(el);\n\n      if (el.shadowRoot !== null && el.shadowRoot.mode === 'open') {\n        walk(el.shadowRoot);\n      }\n    }\n\n    [...el.children].forEach((e: HTMLElement) => walk(e));\n  }\n\n  // Collect all elements including the root\n  walk(root);\n\n  // Find the first and last tabbable elements\n  const start = allElements.find(el => isTabbable(el)) ?? null;\n  const end = allElements.reverse().find(el => isTabbable(el)) ?? null;\n\n  return { start, end };\n}\n"],
  "mappings": ";AACA,SAAS,WAAW,IAAiB;AACnC,QAAM,MAAM,GAAG,QAAQ,YAAY;AAGnC,MAAI,GAAG,aAAa,UAAU,MAAM,MAAM;AACxC,WAAO;AAAA,EACT;AAGA,MAAI,GAAG,aAAa,UAAU,GAAG;AAC/B,WAAO;AAAA,EACT;AAGA,MAAI,GAAG,aAAa,eAAe,KAAK,GAAG,aAAa,eAAe,MAAM,SAAS;AACpF,WAAO;AAAA,EACT;AAGA,MAAI,QAAQ,WAAW,GAAG,aAAa,MAAM,MAAM,WAAW,CAAC,GAAG,aAAa,SAAS,GAAG;AACzF,WAAO;AAAA,EACT;AAGA,MAAI,GAAG,iBAAiB,MAAM;AAC5B,WAAO;AAAA,EACT;AAGA,MAAI,OAAO,iBAAiB,EAAE,EAAE,eAAe,UAAU;AACvD,WAAO;AAAA,EACT;AAGA,OAAK,QAAQ,WAAW,QAAQ,YAAY,GAAG,aAAa,UAAU,GAAG;AACvE,WAAO;AAAA,EACT;AAGA,MAAI,GAAG,aAAa,UAAU,GAAG;AAC/B,WAAO;AAAA,EACT;AAGA,MAAI,GAAG,aAAa,iBAAiB,KAAK,GAAG,aAAa,iBAAiB,MAAM,SAAS;AACxF,WAAO;AAAA,EACT;AAGA,SAAO,CAAC,UAAU,SAAS,UAAU,YAAY,KAAK,SAAS,SAAS,SAAS,EAAE,SAAS,GAAG;AACjG;AAMO,SAAS,oBAAoB,MAAgC;AAzDpE;AA0DE,QAAM,cAA6B,CAAC;AAEpC,WAAS,KAAK,IAA8B;AAC1C,QAAI,cAAc,aAAa;AAC7B,kBAAY,KAAK,EAAE;AAEnB,UAAI,GAAG,eAAe,QAAQ,GAAG,WAAW,SAAS,QAAQ;AAC3D,aAAK,GAAG,UAAU;AAAA,MACpB;AAAA,IACF;AAEA,KAAC,GAAG,GAAG,QAAQ,EAAE,QAAQ,CAAC,MAAmB,KAAK,CAAC,CAAC;AAAA,EACtD;AAGA,OAAK,IAAI;AAGT,QAAM,SAAQ,iBAAY,KAAK,QAAM,WAAW,EAAE,CAAC,MAArC,YAA0C;AACxD,QAAM,OAAM,iBAAY,QAAQ,EAAE,KAAK,QAAM,WAAW,EAAE,CAAC,MAA/C,YAAoD;AAEhE,SAAO,EAAE,OAAO,IAAI;AACtB;",
  "names": []
}
