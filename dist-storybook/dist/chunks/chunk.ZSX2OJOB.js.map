{
  "version": 3,
  "sources": ["../../src/components/include/request.ts"],
  "sourcesContent": ["interface IncludeFile {\n  ok: boolean;\n  status: number;\n  html: string;\n}\n\nconst includeFiles = new Map<string, IncludeFile | Promise<IncludeFile>>();\n\n/** Fetches an include file from a remote source. Caching is enabled so the origin is only pinged once. */\nexport function requestInclude(src: string, mode: 'cors' | 'no-cors' | 'same-origin' = 'cors'): Promise<IncludeFile> {\n  const prev = includeFiles.get(src);\n  if (prev !== undefined) {\n    // Promise.resolve() transparently unboxes prev if it was a promise.\n    return Promise.resolve(prev);\n  }\n  const fileDataPromise = fetch(src, { mode: mode }).then(async response => {\n    const res = {\n      ok: response.ok,\n      status: response.status,\n      html: await response.text()\n    };\n    // Replace the cached promise with its result to avoid having buggy browser Promises retain memory as mentioned in #1284 and #1249\n    includeFiles.set(src, res);\n    return res;\n  });\n  // Cache the promise to only fetch() once per src\n  includeFiles.set(src, fileDataPromise);\n  return fileDataPromise;\n}\n"],
  "mappings": ";AAMA,IAAM,eAAe,oBAAI,IAAgD;AAGlE,SAAS,eAAe,KAAa,OAA2C,QAA8B;AACnH,QAAM,OAAO,aAAa,IAAI,GAAG;AACjC,MAAI,SAAS,QAAW;AAEtB,WAAO,QAAQ,QAAQ,IAAI;AAAA,EAC7B;AACA,QAAM,kBAAkB,MAAM,KAAK,EAAE,KAAW,CAAC,EAAE,KAAK,OAAM,aAAY;AACxE,UAAM,MAAM;AAAA,MACV,IAAI,SAAS;AAAA,MACb,QAAQ,SAAS;AAAA,MACjB,MAAM,MAAM,SAAS,KAAK;AAAA,IAC5B;AAEA,iBAAa,IAAI,KAAK,GAAG;AACzB,WAAO;AAAA,EACT,CAAC;AAED,eAAa,IAAI,KAAK,eAAe;AACrC,SAAO;AACT;",
  "names": []
}
