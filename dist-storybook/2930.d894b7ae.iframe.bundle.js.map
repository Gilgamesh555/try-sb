{"version":3,"file":"2930.d894b7ae.iframe.bundle.js","mappings":";AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC8CA;;;;;;;;;;;;AAiBA;;;;;AAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC4DA;;;AAGA;;;;;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;;AAKA;;;;;;;;AASA;AAEA;;;;;;;;AASA;;;;;AAMA;;;;;AAMA;;AC+BA;AACA;;;;;AAKA;;;;;AAVA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClGA;AAUA;AACA;;AAEA;AAGA;;;;AAKA;;AAEA;AACA;AAEA;AAGA;AAEA;AACA;AAEA;;AAGA;;;;;;;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AAUA;AACA;;AAEA;AAEA;AAMA;AACA;;AAEA;;;;AAKA;AAMA;;;;AAIA;;AAIA;;AAOA;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACgZA;;;;AAUA;AAgBA;AACA;;;;;;;;;;;AAWA;AACA;;;;;;AAMA;;AAQA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;;;AAGA;;;AAGA;AACA;;;AAGA;;AAGA;;;;;;;;;AAWA;;;AAGA;;AAEA;;AAGA;AAGA;AAIA;;AAIA;;;;;AAMA;AACA;AACA;;;AAGA;;;AAGA;AAEA;;;;;AAKA;AAEA;;;;;AAMA;AACA;AACA;;;;;;;AAOA;AAEA;;;;AAKA;;;;;;;;;;AAWA;AACA;;;;AAIA;AACA;;;;;;AAMA;;;;;;AAOA;;AAEA;;AAEA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzsBA;;;;AAaA;;;;;;AAOA;;AAEA;;;AAGA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC6BA;;;;;AAaA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACwFA;AACA;AACA;AACA;;;;;;;AAOA;;;AAMA;;AAEA;;;AAGA;;;;AAIA;;;;;;;;;;;;;;AAcA;AACA;AACA;;;;;;AAMA;;;;AAKA;;;AAGA;;;;;;;AASA;;;AAGA;;AAWA;;;AAGA;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1JA;;;AAGA;;;;;AAWA;;AAKA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;;;AAKA;AACA;;;;;AAKA;;;;AAIA;;;;;;;;AAWA;;;AAKA;;AAGA;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxOA;;;AAqLA;;AAQA;AACA;;;AAGA;;;AAMA;;AAKA;;;AAIA;;AAKA;;;AAIA;;;;;;;;AAYA;;;;;;AASA;;;;;;AASA;;;;;AAMA;AACA;AACA;AACA;;;;;;;AAOA;;AAIA;;;;AC3QA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;;;;AAmGA;;;;;AAOA;AACA;AACA;;;;AAIA;;;;;;;;;AAWA;;;AAGA;;;;;AAKA;;AAMA;;;;AAOA;;;;;;AChJA;AA8EA;AACA;;;;;AAKA;;;;AAKA;;;;;;;;;ACzFA;;;;AAqEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9EA;;;;AA6GA;AAoBA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;AAMA;;;AAGA;AAEA;;;;AAMA;AAGA;;;;;AAMA;;AAEA;AACA;;AAEA;;AAEA;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChLA;;;;AA+TA;AACA;AACA;AACA;;;;;AAKA;AACA;;;;;;;AAUA;AACA;AACA;AACA;;;AAGA;AACA;;;AAIA;;;;ACtVA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AA4FA;AAGA;;;;AAIA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5HA;AAwFA;AAGA;AACA;AAIA;;;AAGA;;AAEA;AACA;AAaA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/HA;;AA4MA;AACA;AACA;;;AAIA;;;AAGA;;;;;AAWA;;AAKA;;AAGA;;AAEA;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChPA;;;AAkHA;;AAUA;AACA;;;;AAKA;;;;AAOA;;;;AAKA;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClJA;;;AA+FA;AAQA;AACA;;;;AAIA;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACkXA;;AAGA;;;AAGA;;;;AAUA;AAeA;AACA;;;;;;;;;;;AAWA;AACA;;;;;;AAMA;;AAOA;AACA;AACA;;;;AAIA;AACA;;AAEA;;;AAGA;;;AAGA;AACA;AACA;AACA;;;;AAIA;;;;;AAMA;AACA;AACA;AACA;;;;;AAKA;;;;;;;AAQA;;;;AAIA;AACA;;AAEA;;AAEA;;;;;;;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;ACvPA;AACA;AACA;;AAEA;;;;AAKA","sources":["webpack://@koerber/uikit/./src/components/card/card.styles.ts","webpack://@koerber/uikit/./src/components/card/card.component.ts","webpack://@koerber/uikit/./src/components/checkbox/checkbox.component.ts","webpack://@koerber/uikit/./src/components/menu-item/submenu-controller.ts","webpack://@koerber/uikit/./src/components/menu-item/menu-item.component.ts","webpack://@koerber/uikit/./src/components/menu/menu.component.ts","webpack://@koerber/uikit/./src/components/select-option/select-option.component.ts","webpack://@koerber/uikit/./src/components/select/select.component.ts","webpack://@koerber/uikit/./src/components/tag/tag.component.ts","webpack://@koerber/uikit/./src/components/toggle/toggle.component.ts","webpack://@koerber/uikit/./src/components/tree-item/tree-item.component.ts","webpack://@koerber/uikit/./src/components/accordion/accordion.component.ts","webpack://@koerber/uikit/./src/components/alert/alert.component.ts","webpack://@koerber/uikit/./src/components/animation/animation.component.ts","webpack://@koerber/uikit/./src/components/breadcrumb-item/breadcrumb-item.component.ts","webpack://@koerber/uikit/./src/components/breadcrumb/breadcrumb.component.ts","webpack://@koerber/uikit/./src/components/button-group/button-group.component.ts","webpack://@koerber/uikit/./src/components/chip/chip.component.ts","webpack://@koerber/uikit/./src/components/dropdown/dropdown.component.ts","webpack://@koerber/uikit/./src/components/include/include.js","webpack://@koerber/uikit/./src/components/link/link.component.ts","webpack://@koerber/uikit/./src/components/radio-button/radio-button.component.ts","webpack://@koerber/uikit/./src/components/radio-group/radio-group.component.ts","webpack://@koerber/uikit/./src/components/radio/radio.component.ts","webpack://@koerber/uikit/./src/components/search-option/search-option.component.ts","webpack://@koerber/uikit/./src/components/search/search.component.ts","webpack://@koerber/uikit/./src/components/tree/tree.component.ts"],"sourcesContent":["import { css } from 'lit';\nimport componentStyles from '../../styles/component.styles';\nexport default css `\r\n  ${componentStyles}\r\n\r\n  :host {\r\n    --border-color: var(--koerber-color-border-secondary);\r\n    --border-radius: var(--koerber-border-radius-medium);\r\n    --border-width: var(--koerber-border-width-s);\r\n    --padding: var(--koerber-spacing-s);\r\n\r\n    display: inline-block;\r\n  }\r\n\r\n  .card {\r\n    display: flex;\r\n    flex-direction: column;\r\n    background-color: var(--koerber-color-bg-surface);\r\n    border: solid var(--border-width) var(--border-color);\r\n    border-radius: var(--border-radius);\r\n  }\r\n\r\n  .card__image {\r\n    display: flex;\r\n    border-top-left-radius: var(--border-radius);\r\n    border-top-right-radius: var(--border-radius);\r\n    margin: calc(-1 * var(--border-width));\r\n    overflow: hidden;\r\n  }\r\n\r\n  .card__image::slotted(img) {\r\n    display: block;\r\n    width: 100%;\r\n  }\r\n\r\n  .card:not(.card--has-image) .card__image {\r\n    display: none;\r\n  }\r\n\r\n  .card-content {\r\n    padding: var(--padding);\r\n  }\r\n\r\n  .card__header {\r\n    display: block;\r\n  }\r\n\r\n  .card:not(.card--has-header) .card__header {\r\n    display: none;\r\n  }\r\n\r\n  .card:not(.card--has-image) .card__header {\r\n    border-top-left-radius: var(--border-radius);\r\n    border-top-right-radius: var(--border-radius);\r\n  }\r\n\r\n  .card__body {\r\n    display: block;\r\n  }\r\n\r\n  .card__body--has-margin-bottom {\r\n    margin-bottom: var(--koerber-spacing-m);\r\n  }\r\n\r\n  .card__body--has-margin-top {\r\n    margin-top: var(--koerber-spacing-m);\r\n  }\r\n\r\n  ::slotted([slot='footer']) {\r\n    display: flex;\r\n    flex-direction: row;\r\n    gap: var(--koerber-spacing-xs);\r\n    flex: 1;\r\n    justify-content: flex-end;\r\n  }\r\n\r\n  .card:not(.card--has-footer) .card__footer {\r\n    display: none;\r\n  }\r\n`;\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { classMap } from 'lit/directives/class-map.js';\nimport { HasSlotController } from '../../internal/slot';\nimport { html } from 'lit';\nimport { query } from 'lit/decorators.js';\nimport styles from './card.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Cards can be used to group related subjects in a container.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-card--docs\n * @status stable\n * @since 2.0\n *\n * @slot - The card's main content.\n * @slot header - An optional header for the card.\n * @slot footer - An optional footer for the card.\n * @slot image - An optional image to render at the start of the card.\n *\n * @csspart base - The component's base wrapper.\n * @csspart image - The container that wraps the card's image.\n * @csspart header - The container that wraps the card's header.\n * @csspart body - The container that wraps the card's main content.\n * @csspart footer - The container that wraps the card's footer.\n *\n * @cssproperty --border-color - The card's border color, including borders that occur inside the card.\n * @cssproperty --border-radius - The border radius for the card's edges.\n * @cssproperty --border-width - The width of the card's borders.\n * @cssproperty --padding - The padding to use for the card's sections.\n */\nclass Card extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.hasSlotController = new HasSlotController(this, 'footer', 'header', 'image');\n    }\n    render() {\n        var _a;\n        const defaultSlotAssignedNodes = (_a = this.defaultSlot) === null || _a === void 0 ? void 0 : _a.assignedNodes({ flatten: true });\n        const defaultSlotHasContent = defaultSlotAssignedNodes === null || defaultSlotAssignedNodes === void 0 ? void 0 : defaultSlotAssignedNodes.some(node => {\n            var _a;\n            return (node.nodeType === Node.ELEMENT_NODE || (node.nodeType === Node.TEXT_NODE && ((_a = node === null || node === void 0 ? void 0 : node.textContent) === null || _a === void 0 ? void 0 : _a.trim()) !== ''));\n        });\n        return html `\n      <div\n        part=\"base\"\n        class=${classMap({\n            card: true,\n            'card--has-footer': this.hasSlotController.test('footer'),\n            'card--has-image': this.hasSlotController.test('image'),\n            'card--has-header': this.hasSlotController.test('header')\n        })}\n      >\n        <slot name=\"image\" part=\"image\" class=\"card__image\"></slot>\n        <div class=\"card-content\">\n          <slot\n            name=\"header\"\n            part=\"header\"\n            class=\"\n              card__header: true\"\n          ></slot>\n          <slot\n            part=\"body\"\n            class=${classMap({\n            card__body: true,\n            'card__body--has-margin-bottom': this.hasSlotController.test('footer'),\n            'card__body--has-margin-top': this.hasSlotController.test('header') && defaultSlotHasContent\n        })}\n          ></slot>\n          <slot name=\"footer\" part=\"footer\" class=\"card__footer\"></slot>\n        </div>\n      </div>\n    `;\n    }\n}\nCard.styles = styles;\nexport default Card;\n__decorate([\n    query('slot:not([name])')\n], Card.prototype, \"defaultSlot\", void 0);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/** Exception due eslint doesn't support WAI-ARIA 1.3 that supports aria-description attr */\n/* eslint-disable lit-a11y/aria-attrs */\nimport { classMap } from 'lit/directives/class-map.js';\nimport { defaultValue } from '../../internal/default-value';\nimport { html } from 'lit';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { live } from 'lit/directives/live.js';\nimport { property, query, state } from 'lit/decorators.js';\nimport { watch } from '../../internal/watch';\nimport componentStyles from '../../styles/component.styles';\nimport Icon from '../icon/icon.component';\nimport styles from './checkbox.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Checkboxes allow the user to toggle an option on or off.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-checkbox--docs\n * @status stable\n * @since 2.0\n *\n * @dependency koerber-icon\n *\n * @slot - The checkbox's label.\n *\n * @event koerber-blur - Emitted when the checkbox loses focus.\n * @event koerber-change - Emitted when the checked state changes.\n * @event koerber-focus - Emitted when the checkbox gains focus.\n * @event koerber-input - Emitted when the checkbox receives input.\n *\n * @csspart base - The component's base wrapper.\n * @csspart control - The square container that wraps the checkbox's checked state.\n * @csspart control--checked - Matches the control part when the checkbox is checked.\n * @csspart control--indeterminate - Matches the control part when the checkbox is indeterminate.\n * @csspart checked-icon - The checked icon, an `<koerber-icon>` element.\n * @csspart indeterminate-icon - The indeterminate icon, an `<koerber-icon>` element.\n * @csspart label - The container that wraps the checkbox's label.\n */\nclass Checkbox extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.hasFocus = false;\n        this.title = ''; // make reactive to pass through\n        /** The name of the checkbox, submitted as a name/value pair with form data. */\n        this.name = '';\n        /** The checkbox's size. */\n        this.size = 'standard';\n        /** Disables the checkbox. */\n        this.disabled = false;\n        /** Draws the checkbox in a checked state. */\n        this.checked = false;\n        /**\n         * Draws the checkbox in an indeterminate state. This is usually applied to checkboxes that represents a \"select\n         * all/none\" behavior when associated checkboxes have a mix of checked and unchecked states.\n         */\n        this.indeterminate = false;\n        /** The default value of the form control. Primarily used for resetting the form control. */\n        this.defaultChecked = false;\n        /** Makes the checkbox a required field. */\n        this.required = false;\n        /**\n         * Used to indicate that the input has some error based on some rule.\n         */\n        this.error = false;\n    }\n    handleClick(event) {\n        event.preventDefault();\n        this.checked = !this.checked;\n        this.indeterminate = false;\n        this.emit('koerber-change');\n    }\n    handleWrapperClick(event) {\n        event.preventDefault();\n        if (event.target.tagName !== 'INPUT') {\n            this.checked = !this.checked;\n            this.emit('koerber-change');\n        }\n    }\n    handleKeyDown(event) {\n        if (event.key === ' ') {\n            event.preventDefault();\n            this.checked = !this.checked;\n            this.emit('koerber-change');\n        }\n    }\n    simulateSpacebarPress() {\n        const event = new KeyboardEvent('keydown', {\n            key: ' ',\n            code: 'Space',\n            keyCode: 32,\n            charCode: 32,\n            which: 32,\n            bubbles: true,\n            cancelable: true,\n            composed: true\n        });\n        this.handleKeyDown(event);\n    }\n    handleBlur() {\n        this.hasFocus = false;\n        this.emit('koerber-blur');\n    }\n    handleInput() {\n        this.emit('koerber-input');\n    }\n    handleFocus() {\n        this.hasFocus = true;\n        this.emit('koerber-focus');\n    }\n    handleStateChange() {\n        this.input.checked = this.checked; // force a sync update\n        this.input.indeterminate = this.indeterminate; // force a sync update\n    }\n    /** Simulates a click on the checkbox. */\n    click() {\n        this.input.click();\n    }\n    /** Sets focus on the checkbox. */\n    focus(options) {\n        this.input.focus(options);\n    }\n    /** Removes focus from the checkbox. */\n    blur() {\n        this.input.blur();\n    }\n    render() {\n        //\n        // NOTE: we use a <div> around the label slot because of this Chrome bug.\n        //\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1413733\n        //\n        return html `\r\n      <div class=\"checkbox-wrapper\" @click=${this.handleWrapperClick}>\r\n        <label\r\n          part=\"base\"\r\n          class=${classMap({\n            checkbox: true,\n            'checkbox--checked': this.checked,\n            'checkbox--disabled': this.disabled,\n            'checkbox--focused': this.hasFocus,\n            'checkbox--indeterminate': this.indeterminate,\n            'checkbox--standard': this.size === 'standard',\n            'checkbox--comfortable': this.size === 'comfortable',\n            'checkbox--error': this.error\n        })}\r\n        >\r\n          <input\r\n            class=\"checkbox__input\"\r\n            type=\"checkbox\"\r\n            title=${this.title /* An empty title prevents browser validation tooltips from appearing on hover */}\r\n            name=${this.name}\r\n            value=${ifDefined(this.value)}\r\n            .indeterminate=${live(this.indeterminate)}\r\n            .checked=${live(this.checked)}\r\n            .disabled=${this.disabled}\r\n            .required=${this.required}\r\n            aria-checked=${this.checked ? 'true' : 'false'}\r\n            aria-label=${ifDefined(this.accessibleName)}\r\n            aria-description=${ifDefined(this.accessibleDescription)}\r\n            @click=${this.handleClick}\r\n            @input=${this.handleInput}\r\n            @blur=${this.handleBlur}\r\n            @focus=${this.handleFocus}\r\n            @keydown=${this.handleKeyDown}\r\n          />\r\n\r\n          <span\r\n            part=\"control${this.checked ? ' control--checked' : ''}${this.indeterminate\n            ? ' control--indeterminate'\n            : ''}\"\r\n            class=\"checkbox__control\"\r\n          >\r\n            ${this.checked\n            ? html `\r\n                  <koerber-icon\r\n                    part=\"checked-icon\"\r\n                    class=\"checkbox__checked-icon\"\r\n                    library=\"system\"\r\n                    name=\"check\"\r\n                    size=\"medium\"\r\n                  ></koerber-icon>\r\n                `\n            : ''}\r\n            ${!this.checked && this.indeterminate\n            ? html `\r\n                  <koerber-icon\r\n                    part=\"indeterminate-icon\"\r\n                    class=\"checkbox__indeterminate-icon\"\r\n                    library=\"system\"\r\n                    name=\"minus\"\r\n                    size=\"medium\"\r\n                  ></koerber-icon>\r\n                `\n            : ''}\r\n          </span>\r\n\r\n          <div part=\"label\" class=\"checkbox__label\">\r\n            <slot>\r\n              <koerber-form-field-label label=\"${this.label}\"></koerber-form-field-label>\r\n            </slot>\r\n          </div>\r\n        </label>\r\n      </div>\r\n    `;\n    }\n}\nCheckbox.styles = [componentStyles, styles];\nCheckbox.dependencies = { 'koerber-icon': Icon };\nexport default Checkbox;\n__decorate([\n    query('input[type=\"checkbox\"]')\n], Checkbox.prototype, \"input\", void 0);\n__decorate([\n    state()\n], Checkbox.prototype, \"hasFocus\", void 0);\n__decorate([\n    property()\n], Checkbox.prototype, \"title\", void 0);\n__decorate([\n    property()\n], Checkbox.prototype, \"name\", void 0);\n__decorate([\n    property()\n], Checkbox.prototype, \"value\", void 0);\n__decorate([\n    property()\n], Checkbox.prototype, \"label\", void 0);\n__decorate([\n    property({ reflect: true })\n], Checkbox.prototype, \"size\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Checkbox.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Checkbox.prototype, \"checked\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Checkbox.prototype, \"indeterminate\", void 0);\n__decorate([\n    defaultValue('checked')\n], Checkbox.prototype, \"defaultChecked\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Checkbox.prototype, \"required\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Checkbox.prototype, \"error\", void 0);\n__decorate([\n    property({ attribute: 'accessible-name', reflect: true })\n], Checkbox.prototype, \"accessibleName\", void 0);\n__decorate([\n    property({ attribute: 'accessible-description', reflect: true })\n], Checkbox.prototype, \"accessibleDescription\", void 0);\n__decorate([\n    watch(['checked', 'indeterminate'], { waitUntilFirstUpdate: true })\n], Checkbox.prototype, \"handleStateChange\", null);\n","import { createRef, ref } from 'lit/directives/ref.js';\nimport { html } from 'lit';\n/** A reactive controller to manage the registration of event listeners for submenus. */\nexport class SubmenuController {\n    constructor(host, hasSlotController, localize) {\n        this.popupRef = createRef();\n        this.enableSubmenuTimer = -1;\n        this.isConnected = false;\n        this.isPopupConnected = false;\n        this.skidding = 0;\n        this.submenuOpenDelay = 100;\n        // Set the safe triangle cursor position\n        this.handleMouseMove = (event) => {\n            this.host.style.setProperty('--safe-triangle-cursor-x', `${event.clientX}px`);\n            this.host.style.setProperty('--safe-triangle-cursor-y', `${event.clientY}px`);\n        };\n        this.handleMouseOver = () => {\n            if (this.hasSlotController.test('submenu')) {\n                this.enableSubmenu();\n            }\n        };\n        // Focus on the first menu-item of a submenu.\n        this.handleKeyDown = (event) => {\n            switch (event.key) {\n                case 'Escape':\n                case 'Tab':\n                    this.disableSubmenu();\n                    break;\n                case 'ArrowLeft':\n                    // Either focus is currently on the host element or a child\n                    if (event.target !== this.host) {\n                        event.preventDefault();\n                        event.stopPropagation();\n                        this.host.focus();\n                        this.disableSubmenu();\n                    }\n                    break;\n                case 'ArrowRight':\n                case 'Enter':\n                case ' ':\n                    this.handleSubmenuEntry(event);\n                    break;\n                default:\n                    break;\n            }\n        };\n        this.handleClick = (event) => {\n            var _a;\n            // Clicking on the item which heads the menu does nothing, otherwise hide submenu and propagate\n            if (event.target === this.host) {\n                // event.preventDefault();\n                // event.stopPropagation();\n            }\n            else if (event.target instanceof Element &&\n                (event.target.tagName === 'KOERBER-MENU-ITEM' || ((_a = event.target.role) === null || _a === void 0 ? void 0 : _a.startsWith('menuitem')))) {\n                this.disableSubmenu();\n                event.preventDefault();\n                event.stopPropagation();\n            }\n        };\n        // Close this submenu on focus outside of the parent or any descendants.\n        this.handleFocusOut = (event) => {\n            if (event.relatedTarget && event.relatedTarget instanceof Element && this.host.contains(event.relatedTarget)) {\n                return;\n            }\n            this.disableSubmenu();\n        };\n        // Prevent the parent menu-item from getting focus on mouse movement on the submenu\n        this.handlePopupMouseover = (event) => {\n            event.stopPropagation();\n        };\n        // Set the safe triangle values for the submenu when the position changes\n        this.handlePopupReposition = () => {\n            const submenuSlot = this.host.renderRoot.querySelector(\"slot[name='submenu']\");\n            const menu = submenuSlot === null || submenuSlot === void 0 ? void 0 : submenuSlot.assignedElements({ flatten: true }).filter(el => el.localName === 'koerber-menu')[0];\n            const isRtl = this.localize.dir() === 'rtl';\n            if (!menu) {\n                return;\n            }\n            const { left, top, width, height } = menu.getBoundingClientRect();\n            this.host.style.setProperty('--safe-triangle-submenu-start-x', `${isRtl ? left + width : left}px`);\n            this.host.style.setProperty('--safe-triangle-submenu-start-y', `${top}px`);\n            this.host.style.setProperty('--safe-triangle-submenu-end-x', `${isRtl ? left + width : left}px`);\n            this.host.style.setProperty('--safe-triangle-submenu-end-y', `${top + height}px`);\n        };\n        (this.host = host).addController(this);\n        this.hasSlotController = hasSlotController;\n        this.localize = localize;\n    }\n    hostConnected() {\n        if (this.hasSlotController.test('submenu') && !this.host.disabled) {\n            this.addListeners();\n        }\n    }\n    hostDisconnected() {\n        this.removeListeners();\n    }\n    hostUpdated() {\n        if (this.hasSlotController.test('submenu') && !this.host.disabled) {\n            this.addListeners();\n            this.updateSkidding();\n        }\n        else {\n            this.removeListeners();\n        }\n    }\n    addListeners() {\n        if (!this.isConnected) {\n            this.host.addEventListener('mousemove', this.handleMouseMove);\n            this.host.addEventListener('mouseover', this.handleMouseOver);\n            this.host.addEventListener('keydown', this.handleKeyDown);\n            this.host.addEventListener('click', this.handleClick);\n            this.host.addEventListener('focusout', this.handleFocusOut);\n            this.isConnected = true;\n        }\n        // The popup does not seem to get wired when the host is\n        // connected, so manage its listeners separately.\n        if (!this.isPopupConnected) {\n            if (this.popupRef.value) {\n                this.popupRef.value.addEventListener('mouseover', this.handlePopupMouseover);\n                this.popupRef.value.addEventListener('koerber-reposition', this.handlePopupReposition);\n                this.isPopupConnected = true;\n            }\n        }\n    }\n    removeListeners() {\n        if (this.isConnected) {\n            this.host.removeEventListener('mousemove', this.handleMouseMove);\n            this.host.removeEventListener('mouseover', this.handleMouseOver);\n            this.host.removeEventListener('keydown', this.handleKeyDown);\n            this.host.removeEventListener('click', this.handleClick);\n            this.host.removeEventListener('focusout', this.handleFocusOut);\n            this.isConnected = false;\n        }\n        if (this.isPopupConnected) {\n            if (this.popupRef.value) {\n                this.popupRef.value.removeEventListener('mouseover', this.handlePopupMouseover);\n                this.popupRef.value.removeEventListener('koerber-reposition', this.handlePopupReposition);\n                this.isPopupConnected = false;\n            }\n        }\n    }\n    handleSubmenuEntry(event) {\n        // Pass focus to the first menu-item in the submenu.\n        const submenuSlot = this.host.renderRoot.querySelector(\"slot[name='submenu']\");\n        // Missing slot\n        if (!submenuSlot) {\n            console.error('Cannot activate a submenu if no corresponding menuitem can be found.', this);\n            return;\n        }\n        // Menus\n        let menuItems = null;\n        for (const elt of submenuSlot.assignedElements()) {\n            menuItems = elt.querySelectorAll(\"koerber-menu-item, [role^='menuitem']\");\n            if (menuItems.length !== 0) {\n                break;\n            }\n        }\n        if (!menuItems || menuItems.length === 0) {\n            return;\n        }\n        menuItems[0].setAttribute('tabindex', '0');\n        for (let i = 1; i !== menuItems.length; ++i) {\n            menuItems[i].setAttribute('tabindex', '-1');\n        }\n        // Open the submenu (if not open), and set focus to first menuitem.\n        if (this.popupRef.value) {\n            event.preventDefault();\n            event.stopPropagation();\n            if (this.popupRef.value.active) {\n                if (menuItems[0] instanceof HTMLElement) {\n                    menuItems[0].focus();\n                }\n            }\n            else {\n                this.enableSubmenu(false);\n                this.host.updateComplete.then(() => {\n                    if ((menuItems === null || menuItems === void 0 ? void 0 : menuItems[0]) instanceof HTMLElement) {\n                        menuItems[0].focus();\n                    }\n                });\n                this.host.requestUpdate();\n            }\n        }\n    }\n    setSubmenuState(state) {\n        if (this.popupRef.value) {\n            if (this.popupRef.value.active !== state) {\n                this.popupRef.value.active = state;\n                this.host.requestUpdate();\n            }\n        }\n    }\n    // Shows the submenu. Supports disabling the opening delay, e.g. for keyboard events that want to set the focus to the\n    // newly opened menu.\n    enableSubmenu(delay = true) {\n        if (delay) {\n            window.clearTimeout(this.enableSubmenuTimer);\n            this.enableSubmenuTimer = window.setTimeout(() => {\n                this.setSubmenuState(true);\n            }, this.submenuOpenDelay);\n        }\n        else {\n            this.setSubmenuState(true);\n        }\n    }\n    disableSubmenu() {\n        window.clearTimeout(this.enableSubmenuTimer);\n        this.setSubmenuState(false);\n    }\n    // Calculate the space the top of a menu takes-up, for aligning the popup menu-item with the activating element.\n    updateSkidding() {\n        var _a;\n        // .computedStyleMap() not always available.\n        if (!((_a = this.host.parentElement) === null || _a === void 0 ? void 0 : _a.computedStyleMap)) {\n            return;\n        }\n        const styleMap = this.host.parentElement.computedStyleMap();\n        const attrs = ['padding-top', 'border-top-width', 'margin-top'];\n        const skidding = attrs.reduce((accumulator, attr) => {\n            var _a;\n            const styleValue = (_a = styleMap.get(attr)) !== null && _a !== void 0 ? _a : new CSSUnitValue(0, 'px');\n            const unitValue = styleValue instanceof CSSUnitValue ? styleValue : new CSSUnitValue(0, 'px');\n            const pxValue = unitValue.to('px');\n            return accumulator - pxValue.value;\n        }, 0);\n        this.skidding = skidding;\n    }\n    isExpanded() {\n        return this.popupRef.value ? this.popupRef.value.active : false;\n    }\n    renderSubmenu() {\n        const isLtr = this.localize.dir() === 'ltr';\n        // Always render the slot, but conditionally render the outer <sl-popup>\n        if (!this.isConnected) {\n            return html ` <slot name=\"submenu\" hidden></slot> `;\n        }\n        return html `\r\n      <koerber-popup\r\n        ${ref(this.popupRef)}\r\n        placement=${isLtr ? 'right-start' : 'left-start'}\r\n        anchor=\"anchor\"\r\n        distance=\"4\"\r\n        flip\r\n        flip-fallback-strategy=\"best-fit\"\r\n        skidding=\"${this.skidding}\"\r\n        strategy=\"fixed\"\r\n      >\r\n        <slot name=\"submenu\"></slot>\r\n      </koerber-popup>\r\n    `;\n    }\n}\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { classMap } from 'lit/directives/class-map.js';\nimport { getTextContent, HasSlotController } from '../../internal/slot';\nimport { html } from 'lit';\nimport { LocalizeController } from '../../utilities/localize';\nimport { property, query, state } from 'lit/decorators.js';\nimport { SubmenuController } from './submenu-controller';\nimport { watch } from '../../internal/watch';\nimport componentStyles from '../../styles/component.styles';\nimport Icon from '../icon/icon';\nimport Popup from '../popup/popup';\nimport styles from './menu-item.styles';\nimport Tooltip from '../tooltip/tooltip';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Menu items provide options for the user to pick from in a menu.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net\n * @status stable\n * @since 2.0\n *\n * @dependency koerber-icon\n * @dependency koerber-popup\n * @dependency koerber-spinner\n * @dependency koerber-tooltip\n *\n * @slot - The menu item's label.\n * @slot prefix - Used to prepend an icon or similar element to the menu item.\n * @slot suffix - Used to append an icon or similar element to the menu item.\n * @slot submenu - Used to denote a nested menu.\n *\n * @csspart base - The component's base wrapper.\n * @csspart prefix - The prefix container.\n * @csspart label - The menu item label.\n * @csspart suffix - The suffix container.\n * @csspart spinner - The spinner that shows when the menu item is in the loading state.\n * @csspart spinner__base - The spinner's base part.\n * @csspart submenu-icon - The submenu icon, visible only when the menu item has a submenu (not yet implemented).\n *\n * @cssproperty [--submenu-offset=-2px] - The distance submenus shift to overlap the parent menu.\n */\nclass MenuItem extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.tooltipContent = '';\n        /* Checks if text is overflowing */\n        this.isLabelOverflowing = false;\n        /** The type of menu item to render. To use `checked`, this value must be set t`. */\n        this.type = 'checkbox';\n        /** Draws the item in a selected state. */\n        this.selected = false;\n        /** A unique value to store in the menu item. This can be used as a way to identify menu items when selected. */\n        this.value = '';\n        /** Draws the menu item in a loading state. */\n        // @property({ type: Boolean, reflect: true }) loading = false;\n        /** Draws the menu item in a disabled state, preventing selection. */\n        this.disabled = false;\n        /** The height size value of the item - medium by default */\n        this.size = 'medium';\n        this.localize = new LocalizeController(this);\n        this.hasSlotController = new HasSlotController(this, 'submenu', 'prefix', 'suffix');\n        this.submenuController = new SubmenuController(this, this.hasSlotController, this.localize);\n        this.handleHostClick = (event) => {\n            // Prevent the click event from being emitted when the button is disabled or loading\n            if (this.disabled) {\n                event.preventDefault();\n                event.stopImmediatePropagation();\n            }\n        };\n        this.handleMouseOver = (event) => {\n            this.focus();\n            event.stopPropagation();\n        };\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.addEventListener('click', this.handleHostClick);\n        this.addEventListener('mouseover', this.handleMouseOver);\n        this.setAttribute('role', 'menuitemcheckbox');\n        this.setAttribute('aria-checked', this.selected ? 'true' : 'false');\n    }\n    firstUpdated() {\n        this.checkTextOverflow();\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this.removeEventListener('click', this.handleHostClick);\n        this.removeEventListener('mouseover', this.handleMouseOver);\n    }\n    checkTextOverflow() {\n        if (this.labelContentSlot.scrollHeight > this.labelContentSlot.clientHeight) {\n            this.isLabelOverflowing = true;\n            this.tooltipContent = this.getTextLabel();\n        }\n        else {\n            this.isLabelOverflowing = false;\n            this.tooltipContent = '';\n        }\n    }\n    handleDefaultSlotChange() {\n        const textLabel = this.getTextLabel();\n        // Ignore the first time the label is set\n        if (typeof this.cachedTextLabel === 'undefined') {\n            this.cachedTextLabel = textLabel;\n            return;\n        }\n        // When the label changes, emit a slotchange event so parent controls see it\n        if (textLabel !== this.cachedTextLabel) {\n            this.cachedTextLabel = textLabel;\n            this.emit('slotchange', { bubbles: true, composed: false, cancelable: false });\n        }\n    }\n    handleCheckedChange() {\n        this.setAttribute('aria-checked', this.selected ? 'true' : 'false');\n    }\n    handleDisabledChange() {\n        this.setAttribute('aria-disabled', this.disabled ? 'true' : 'false');\n    }\n    /** Returns a text label based on the contents of the menu item's default slot. */\n    getTextLabel() {\n        return getTextContent(this.defaultSlot);\n    }\n    isSubmenu() {\n        return this.hasSlotController.test('submenu');\n    }\n    render() {\n        var _a;\n        const isRtl = this.localize.dir() === 'rtl';\n        const isSubmenuExpanded = this.submenuController.isExpanded();\n        return html `\r\n      <div\r\n        id=\"anchor\"\r\n        part=\"base\"\r\n        class=${classMap({\n            'menu-item': true,\n            'menu-item--rtl': isRtl,\n            'menu-item--selected': this.selected,\n            'menu-item--disabled': this.disabled,\n            // 'menu-item--loading': this.loading,\n            'menu-item--has-submenu': this.isSubmenu(),\n            'menu-item--submenu-expanded': isSubmenuExpanded,\n            [`menu-item--${this.size}`]: true\n        })}\r\n        ?aria-haspopup=\"${this.isSubmenu()}\"\r\n        ?aria-expanded=\"${isSubmenuExpanded ? true : false}\"\r\n      >\r\n        ${this.hasSlotController.test('prefix')\n            ? html `<slot name=\"prefix\" part=\"prefix\" class=\"menu-item__prefix\"></slot>`\n            : ''}\r\n        ${this.isLabelOverflowing\n            ? html `<koerber-tooltip\r\n              class=\"menu-item__tooltip\"\r\n              placement=\"top\"\r\n              hoist\r\n              content=\"${(_a = this.tooltipContent) !== null && _a !== void 0 ? _a : ''}\"\r\n            >\r\n              <div><slot part=\"label\" class=\"menu-item__label\" @slotchange=${this.handleDefaultSlotChange}></slot></div>\r\n            </koerber-tooltip>`\n            : html `<slot part=\"label\" class=\"menu-item__label\" @slotchange=${this.handleDefaultSlotChange}></slot>`}\r\n        ${this.hasSlotController.test('suffix')\n            ? html `<slot name=\"suffix\" part=\"suffix\" class=\"menu-item__suffix\"></slot>`\n            : ''}\r\n        ${this.isSubmenu()\n            ? html `<span part=\"submenu-icon\" class=\"menu-item__chevron\">\r\n              <koerber-icon name=${isRtl ? 'chevron-left' : 'chevron-right'} aria-hidden=\"true\"></koerber-icon>\r\n            </span>`\n            : ''}\r\n        ${this.submenuController.renderSubmenu()}\r\n      </div>\r\n    `;\n    }\n}\nMenuItem.styles = [componentStyles, styles];\nMenuItem.dependencies = {\n    'koerber-icon': Icon,\n    'koerber-popup': Popup,\n    'koerber-tooltip': Tooltip\n};\nexport default MenuItem;\n__decorate([\n    state()\n], MenuItem.prototype, \"isLabelOverflowing\", void 0);\n__decorate([\n    query('slot:not([name])')\n], MenuItem.prototype, \"defaultSlot\", void 0);\n__decorate([\n    query('.menu-item')\n], MenuItem.prototype, \"menuItem\", void 0);\n__decorate([\n    query('.menu-item__label')\n], MenuItem.prototype, \"labelContentSlot\", void 0);\n__decorate([\n    property()\n], MenuItem.prototype, \"type\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], MenuItem.prototype, \"selected\", void 0);\n__decorate([\n    property()\n], MenuItem.prototype, \"value\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], MenuItem.prototype, \"disabled\", void 0);\n__decorate([\n    property({ reflect: true })\n], MenuItem.prototype, \"size\", void 0);\n__decorate([\n    watch('selected')\n], MenuItem.prototype, \"handleCheckedChange\", null);\n__decorate([\n    watch('disabled')\n], MenuItem.prototype, \"handleDisabledChange\", null);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { html } from 'lit';\nimport { query } from 'lit/decorators.js';\nimport componentStyles from '../../styles/component.styles';\nimport styles from './menu.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Menus provide a list of options for the user to choose from.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net\n * @status stable\n * @since 2.0\n *\n * @slot - The menu's content, including menu items, menu labels, and dividers.\n *\n * @event {{ item: MenuItem }} koerber-select - Emitted when a menu item is selected.\n */\nclass Menu extends UIKitElement {\n    connectedCallback() {\n        super.connectedCallback();\n        this.setAttribute('role', 'menu');\n    }\n    handleClick(event) {\n        const target = event.target;\n        const menuItem = target.closest('koerber-menu-item');\n        if (!target)\n            return;\n        // This isn't true. But we use it for TypeScript checks below.\n        const item = menuItem;\n        this.emit('koerber-select', { detail: { item } });\n    }\n    handleKeyDown(event) {\n        // Make a selection when pressing enter or space\n        if (event.key === 'Enter' || event.key === ' ') {\n            const item = this.getCurrentItem();\n            event.preventDefault();\n            event.stopPropagation();\n            // Simulate a click to support @click handlers on menu items that also work with the keyboard\n            item === null || item === void 0 ? void 0 : item.click();\n        }\n        // Move the selection when pressing down or up\n        else if (['ArrowDown', 'ArrowUp', 'Home', 'End'].includes(event.key)) {\n            const items = this.getAllItems();\n            const activeItem = this.getCurrentItem();\n            let index = activeItem ? items.indexOf(activeItem) : 0;\n            if (items.length > 0) {\n                event.preventDefault();\n                event.stopPropagation();\n                if (event.key === 'ArrowDown') {\n                    index++;\n                }\n                else if (event.key === 'ArrowUp') {\n                    index--;\n                }\n                else if (event.key === 'Home') {\n                    index = 0;\n                }\n                else if (event.key === 'End') {\n                    index = items.length - 1;\n                }\n                if (index < 0) {\n                    index = items.length - 1;\n                }\n                if (index > items.length - 1) {\n                    index = 0;\n                }\n                this.setCurrentItem(items[index]);\n                items[index].focus();\n            }\n        }\n    }\n    handleMouseDown(event) {\n        const target = event.target;\n        if (this.isMenuItem(target)) {\n            this.setCurrentItem(target);\n        }\n    }\n    handleSlotChange() {\n        const items = this.getAllItems();\n        // Reset the roving tab index when the slotted items change\n        if (items.length > 0) {\n            this.setCurrentItem(items[0]);\n        }\n    }\n    isMenuItem(item) {\n        var _a;\n        return (item.tagName.toLowerCase() === 'koerber-menu-item' ||\n            ['menuitem', 'menuitemradio'].includes((_a = item.getAttribute('role')) !== null && _a !== void 0 ? _a : ''));\n    }\n    /** @internal Gets all slotted menu items, ignoring dividers, headers, and other elements. */\n    getAllItems() {\n        return [...this.defaultSlot.assignedElements({ flatten: true })].filter((el) => {\n            if (el.inert || !this.isMenuItem(el)) {\n                return false;\n            }\n            return true;\n        });\n    }\n    /**\n     * @internal Gets the current menu item, which is the menu item that has `tabindex=\"0\"` within the roving tab index.\n     * The menu item may or may not have focus, but for keyboard interaction purposes it's considered the \"active\" item.\n     */\n    getCurrentItem() {\n        return this.getAllItems().find(i => i.getAttribute('tabindex') === '0');\n    }\n    /**\n     * @internal Sets the current menu item to the specified element. This sets `tabindex=\"0\"` on the target element and\n     * `tabindex=\"-1\"` to all other items. This method must be called prior to setting focus on a menu item.\n     */\n    setCurrentItem(item) {\n        const items = this.getAllItems();\n        // Update tab indexes\n        items.forEach(i => {\n            i.setAttribute('tabindex', i === item ? '0' : '-1');\n        });\n    }\n    render() {\n        return html `\r\n      <slot\r\n        @slotchange=${this.handleSlotChange}\r\n        @click=${this.handleClick}\r\n        @keydown=${this.handleKeyDown}\r\n        @mousedown=${this.handleMouseDown}\r\n      ></slot>\r\n    `;\n    }\n}\nMenu.styles = [componentStyles, styles];\nexport default Menu;\n__decorate([\n    query('slot')\n], Menu.prototype, \"defaultSlot\", void 0);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { classMap } from 'lit/directives/class-map.js';\nimport { html } from 'lit';\nimport { LocalizeController } from '../../utilities/localize';\nimport { property, query, state } from 'lit/decorators.js';\nimport { watch } from '../../internal/watch';\nimport Checkbox from '../checkbox/checkbox.component';\nimport componentStyles from '../../styles/component.styles';\nimport Icon from '../icon/icon.component';\nimport styles from './select-option.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Options define the selectable items within various form controls such as [select](/components/select).\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-select-option--docs\n * @status stable\n * @since 2.0\n *\n * @dependency koerber-icon\n *\n * @slot - The option's label.\n * @slot prefix - Used to prepend an icon or similar element to the menu item.\n * @slot suffix - Used to append an icon or similar element to the menu item.\n *\n * @csspart checked-icon - The checked icon, an `<koerber-icon>` element.\n * @csspart base - The component's base wrapper.\n * @csspart label - The option's label.\n * @csspart prefix - The container that wraps the prefix.\n * @csspart suffix - The container that wraps the suffix.\n */\nclass SelectOption extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        // @ts-expect-error - Controller is currently unused\n        this.localize = new LocalizeController(this);\n        this.current = false; // the user has keyed into the option, but hasn't selected it yet (shows a highlight)\n        this.selected = false; // the option is selected and has aria-selected=\"true\"\n        this.hasHover = false; // we need this because Safari doesn't honor :hover styles while dragging\n        /**\n         * The option's value. When selected, the containing form control will receive this value. The value must be unique\n         * from other options in the same group. Values may not contain spaces, as spaces are used as delimiters when listing\n         * multiple values.\n         */\n        this.value = '';\n        /** Draws the option in a disabled state, preventing selection. */\n        this.disabled = false;\n        /** Draws the option in a checkbox state. */\n        this.checkbox = false;\n        /**\n         * The option's size. When used inside a select, the size will be determined by the select's size so this\n         * attribute can typically be omitted.\n         */\n        this.size = 'medium';\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.setAttribute('role', 'option');\n        this.setAttribute('aria-selected', 'false');\n    }\n    handleDefaultSlotChange() {\n        const textLabel = this.getTextLabel();\n        // Ignore the first time the label is set\n        if (typeof this.cachedTextLabel === 'undefined') {\n            this.cachedTextLabel = textLabel;\n            return;\n        }\n        // When the label changes, emit a slotchange event so parent controls see it\n        if (textLabel !== this.cachedTextLabel) {\n            this.cachedTextLabel = textLabel;\n            this.emit('slotchange', { bubbles: true, composed: false, cancelable: false });\n        }\n    }\n    handleMouseEnter() {\n        this.hasHover = true;\n        this.current = true;\n    }\n    handleMouseLeave() {\n        this.hasHover = false;\n        this.current = false;\n    }\n    handleDisabledChange() {\n        this.setAttribute('aria-disabled', this.disabled ? 'true' : 'false');\n    }\n    handleSelectedChange() {\n        this.setAttribute('aria-selected', this.selected ? 'true' : 'false');\n    }\n    handleValueChange() {\n        // Ensure the value is a string. This ensures the next line doesn't error and allows framework users to pass numbers\n        // instead of requiring them to cast the value to a string.\n        if (typeof this.value !== 'string') {\n            this.value = String(this.value);\n        }\n        if (this.value.includes(' ')) {\n            console.error(`Option values cannot include a space. All spaces have been replaced with underscores.`, this);\n            this.value = this.value.replace(/ /g, '_');\n        }\n    }\n    // We are binding the click event to the options selected value because the first click\n    // is not handled correctly as the checkbox does not have focus initially\n    handleCheckboxClick(event) {\n        this.selected = !this.selected;\n        this.emit('koerber-change');\n        event.preventDefault();\n    }\n    /** Returns a plain text label based on the option's content. */\n    getTextLabel() {\n        var _a;\n        return ((_a = this.textContent) !== null && _a !== void 0 ? _a : '').trim();\n    }\n    render() {\n        return html `\r\n      <div\r\n        part=\"base\"\r\n        class=${classMap({\n            'select-option': true,\n            'select-option--current': this.current,\n            'select-option--disabled': this.disabled,\n            'select-option--selected': this.selected,\n            'select-option--hover': this.hasHover,\n            'select-option--small': this.size === 'small',\n            'select-option--medium': this.size === 'medium',\n            'select-option--large': this.size === 'large'\n        })}\r\n        @mouseenter=${this.handleMouseEnter}\r\n        @mouseleave=${this.handleMouseLeave}\r\n      >\r\n        ${this.checkbox\n            ? html ` <koerber-checkbox\r\n              class=${classMap({\n                'select-option__checkbox': true,\n                'checkbox--small': this.size === 'small',\n                'checkbox--medium': this.size === 'medium',\n                'checkbox--large': this.size === 'large'\n            })}\r\n              @click=${this.handleCheckboxClick}\r\n              ?checked=${this.selected}\r\n            >\r\n            </koerber-checkbox>`\n            : ''}\r\n        <slot part=\"prefix\" name=\"prefix\" class=\"select-option__prefix\"></slot>\r\n        <slot\r\n          part=\"label\"\r\n          class=${classMap({\n            'select-option__label': true,\n            'select-option-label--small': this.size === 'small',\n            'select-option-label--medium': this.size === 'medium',\n            'select-option-label--large': this.size === 'large'\n        })}\r\n          @slotchange=${this.handleDefaultSlotChange}\r\n        >\r\n        </slot>\r\n        <slot part=\"suffix\" name=\"suffix\" class=\"select-option__suffix\"></slot>\r\n        ${this.checkbox\n            ? ''\n            : html ` <koerber-icon\r\n              part=\"checked-icon\"\r\n              class=${classMap({\n                'select-option__check': true,\n                'icon--small': this.size === 'small',\n                'icon--medium': this.size === 'medium',\n                'icon--large': this.size === 'large'\n            })}\r\n              name=\"check\"\r\n              size=${this.size}\r\n              library=\"system\"\r\n              aria-hidden=\"true\"\r\n            >\r\n            </koerber-icon>`}\r\n      </div>\r\n    `;\n    }\n}\nSelectOption.styles = [componentStyles, styles];\nSelectOption.dependencies = {\n    'koerber-icon': Icon,\n    'koerber-checkbox': Checkbox\n};\nexport default SelectOption;\n__decorate([\n    query('.select-option__label')\n], SelectOption.prototype, \"defaultSlot\", void 0);\n__decorate([\n    state()\n], SelectOption.prototype, \"current\", void 0);\n__decorate([\n    state()\n], SelectOption.prototype, \"selected\", void 0);\n__decorate([\n    state()\n], SelectOption.prototype, \"hasHover\", void 0);\n__decorate([\n    property({ reflect: true })\n], SelectOption.prototype, \"value\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], SelectOption.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], SelectOption.prototype, \"checkbox\", void 0);\n__decorate([\n    property({ reflect: true })\n], SelectOption.prototype, \"size\", void 0);\n__decorate([\n    watch('disabled')\n], SelectOption.prototype, \"handleDisabledChange\", null);\n__decorate([\n    watch('selected')\n], SelectOption.prototype, \"handleSelectedChange\", null);\n__decorate([\n    watch('value')\n], SelectOption.prototype, \"handleValueChange\", null);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/** Exception due eslint doesn't support WAI-ARIA 1.3 that supports aria-description attr */\n/* eslint-disable lit-a11y/aria-attrs */\nimport { animateTo, stopAnimations } from '../../internal/animate';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { defaultValue } from '../../internal/default-value';\nimport { getAnimation, setDefaultAnimation } from '../../utilities/animation-registry';\nimport { html } from 'lit';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { LocalizeController } from '../../utilities/localize';\nimport { property, query, state } from 'lit/decorators.js';\nimport { scrollIntoView } from '../../internal/scroll';\nimport { waitForEvent } from '../../internal/event';\nimport { watch } from '../../internal/watch';\nimport componentStyles from '../../styles/component.styles';\nimport formControlStyles from '../../styles/form-control.styles';\nimport Icon from '../icon/icon.component';\nimport Popup from '../popup/popup.component';\nimport Spinner from '../spinner/spinner.component';\nimport styles from './select.styles';\nimport Tag from '../tag/tag.component';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Selects allow you to choose items from a menu of predefined options.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-select--docs\n * @status stable\n * @since 2.0\n *\n * @dependency koerber-icon\n * @dependency koerber-popup\n * @dependency koerber-tag\n *\n * @slot - The listbox options. Must be `<koerber-select-option>` elements.\n * @slot prefix - Used to prepend a presentational icon or similar element to the combobox.\n * @slot clear-icon - An icon to use in lieu of the default clear icon.\n * @slot expand-icon - The icon to show when the control is expanded and collapsed. Rotates on open and close.\n *\n * @event koerber-change - Emitted when the control's value changes.\n * @event koerber-clear - Emitted when the control's value is cleared.\n * @event koerber-input - Emitted when the control receives input.\n * @event koerber-focus - Emitted when the control gains focus.\n * @event koerber-blur - Emitted when the control loses focus.\n * @event koerber-show - Emitted when the select's menu opens.\n * @event koerber-after-show - Emitted after the select's menu opens and all animations are complete.\n * @event koerber-hide - Emitted when the select's menu closes.\n * @event koerber-after-hide - Emitted after the select's menu closes and all animations are complete.\n *\n * @csspart combobox - The container the wraps the prefix, combobox, clear icon, and expand button.\n * @csspart prefix - The container that wraps the prefix slot.\n * @csspart display-input - The element that displays the selected option's label, an `<input>` element.\n * @csspart listbox - The listbox container where options are slotted.\n * @csspart tags - The container that houses option tags when `multiselect` is used.\n * @csspart tag - The individual tags that represent each multiselect option.\n * @csspart tag__base - The tag's base part.\n * @csspart tag__content - The tag's content part.\n * @csspart tag__remove-button - The tag's remove button.\n * @csspart tag__remove-button__base - The tag's remove button base part.\n * @csspart clear-button - The clear button.\n * @csspart expand-icon - The container that wraps the expand icon.\n * @csspart form-control-error-message - The error's message wrapper.\n */\nclass Select extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.localize = new LocalizeController(this);\n        this.typeToSelectString = '';\n        this.hasFocus = false;\n        this.displayLabel = '';\n        this.selectedOptions = [];\n        this.hasClearIcon = this.shouldShowClearIcon();\n        /** The name of the select, submitted as a name/value pair with form data. */\n        this.name = '';\n        /**\n         * The current value of the select, submitted as a name/value pair with form data. When `multiple` is enabled, the\n         * value will be a space-delimited list of values based on the options selected.\n         */\n        this.value = '';\n        /** The default value of the form control. Primarily used for resetting the form control. */\n        this.defaultValue = '';\n        /** Placeholder text to show as a hint when the select is empty. */\n        this.placeholder = '';\n        /** The select's size. */\n        this.size = 'medium';\n        /** Adds a loader/spinner in the suffix of the select control */\n        this.loading = false;\n        /** Displays loading message when loading flag set to true */\n        this.loadingMessage = 'Disabled while loading';\n        /** Allows more than one option to be selected. */\n        this.multiple = false;\n        /**\n         * Sets the maximum height for the dropdown box before the scrollbar appears.\n         */\n        this.maxHeight = 0;\n        /**\n         * The maximum number of selected options to show when `multiple` is true. After the maximum, \"+n\" will be shown to\n         * indicate the number of additional items that are selected. Set to 0 to remove the limit.\n         */\n        this.maxOptionsVisible = 3;\n        /** Disables the select control. */\n        this.disabled = false;\n        /** Adds a clear button when the select is not empty. */\n        this.clearable = false;\n        /**\n         * Indicates whether or not the select is open. You can toggle this attribute to show and hide the menu, or you can\n         * use the `show()` and `hide()` methods and this attribute will reflect the select's open state.\n         */\n        this.open = false;\n        /**\n         * Enable this option to prevent the listbox from being clipped when the component is placed inside a container with\n         * `overflow: auto|scroll`. Hoisting uses a fixed positioning strategy that works in many, but not all, scenarios.\n         */\n        this.hoist = false;\n        /**\n         * The preferred placement of the select's menu. Note that the actual placement may vary as needed to keep the listbox\n         * inside of the viewport.\n         */\n        this.placement = 'bottom';\n        /** The select's required attribute. */\n        this.required = false;\n        /** Enables search functionality in the select box. */\n        this.allowSearch = false;\n        /**\n         * Used to indicate that the input has some error based on some rule.\n         */\n        this.error = false;\n        this.handleDocumentFocusIn = (event) => {\n            // Close when focusing out of the select\n            const path = event.composedPath();\n            if (this && !path.includes(this)) {\n                this.hide();\n            }\n        };\n        this.handleDocumentKeyDown = (event) => {\n            const target = event.target;\n            const isClearButton = target.closest('.select__clear') !== null;\n            const isIconButton = target.closest('koerber-icon-button') !== null;\n            // Ignore presses when the target is an icon button (e.g. the remove button in <koerber-tag>)\n            if (isClearButton || isIconButton) {\n                return;\n            }\n            // Close when pressing escape\n            if (event.key === 'Escape' && this.open) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.hide();\n                this.displayInput.focus({ preventScroll: true });\n            }\n            // Handle enter and space. When pressing space, we allow for type to select behaviors so if there's anything in the\n            // buffer we _don't_ close it.\n            if (event.key === 'Enter' || (event.key === ' ' && this.typeToSelectString === '')) {\n                event.preventDefault();\n                event.stopImmediatePropagation();\n                // If it's not open, open it\n                if (!this.open) {\n                    this.show();\n                    return;\n                }\n                // If it is open, update the value based on the current selection and close it\n                if (this.currentOption && !this.currentOption.disabled) {\n                    if (this.multiple) {\n                        this.toggleOptionSelection(this.currentOption);\n                    }\n                    else {\n                        this.setSelectedOptions(this.currentOption);\n                    }\n                    this.typeToSelectString = '';\n                    // Emit after updating\n                    this.updateComplete.then(() => {\n                        this.emit('koerber-input');\n                        this.emit('koerber-change');\n                    });\n                    if (!this.multiple) {\n                        this.hide();\n                        this.displayInput.focus({ preventScroll: true });\n                    }\n                }\n                return;\n            }\n            // Navigate options\n            if (['ArrowUp', 'ArrowDown', 'Home', 'End'].includes(event.key)) {\n                const allOptions = this.getAllOptions();\n                const currentIndex = allOptions.indexOf(this.currentOption);\n                let newIndex = Math.max(0, currentIndex);\n                // Prevent scrolling\n                event.preventDefault();\n                // Open it\n                if (!this.open) {\n                    this.show();\n                    // If an option is already selected, stop here because we want that one to remain highlighted when the listbox\n                    // opens for the first time\n                    if (this.currentOption) {\n                        return;\n                    }\n                }\n                if (event.key === 'ArrowDown') {\n                    newIndex = currentIndex + 1;\n                    if (newIndex > allOptions.length - 1)\n                        newIndex = 0;\n                }\n                else if (event.key === 'ArrowUp') {\n                    newIndex = currentIndex - 1;\n                    if (newIndex < 0)\n                        newIndex = allOptions.length - 1;\n                }\n                else if (event.key === 'Home') {\n                    newIndex = 0;\n                }\n                else if (event.key === 'End') {\n                    newIndex = allOptions.length - 1;\n                }\n                this.setCurrentOption(allOptions[newIndex]);\n            }\n            if (this.allowSearch) {\n                // All other \"printable\" keys trigger type to select\n                if (event.key.length === 1 || event.key === 'Backspace') {\n                    const allOptions = this.getAllOptions();\n                    // Don't block important key combos like CMD+R\n                    if (event.metaKey || event.ctrlKey || event.altKey) {\n                        return;\n                    }\n                    // Open, unless the key that triggered is backspace\n                    if (!this.open) {\n                        if (event.key === 'Backspace') {\n                            return;\n                        }\n                        this.show();\n                    }\n                    event.stopPropagation();\n                    event.preventDefault();\n                    clearTimeout(this.typeToSelectTimeout);\n                    this.typeToSelectTimeout = window.setTimeout(() => (this.typeToSelectString = ''), 10000);\n                    if (event.key === 'Backspace') {\n                        this.typeToSelectString = this.typeToSelectString.slice(0, -1);\n                    }\n                    else {\n                        // Use the shift key to check for uppercase\n                        const isShiftPressed = event.shiftKey;\n                        const charToAdd = isShiftPressed ? event.key : event.key.toLowerCase();\n                        this.typeToSelectString += charToAdd;\n                    }\n                    // Update the value of the displayInput to show the characters being typed\n                    this.displayInput.value = this.typeToSelectString;\n                    this.displayInput.focus({ preventScroll: true });\n                    this.setCurrentOption(this.currentOption);\n                    this.hasClearIcon = this.shouldShowClearIcon();\n                    if (this.currentOption) {\n                        scrollIntoView(this.currentOption, this.listbox, 'vertical', 'auto');\n                    }\n                    this.emit('koerber-input');\n                    this.emit('koerber-change');\n                    for (const option of allOptions) {\n                        const label = option.getTextLabel().toLowerCase();\n                        if (label.startsWith(this.typeToSelectString.toLowerCase())) {\n                            this.setCurrentOption(option);\n                            break;\n                        }\n                    }\n                }\n            }\n        };\n        this.handleDocumentMouseDown = (event) => {\n            // Close when clicking outside of the select\n            const path = event.composedPath();\n            if (this && !path.includes(this)) {\n                this.hide();\n            }\n        };\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        // Because this is a form control, it shouldn't be opened initially\n        this.open = false;\n    }\n    addOpenListeners() {\n        document.addEventListener('focusin', this.handleDocumentFocusIn);\n        document.addEventListener('keydown', this.handleDocumentKeyDown);\n        document.addEventListener('mousedown', this.handleDocumentMouseDown);\n    }\n    removeOpenListeners() {\n        document.removeEventListener('focusin', this.handleDocumentFocusIn);\n        document.removeEventListener('keydown', this.handleDocumentKeyDown);\n        document.removeEventListener('mousedown', this.handleDocumentMouseDown);\n    }\n    handleFocus() {\n        this.hasFocus = true;\n        this.displayInput.setSelectionRange(0, 0);\n        this.emit('koerber-focus');\n    }\n    handleBlur() {\n        this.hasFocus = false;\n        this.emit('koerber-blur');\n    }\n    shouldShowClearIcon() {\n        return (this.isSearchable() || this.isClearable()) && !this.isDisabled();\n    }\n    isSearchable() {\n        return this.allowSearch && this.typeToSelectString !== '' && !this.multiple;\n    }\n    isClearable() {\n        return this.clearable && this.value.length > 0;\n    }\n    isDisabled() {\n        return this.disabled;\n    }\n    handleComboboxMouseDown(event) {\n        const path = event.composedPath();\n        const isIconButton = path.some(el => el instanceof Element && el.tagName.toLowerCase() === 'koerber-icon-button');\n        // Ignore disabled controls and clicks on tags (remove buttons)\n        if (this.disabled || isIconButton) {\n            return;\n        }\n        event.preventDefault();\n        this.open = !this.open;\n    }\n    handleComboboxKeyDown(event) {\n        event.stopPropagation();\n        this.handleDocumentKeyDown(event);\n    }\n    handleClearClick(event) {\n        event.stopPropagation();\n        this.typeToSelectString = '';\n        this.displayInput.value = this.typeToSelectString;\n        if (this.value !== '') {\n            this.setSelectedOptions([]);\n            this.displayInput.focus({ preventScroll: true });\n            // Emit after update\n            this.updateComplete.then(() => {\n                this.emit('koerber-clear');\n                this.emit('koerber-input');\n                this.emit('koerber-change');\n            });\n        }\n        this.hasClearIcon = false;\n    }\n    handleClearMouseDown(event) {\n        // Don't lose focus or propagate events when clicking the clear button\n        event.stopPropagation();\n        event.preventDefault();\n    }\n    handleOptionClick(event) {\n        const target = event.target;\n        const option = target.closest('koerber-select-option');\n        // Check if the click event was on the koerber-select-option > checkbox\n        const isCheckbox = event\n            .composedPath()\n            .some((el) => { var _a; return (_a = el === null || el === void 0 ? void 0 : el.classList) === null || _a === void 0 ? void 0 : _a.contains('select-option__checkbox'); });\n        const oldValue = this.value;\n        if (option && !option.disabled) {\n            if (this.multiple) {\n                // If its clicked we only need to update the selected values\n                if (isCheckbox) {\n                    option.addEventListener('koerber-change', () => this.selectionChanged());\n                }\n                else {\n                    this.toggleOptionSelection(option);\n                }\n            }\n            else {\n                this.setSelectedOptions(option);\n            }\n            this.typeToSelectString = '';\n            // Set focus after updating so the value is announced by screen readers\n            this.updateComplete.then(() => this.displayInput.focus({ preventScroll: true }));\n            if (this.value !== oldValue) {\n                // Emit after updating\n                this.updateComplete.then(() => {\n                    this.emit('koerber-input');\n                    this.emit('koerber-change');\n                });\n            }\n            if (!this.multiple) {\n                this.hide();\n                this.displayInput.focus({ preventScroll: true });\n            }\n        }\n    }\n    handleDefaultSlotChange() {\n        const allOptions = this.getAllOptions();\n        const value = Array.isArray(this.value) ? this.value : [this.value];\n        const values = [];\n        // Check for duplicate values in menu items\n        if (customElements.get('koerber-select-option')) {\n            allOptions.forEach(option => values.push(option.value));\n            // Select only the options that match the new value\n            this.setSelectedOptions(allOptions.filter(el => value.includes(el.value)));\n        }\n        else {\n            // Rerun this handler when <koerber-select-option> is registered\n            customElements.whenDefined('koerber-select-option').then(() => this.handleDefaultSlotChange());\n        }\n    }\n    handleTagRemove(event, option) {\n        event.stopPropagation();\n        if (!this.disabled) {\n            this.toggleOptionSelection(option, false);\n            // Emit after updating\n            this.updateComplete.then(() => {\n                this.emit('koerber-input');\n                this.emit('koerber-change');\n            });\n        }\n    }\n    // Gets an array of all <koerber-select-option> elements\n    getAllOptions() {\n        return [...this.querySelectorAll('koerber-select-option')];\n    }\n    // Gets the first <koerber-select-option> element\n    getFirstOption() {\n        return this.querySelector('koerber-select-option');\n    }\n    // Sets the current option, which is the option the user is currently interacting with (e.g. via keyboard). Only one\n    // option may be \"current\" at a time.\n    setCurrentOption(option) {\n        const allOptions = this.getAllOptions();\n        // Clear selection\n        allOptions.forEach(el => {\n            el.current = false;\n            el.tabIndex = -1;\n        });\n        // Select the target option\n        if (option) {\n            this.currentOption = option;\n            option.current = true;\n            option.tabIndex = 0;\n        }\n    }\n    // Sets the selected option(s)\n    setSelectedOptions(option) {\n        const allOptions = this.getAllOptions();\n        const newSelectedOptions = Array.isArray(option) ? option : [option];\n        // Clear existing selection\n        allOptions.forEach(el => (el.selected = false));\n        // Set the new selection\n        if (newSelectedOptions.length) {\n            newSelectedOptions.forEach(el => (el.selected = true));\n        }\n        // Update selection, value, and display label\n        this.selectionChanged();\n    }\n    // Toggles an option's selected state\n    toggleOptionSelection(option, force) {\n        if (force === true || force === false) {\n            option.selected = force;\n        }\n        else {\n            option.selected = !option.selected;\n        }\n        this.selectionChanged();\n    }\n    // This method must be called whenever the selection changes. It will update the selected options cache, the current\n    // value, and the display value\n    selectionChanged() {\n        var _a, _b, _c, _d;\n        // Update selected options cache\n        this.selectedOptions = this.getAllOptions().filter(el => el.selected);\n        // Update the value and display label\n        if (this.multiple) {\n            this.value = this.selectedOptions.map(el => el.value);\n            if (this.placeholder && this.value.length === 0) {\n                // When no items are selected, keep the value empty so the placeholder shows\n                this.displayLabel = '';\n            }\n            else {\n                this.displayLabel = this.localize.term('numOptionsSelected', this.selectedOptions.length);\n            }\n        }\n        else {\n            this.value = (_b = (_a = this.selectedOptions[0]) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : '';\n            this.displayLabel = (_d = (_c = this.selectedOptions[0]) === null || _c === void 0 ? void 0 : _c.getTextLabel()) !== null && _d !== void 0 ? _d : '';\n        }\n    }\n    async syncOptions() {\n        const options = this.getAllOptions();\n        await Promise.all(\n        // Sync the checked state and size\n        options.map(async (option) => {\n            await option.updateComplete;\n            option.size = this.size;\n        }));\n    }\n    handleSizeChange() {\n        this.syncOptions();\n    }\n    handleDisabledChange() {\n        // Close the listbox when the control is disabled\n        if (this.disabled) {\n            this.open = false;\n            this.handleOpenChange();\n        }\n    }\n    handleValueChange() {\n        const allOptions = this.getAllOptions();\n        const value = Array.isArray(this.value) ? this.value : [this.value];\n        // Select only the options that match the new value\n        this.setSelectedOptions(allOptions.filter(el => value.includes(el.value)));\n        this.hasClearIcon = this.shouldShowClearIcon();\n    }\n    async handleOpenChange() {\n        if (this.open && !this.disabled && !this.loading) {\n            // Set the maximum height of the dropdown box\n            if (this.maxHeight > 0) {\n                this.listbox.style.setProperty('max-height', `${this.maxHeight}px`);\n            }\n            this.handleSizeChange();\n            // Reset the current option\n            this.setCurrentOption(this.selectedOptions[0] || this.getFirstOption());\n            // Show\n            this.emit('koerber-show');\n            this.addOpenListeners();\n            await stopAnimations(this);\n            this.listbox.hidden = false;\n            this.popup.active = true;\n            // Select the appropriate option based on value after the listbox opens\n            requestAnimationFrame(() => {\n                this.setCurrentOption(this.currentOption);\n            });\n            const { keyframes, options } = getAnimation(this, 'select.show', { dir: this.localize.dir() });\n            await animateTo(this.popup.popup, keyframes, options);\n            // Make sure the current option is scrolled into view (required for Safari)\n            if (this.currentOption) {\n                scrollIntoView(this.currentOption, this.listbox, 'vertical', 'auto');\n            }\n            this.emit('koerber-after-show');\n            this.displayInput.focus({ preventScroll: true });\n        }\n        else {\n            // Hide\n            this.emit('koerber-hide');\n            this.removeOpenListeners();\n            await stopAnimations(this);\n            const { keyframes, options } = getAnimation(this, 'select.hide', { dir: this.localize.dir() });\n            await animateTo(this.popup.popup, keyframes, options);\n            this.listbox.hidden = true;\n            this.popup.active = false;\n            this.emit('koerber-after-hide');\n        }\n    }\n    /** Shows the listbox. */\n    async show() {\n        if (this.open || this.disabled || this.loading) {\n            this.open = false;\n            return undefined;\n        }\n        this.open = true;\n        return waitForEvent(this, 'koerber-after-show');\n    }\n    /** Hides the listbox. */\n    async hide() {\n        if (!this.open || this.disabled || this.loading) {\n            this.open = false;\n            return undefined;\n        }\n        this.open = false;\n        return waitForEvent(this, 'koerber-after-hide');\n    }\n    /** Sets focus on the control. */\n    focus(options) {\n        this.displayInput.focus(options);\n    }\n    /** Removes focus from the control. */\n    blur() {\n        this.displayInput.blur();\n    }\n    render() {\n        const isPlaceholderVisible = this.placeholder && this.value.length === 0;\n        const hasError = this.error;\n        return html `\r\n      <div\r\n        part=\"form-control\"\r\n        class=${classMap({\n            'form-control': true,\n            'form-control--small': this.size === 'small',\n            'form-control--medium': this.size === 'medium',\n            'form-control--large': this.size === 'large',\n            'form-control__label--disabled': this.disabled\n        })}\r\n      >\r\n        <div part=\"form-control-input\" class=\"form-control-input\">\r\n          <koerber-popup\r\n            class=${classMap({\n            select: true,\n            'select--standard': true,\n            'select--open': this.open && !this.loading,\n            'select--disabled': this.disabled,\n            'select--multiple': this.multiple,\n            'select--focused': this.hasFocus,\n            'select--placeholder-visible': isPlaceholderVisible,\n            'select--top': this.placement === 'top',\n            'select--bottom': this.placement === 'bottom',\n            'select--small': this.size === 'small',\n            'select--medium': this.size === 'medium',\n            'select--large': this.size === 'large',\n            'select--loading': this.loading,\n            'select--error': hasError\n        })}\r\n            placement=${this.placement}\r\n            strategy=${this.hoist ? 'fixed' : 'absolute'}\r\n            flip\r\n            shift\r\n            sync=\"width\"\r\n            auto-size=\"vertical\"\r\n            auto-size-padding=\"10\"\r\n          >\r\n            <div\r\n              part=\"combobox\"\r\n              class=\"select__combobox\"\r\n              slot=\"anchor\"\r\n              @keydown=${this.handleComboboxKeyDown}\r\n              @mousedown=${this.handleComboboxMouseDown}\r\n            >\r\n              <slot part=\"prefix\" name=\"prefix\" class=\"select__prefix\"></slot>\r\n\r\n              <input\r\n                part=\"display-input\"\r\n                class=${classMap({\n            'select__display-input': true,\n            'select--small': this.size === 'small',\n            'select--medium': this.size === 'medium',\n            'select--large': this.size === 'large',\n            'select--allowSearch': this.allowSearch\n        })}\r\n                type=\"text\"\r\n                placeholder=${this.placeholder}\r\n                .disabled=${this.disabled || this.loading}\r\n                .value=${this.displayLabel}\r\n                autocomplete=\"off\"\r\n                spellcheck=\"false\"\r\n                autocapitalize=\"off\"\r\n                ?readonly=${!this.allowSearch}\r\n                aria-label=${ifDefined(this.accessibleName)}\r\n                aria-description=${ifDefined(this.accessibleDescription)}\r\n                aria-controls=\"listbox\"\r\n                aria-expanded=${this.open ? 'true' : 'false'}\r\n                aria-haspopup=\"listbox\"\r\n                aria-labelledby=\"label\"\r\n                aria-disabled=${this.disabled || this.loading}\r\n                role=\"combobox\"\r\n                tabindex=\"0\"\r\n                @focus=${this.handleFocus}\r\n                @blur=${this.handleBlur}\r\n              />\r\n\r\n              ${this.multiple\n            ? html `\r\n                    <div part=\"tags\" class=\"select__tags\">\r\n                      ${this.selectedOptions.map((option, index) => {\n                if (index < this.maxOptionsVisible || this.maxOptionsVisible <= 0) {\n                    return html `\r\n                            <koerber-tag\r\n                              part=\"tag\"\r\n                              exportparts=\"\r\n                                base:tag__base,\r\n                                content:tag__content,\r\n                                remove-button:tag__remove-button,\r\n                                remove-button__base:tag__remove-button__base\r\n                              \"\r\n                              size=${this.size}\r\n                              pill=\"true\"\r\n                              removable\r\n                              @koerber-remove=${(event) => this.handleTagRemove(event, option)}\r\n                            >\r\n                              ${option.getTextLabel()}\r\n                            </koerber-tag>\r\n                          `;\n                }\n                else if (index === this.maxOptionsVisible) {\n                    return html `\r\n                            <koerber-tag size=${this.size}> +${this.selectedOptions.length - index} </koerber-tag>\r\n                          `;\n                }\n                else {\n                    return null;\n                }\n            })}\r\n                    </div>\r\n                  `\n            : ''}\r\n\r\n              <input\r\n                class=\"select__value-input\"\r\n                type=\"text\"\r\n                ?disabled=${this.disabled || this.loading}\r\n                ?required=${this.required}\r\n                .value=${Array.isArray(this.value) ? this.value.join(', ') : this.value}\r\n                tabindex=\"-1\"\r\n                aria-hidden=\"true\"\r\n                @focus=${() => this.focus()}\r\n              />\r\n\r\n              ${this.loading && !this.error\n            ? html `\r\n                    <koerber-tooltip hoist content=${this.loadingMessage}>\r\n                      <div>\r\n                        <koerber-spinner></koerber-spinner>\r\n                      </div>\r\n                    </koerber-tooltip>\r\n                  `\n            : ''}\r\n              ${this.hasClearIcon\n            ? html `\r\n                    <button\r\n                      part=\"clear-button\"\r\n                      class=\"select__clear\"\r\n                      type=\"button\"\r\n                      aria-label=${this.localize.term('clearEntry')}\r\n                      @mousedown=${this.handleClearMouseDown}\r\n                      @click=${this.handleClearClick}\r\n                      tabindex=\"-1\"\r\n                    >\r\n                      <slot name=\"clear-icon\">\r\n                        <koerber-icon name=\"close\" library=\"system\"></koerber-icon>\r\n                      </slot>\r\n                    </button>\r\n                  `\n            : ''}\r\n              ${hasError\n            ? html `\r\n                    <div class=\"select-error-icon-slot\">\r\n                      <koerber-icon class=\"select-error-icon\" name=\"alert\"></koerber-icon>\r\n                    </div>\r\n                  `\n            : ''}\r\n\r\n              <slot name=\"expand-icon\" part=\"expand-icon\" class=\"select__expand-icon\">\r\n                <koerber-icon library=\"system\" name=\"chevron-down\"></koerber-icon>\r\n              </slot>\r\n            </div>\r\n\r\n            <div\r\n              id=\"listbox\"\r\n              role=\"listbox\"\r\n              aria-expanded=${this.open ? 'true' : 'false'}\r\n              aria-multiselectable=${this.multiple ? 'true' : 'false'}\r\n              part=\"listbox\"\r\n              class=\"select__listbox\"\r\n              tabindex=\"-1\"\r\n              @mouseup=${this.handleOptionClick}\r\n              @slotchange=${this.handleDefaultSlotChange}\r\n            >\r\n              <slot></slot>\r\n            </div>\r\n          </koerber-popup>\r\n        </div>\r\n        ${this.loadingErrorMessage\n            ? html `\r\n              <slot\r\n                name=\"error-message\"\r\n                part=\"form-control-error-message\"\r\n                id=\"error-message\"\r\n                class=\"form-control__error-message\"\r\n                aria-hidden=${this.loadingErrorMessage ? 'false' : 'true'}\r\n              >\r\n                ${this.loadingErrorMessage}\r\n              </slot>\r\n            `\n            : ''}\r\n      </div>\r\n    `;\n    }\n}\nSelect.styles = [componentStyles, formControlStyles, styles];\nSelect.dependencies = {\n    'koerber-icon': Icon,\n    'koerber-popup': Popup,\n    'koerber-tag': Tag,\n    'koerber-spinner': Spinner\n};\nexport default Select;\n__decorate([\n    query('.select')\n], Select.prototype, \"popup\", void 0);\n__decorate([\n    query('.select__combobox')\n], Select.prototype, \"combobox\", void 0);\n__decorate([\n    query('.select__display-input')\n], Select.prototype, \"displayInput\", void 0);\n__decorate([\n    query('.select__value-input')\n], Select.prototype, \"valueInput\", void 0);\n__decorate([\n    query('.select__listbox')\n], Select.prototype, \"listbox\", void 0);\n__decorate([\n    state()\n], Select.prototype, \"hasFocus\", void 0);\n__decorate([\n    state()\n], Select.prototype, \"displayLabel\", void 0);\n__decorate([\n    state()\n], Select.prototype, \"currentOption\", void 0);\n__decorate([\n    state()\n], Select.prototype, \"selectedOptions\", void 0);\n__decorate([\n    state()\n], Select.prototype, \"hasClearIcon\", void 0);\n__decorate([\n    property()\n], Select.prototype, \"name\", void 0);\n__decorate([\n    property({\n        converter: {\n            fromAttribute: (value) => value.split(' '),\n            toAttribute: (value) => value.join(' ')\n        }\n    })\n], Select.prototype, \"value\", void 0);\n__decorate([\n    defaultValue()\n], Select.prototype, \"defaultValue\", void 0);\n__decorate([\n    property()\n], Select.prototype, \"placeholder\", void 0);\n__decorate([\n    property({ reflect: true })\n], Select.prototype, \"size\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Select.prototype, \"loading\", void 0);\n__decorate([\n    property({ type: String })\n], Select.prototype, \"loadingMessage\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Select.prototype, \"multiple\", void 0);\n__decorate([\n    property({ attribute: 'max-height', type: Number })\n], Select.prototype, \"maxHeight\", void 0);\n__decorate([\n    property({ attribute: 'max-options-visible', type: Number })\n], Select.prototype, \"maxOptionsVisible\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Select.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Select.prototype, \"clearable\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Select.prototype, \"open\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Select.prototype, \"hoist\", void 0);\n__decorate([\n    property({ reflect: true })\n], Select.prototype, \"placement\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Select.prototype, \"required\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Select.prototype, \"allowSearch\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Select.prototype, \"error\", void 0);\n__decorate([\n    property({ attribute: 'loading-error-message' })\n], Select.prototype, \"loadingErrorMessage\", void 0);\n__decorate([\n    property({ attribute: 'accessible-name', reflect: true })\n], Select.prototype, \"accessibleName\", void 0);\n__decorate([\n    property({ attribute: 'accessible-description', reflect: true })\n], Select.prototype, \"accessibleDescription\", void 0);\n__decorate([\n    watch('disabled', { waitUntilFirstUpdate: true })\n], Select.prototype, \"handleDisabledChange\", null);\n__decorate([\n    watch('value', { waitUntilFirstUpdate: true })\n], Select.prototype, \"handleValueChange\", null);\n__decorate([\n    watch('open', { waitUntilFirstUpdate: true })\n], Select.prototype, \"handleOpenChange\", null);\nsetDefaultAnimation('select.show', {\n    keyframes: [\n        { opacity: 0, scale: 0.9 },\n        { opacity: 1, scale: 1 }\n    ],\n    options: { duration: 100, easing: 'ease' }\n});\nsetDefaultAnimation('select.hide', {\n    keyframes: [\n        { opacity: 1, scale: 1 },\n        { opacity: 0, scale: 0.9 }\n    ],\n    options: { duration: 100, easing: 'ease' }\n});\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { classMap } from 'lit/directives/class-map.js';\nimport { html } from 'lit';\nimport { LocalizeController } from '../../utilities/localize';\nimport { property } from 'lit/decorators.js';\nimport componentStyles from '../../styles/component.styles';\nimport IconButton from '../icon-button/icon-button.component';\nimport styles from './tag.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Tags are used as labels to organize things or to indicate a selection.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net\n * @status stable\n * @since 2.0\n *\n * @dependency koerber-icon-button\n *\n * @slot - The tag's content.\n *\n * @event koerber-remove - Emitted when the remove button is activated.\n *\n * @csspart base - The component's base wrapper.\n * @csspart content - The tag's content.\n * @csspart remove-button - The tag's remove button, an `<koerber-icon-button>`.\n * @csspart remove-button__base - The remove button's exported `base` part.\n */\n// INTERNAL ONLY\nclass Tag extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.localize = new LocalizeController(this);\n        /** The tag's size. */\n        this.size = 'medium';\n        /** Draws a pill-style tag with rounded edges. */\n        this.pill = false;\n        /** Makes the tag removable and shows a remove button. */\n        this.removable = false;\n    }\n    handleRemoveClick() {\n        this.emit('koerber-remove');\n    }\n    render() {\n        return html `\n      <span\n        part=\"base\"\n        class=${classMap({\n            tag: true,\n            // Sizes\n            'tag--small': this.size === 'small',\n            'tag--medium': this.size === 'medium',\n            'tag--large': this.size === 'large',\n            // Modifiers\n            'tag--pill': this.pill,\n            'tag--removable': this.removable\n        })}\n      >\n        <slot part=\"content\" class=\"tag__content\"></slot>\n\n        ${this.removable\n            ? html `\n              <koerber-icon-button\n                part=\"remove-button\"\n                exportparts=\"base:remove-button__base\"\n                name=\"close\"\n                library=\"system\"\n                label=${this.localize.term('remove')}\n                class=\"tag__remove\"\n                @click=${this.handleRemoveClick}\n                tabindex=\"-1\"\n              ></koerber-icon-button>\n            `\n            : ''}\n      </span>\n    `;\n    }\n}\nTag.styles = [componentStyles, styles];\nTag.dependencies = {\n    'koerber-icon-button': IconButton\n};\nexport default Tag;\n__decorate([\n    property({ reflect: true })\n], Tag.prototype, \"size\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Tag.prototype, \"pill\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Tag.prototype, \"removable\", void 0);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/** Exception due eslint doesn't support WAI-ARIA 1.3 that supports aria-description attr */\n/* eslint-disable lit-a11y/aria-attrs */\nimport { classMap } from 'lit/directives/class-map.js';\nimport { defaultValue } from '../../internal/default-value';\nimport { html } from 'lit';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { live } from 'lit/directives/live.js';\nimport { property, query, state } from 'lit/decorators.js';\nimport { watch } from '../../internal/watch';\nimport componentStyles from '../../styles/component.styles';\nimport styles from './toggle.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary toggles allow the user to toggle an option on or off.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net\n * @status stable\n * @since 2.0\n *\n * @slot - The toggle's label.\n *\n * @event koerber-blur - Emitted when the control loses focus.\n * @event koerber-change - Emitted when the control's checked state changes.\n * @event koerber-input - Emitted when the control receives input.\n * @event koerber-focus - Emitted when the control gains focus.\n *\n * @csspart base - The component's base wrapper.\n * @csspart control - The control that houses the toggle's thumb.\n * @csspart thumb - The toggle's thumb.\n * @csspart label - The toggle's label.\n *\n * @cssproperty --width - The width of the toggle.\n * @cssproperty --height - The height of the toggle.\n * @cssproperty --thumb-size - The size of the thumb.\n */\nclass Toggle extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.hasFocus = false;\n        this.title = ''; // make reactive to pass through\n        /** The name of the toggle, submitted as a name/value pair with form data. */\n        this.name = '';\n        /** The toggle's size. */\n        this.size = 'standard';\n        /** Disables the toggle. */\n        this.disabled = false;\n        /** Draws the toggle in a checked state. */\n        this.checked = false;\n        /** The default value of the form control. Primarily used for resetting the form control. */\n        this.defaultChecked = false;\n        /** Makes the toggle a required field. */\n        this.required = false;\n        /** Indicates the form control is in an error state. */\n        this.error = false;\n    }\n    handleBlur() {\n        this.hasFocus = false;\n        this.emit('koerber-blur');\n    }\n    handleInput() {\n        this.emit('koerber-input');\n    }\n    handleClick() {\n        this.checked = !this.checked;\n        this.emit('koerber-change');\n    }\n    handleFocus() {\n        this.hasFocus = true;\n        this.emit('koerber-focus');\n    }\n    handleKeyDown(event) {\n        if (event.key === 'ArrowLeft') {\n            event.preventDefault();\n            this.checked = false;\n            this.emit('koerber-change');\n            this.emit('koerber-input');\n        }\n        if (event.key === 'ArrowRight') {\n            event.preventDefault();\n            this.checked = true;\n            this.emit('koerber-change');\n            this.emit('koerber-input');\n        }\n    }\n    handleCheckedChange() {\n        this.input.checked = this.checked; // force a sync update\n    }\n    /** Simulates a click on the toggle. */\n    click() {\n        this.input.click();\n    }\n    /** Sets focus on the toggle. */\n    focus(options) {\n        this.input.focus(options);\n    }\n    /** Removes focus from the toggle. */\n    blur() {\n        this.input.blur();\n    }\n    render() {\n        return html `\r\n      <label\r\n        part=\"base\"\r\n        class=${classMap({\n            toggle: true,\n            'toggle--checked': this.checked,\n            'toggle--disabled': this.disabled,\n            'toggle--focused': this.hasFocus,\n            'toggle--standard': this.size === 'standard',\n            'toggle--comfortable': this.size === 'comfortable',\n            'toggle--error': this.error\n        })}\r\n      >\r\n        <input\r\n          class=\"toggle__input\"\r\n          type=\"checkbox\"\r\n          title=${this.title /* An empty title prevents browser validation tooltips from appearing on hover */}\r\n          name=${this.name}\r\n          value=${ifDefined(this.value)}\r\n          .checked=${live(this.checked)}\r\n          .disabled=${this.disabled}\r\n          .required=${this.required}\r\n          role=\"switch\"\r\n          aria-checked=${this.checked ? 'true' : 'false'}\r\n          aria-label=${ifDefined(this.accessibleName)}\r\n          aria-description=${ifDefined(this.accessibleDescription)}\r\n          @click=${this.handleClick}\r\n          @input=${this.handleInput}\r\n          @blur=${this.handleBlur}\r\n          @focus=${this.handleFocus}\r\n          @keydown=${this.handleKeyDown}\r\n        />\r\n\r\n        <span part=\"control\" class=\"toggle__control\">\r\n          <span part=\"thumb\" class=\"toggle__thumb\"></span>\r\n        </span>\r\n\r\n        <slot part=\"label\" class=\"toggle__label\">\r\n          <koerber-form-field-label label=\"${this.label}\"></koerber-form-field-label>\r\n        </slot>\r\n      </label>\r\n    `;\n    }\n}\nToggle.styles = [componentStyles, styles];\nexport default Toggle;\n__decorate([\n    query('input[type=\"checkbox\"]')\n], Toggle.prototype, \"input\", void 0);\n__decorate([\n    state()\n], Toggle.prototype, \"hasFocus\", void 0);\n__decorate([\n    property()\n], Toggle.prototype, \"title\", void 0);\n__decorate([\n    property()\n], Toggle.prototype, \"name\", void 0);\n__decorate([\n    property()\n], Toggle.prototype, \"value\", void 0);\n__decorate([\n    property()\n], Toggle.prototype, \"label\", void 0);\n__decorate([\n    property({ reflect: true })\n], Toggle.prototype, \"size\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Toggle.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Toggle.prototype, \"checked\", void 0);\n__decorate([\n    defaultValue('checked')\n], Toggle.prototype, \"defaultChecked\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Toggle.prototype, \"required\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Toggle.prototype, \"error\", void 0);\n__decorate([\n    property({ attribute: 'accessible-name', reflect: true })\n], Toggle.prototype, \"accessibleName\", void 0);\n__decorate([\n    property({ attribute: 'accessible-description', reflect: true })\n], Toggle.prototype, \"accessibleDescription\", void 0);\n__decorate([\n    watch('checked', { waitUntilFirstUpdate: true })\n], Toggle.prototype, \"handleCheckedChange\", null);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { animateTo, shimKeyframesHeightAuto, stopAnimations } from '../../internal/animate';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { getAnimation, setDefaultAnimation } from '../../utilities/animation-registry';\nimport { html } from 'lit';\nimport { live } from 'lit/directives/live.js';\nimport { LocalizeController } from '../../utilities/localize';\nimport { property, query, state } from 'lit/decorators.js';\nimport { watch } from '../../internal/watch';\nimport { when } from 'lit/directives/when.js';\nimport Checkbox from '../checkbox/checkbox.component';\nimport componentStyles from '../../styles/component.styles';\nimport Icon from '../icon/icon.component';\nimport Spinner from '../spinner/spinner.component';\nimport styles from './tree-item.styles';\nimport Tooltip from '../tooltip/tooltip.component';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary A tree item serves as a hierarchical node that lives inside a [tree](/components/tree).\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-tree-item--docs\n * @status stable\n * @since 2.0\n *\n * @dependency koerber-checkbox\n * @dependency koerber-icon\n * @dependency koerber-spinner\n *\n * @event koerber-expand - Emitted when the tree item expands.\n * @event koerber-after-expand - Emitted after the tree item expands and all animations are complete.\n * @event koerber-collapse - Emitted when the tree item collapses.\n * @event koerber-after-collapse - Emitted after the tree item collapses and all animations are complete.\n * @event koerber-lazy-change - Emitted when the tree item's lazy state changes.\n * @event koerber-lazy-load - Emitted when a lazy item is selected. Use this event to asynchronously load data and append\n *  items to the tree before expanding. After appending new items, remove the `lazy` attribute to remove the loading\n *  state and update the tree.\n *\n * @slot - The default slot.\n * @slot expand-icon - The icon to show when the tree item is expanded.\n * @slot collapse-icon - The icon to show when the tree item is collapsed.\n * @slot actions - The action buttons in the tree item.\n * @slot support - The icon to show the supporting visuals in the tree item.\n * @slot hint - The hint text in the tree item content.\n *\n *\n * @csspart base - The component's base wrapper.\n * @csspart item - The tree item's container. This element wraps everything except slotted tree item children.\n * @csspart item--disabled - Applied when the tree item is disabled.\n * @csspart item--open - Applied when the tree item is open.\n * @csspart item--indeterminate - Applied when the selection is indeterminate.\n * @csspart item--selected - Applied when the tree item is selected.\n * @csspart indentation - The tree item's indentation container.\n * @csspart expand-button - The container that wraps the tree item's expand button and spinner.\n * @csspart label - The tree item's label.\n * @csspart children - The container that wraps the tree item's nested children.\n * @csspart checkbox - The checkbox that shows when using multiselect.\n * @csspart checkbox__base - The checkbox's exported `base` part.\n * @csspart checkbox__control - The checkbox's exported `control` part.\n * @csspart checkbox__control--checked - The checkbox's exported `control--checked` part.\n * @csspart checkbox__control--indeterminate - The checkbox's exported `control--indeterminate` part.\n * @csspart checkbox__checked-icon - The checkbox's exported `checked-icon` part.\n * @csspart checkbox__indeterminate-icon - The checkbox's exported `indeterminate-icon` part.\n * @csspart checkbox__label - The checkbox's exported `label` part.\n */\nclass TreeItem extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.localize = new LocalizeController(this);\n        this.tooltipContent = '';\n        /* Checks if text is overflowing */\n        this.isTextOverflowing = false;\n        this.indeterminate = false;\n        this.isLeaf = false;\n        this.loading = false;\n        this.selectable = false;\n        /** Expands the tree item. */\n        this.open = false;\n        /** Draws the tree item in a selected state. */\n        this.selected = false;\n        /** Disables the tree item. */\n        this.disabled = false;\n        /** Enables lazy loading behavior. */\n        this.lazy = false;\n        /** Set the current size of the tree item */\n        this.size = 'medium';\n        /** Gets all the nested tree items in this node. */\n        this.getChildrenItems = ({ includeDisabled = true } = {}) => {\n            return this.childrenSlot\n                ? [...this.childrenSlot.assignedElements({ flatten: true })].filter((item) => TreeItem.isTreeItem(item) && (includeDisabled || !item.disabled))\n                : [];\n        };\n    }\n    static isTreeItem(node) {\n        return node instanceof Element && node.getAttribute('role') === 'treeitem';\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.setAttribute('role', 'treeitem');\n        this.setAttribute('tabindex', '-1');\n        if (this.isNestedItem()) {\n            this.slot = 'children';\n        }\n        this.resizeObserver = new ResizeObserver(() => this.checkTextOverflow());\n        this.updateComplete.then(() => {\n            this.resizeObserver.observe(this.labelContentSlot);\n        });\n    }\n    firstUpdated() {\n        this.childrenContainer.hidden = !this.open;\n        this.childrenContainer.style.height = this.open ? 'auto' : '0';\n        this.isLeaf = !this.lazy && this.getChildrenItems().length === 0;\n        this.handleOpenChange();\n        this.checkTextOverflow();\n    }\n    updated(_changedProperties) {\n        if (_changedProperties.has('isTextOverflowing')) {\n            this.attachOverflowObserver();\n        }\n    }\n    async animateCollapse() {\n        this.emit('koerber-collapse');\n        await stopAnimations(this.childrenContainer);\n        const { keyframes, options } = getAnimation(this, 'tree-item.collapse', { dir: this.localize.dir() });\n        await animateTo(this.childrenContainer, shimKeyframesHeightAuto(keyframes, this.childrenContainer.scrollHeight), options);\n        this.childrenContainer.hidden = true;\n        this.emit('koerber-after-collapse');\n    }\n    // Checks whether the item is nested into an item\n    isNestedItem() {\n        const parent = this.parentElement;\n        return !!parent && TreeItem.isTreeItem(parent);\n    }\n    handleChildrenSlotChange() {\n        this.loading = false;\n        this.isLeaf = !this.lazy && this.getChildrenItems().length === 0;\n    }\n    willUpdate(changedProperties) {\n        if (changedProperties.has('selected') && !changedProperties.has('indeterminate')) {\n            this.indeterminate = false;\n        }\n    }\n    async animateExpand() {\n        this.emit('koerber-expand');\n        await stopAnimations(this.childrenContainer);\n        this.childrenContainer.hidden = false;\n        const { keyframes, options } = getAnimation(this, 'tree-item.expand', { dir: this.localize.dir() });\n        await animateTo(this.childrenContainer, shimKeyframesHeightAuto(keyframes, this.childrenContainer.scrollHeight), options);\n        this.childrenContainer.style.height = 'auto';\n        this.emit('koerber-after-expand');\n    }\n    attachOverflowObserver() {\n        if (this.resizeObserver) {\n            this.resizeObserver.disconnect();\n        }\n        this.resizeObserver = new ResizeObserver(() => this.checkTextOverflow());\n        this.updateComplete.then(() => {\n            this.resizeObserver.observe(this.labelContentSlot);\n        });\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this.resizeObserver.disconnect();\n    }\n    checkTextOverflow() {\n        requestAnimationFrame(() => {\n            if (this.labelContentSlot.scrollHeight > this.labelContentSlot.clientHeight) {\n                this.isTextOverflowing = true;\n                this.tooltipContent = this.getTextContent();\n            }\n            else {\n                this.isTextOverflowing = false;\n                this.tooltipContent = '';\n            }\n        });\n    }\n    getTextContent() {\n        const nodes = this.labelContentSlot.assignedNodes();\n        //avoid have 2 returns use foreach instead and a variable\n        let textContent = '';\n        nodes.forEach(node => {\n            if (node.nodeType === Node.TEXT_NODE) {\n                textContent += node.textContent;\n            }\n        });\n        return textContent;\n    }\n    handleLoadingChange() {\n        this.setAttribute('aria-busy', this.loading ? 'true' : 'false');\n        if (!this.loading) {\n            this.animateExpand();\n        }\n    }\n    handleDisabledChange() {\n        this.setAttribute('aria-disabled', this.disabled ? 'true' : 'false');\n    }\n    handleSelectedChange() {\n        this.setAttribute('aria-selected', this.selected ? 'true' : 'false');\n    }\n    handleOpenChange() {\n        if (!this.isLeaf) {\n            this.setAttribute('aria-expanded', this.open ? 'true' : 'false');\n        }\n        else {\n            this.removeAttribute('aria-expanded');\n        }\n    }\n    handleExpandAnimation() {\n        if (this.open) {\n            if (this.lazy) {\n                this.loading = true;\n                this.emit('koerber-lazy-load');\n            }\n            else {\n                this.animateExpand();\n            }\n        }\n        else {\n            this.animateCollapse();\n        }\n    }\n    handleLazyChange() {\n        this.emit('koerber-lazy-change');\n    }\n    render() {\n        var _a;\n        const isRtl = this.localize.dir() === 'rtl';\n        const showExpandButton = !this.loading && (!this.isLeaf || this.lazy);\n        const treeItemContent = html ` <div\r\n      class=\"tree-item__item\"\r\n      part=\"\r\n          item\r\n          ${this.disabled ? 'item--disabled' : ''}\r\n          ${this.open ? 'item--open' : ''}\r\n          ${this.indeterminate ? 'item--indeterminate' : ''}\r\n          ${this.selected ? 'item--selected' : ''}\r\n        \"\r\n    >\r\n      <div class=\"tree-item__indentation\" part=\"indentation\"></div>\r\n\r\n      <div\r\n        part=\"expand-button\"\r\n        class=${classMap({\n            'tree-item__expand-button': true,\n            'tree-item__expand-button--visible': showExpandButton\n        })}\r\n        aria-hidden=\"true\"\r\n      >\r\n        ${when(this.loading, () => html ` <koerber-spinner></koerber-spinner> `)}\r\n        <slot class=\"tree-item__expand-icon-slot\" name=\"expand-icon\">\r\n          <koerber-icon library=\"system\" name=${isRtl ? 'chevron-left' : 'chevron-up'}></koerber-icon>\r\n        </slot>\r\n        <slot class=\"tree-item__expand-icon-slot\" name=\"collapse-icon\">\r\n          <koerber-icon library=\"system\" name=${isRtl ? 'chevron-left' : 'chevron-up'}></koerber-icon>\r\n        </slot>\r\n      </div>\r\n\r\n      ${when(this.selectable, () => html ` <koerber-checkbox\r\n            part=\"checkbox\"\r\n            exportparts=\"\r\n                  base:checkbox__base,\r\n                  control:checkbox__control,\r\n                  control--checked:checkbox__control--checked,\r\n                  control--indeterminate:checkbox__control--indeterminate,\r\n                  checked-icon:checkbox__checked-icon,\r\n                  indeterminate-icon:checkbox__indeterminate-icon,\r\n                  label:checkbox__label\r\n                \"\r\n            class=\"tree-item__checkbox\"\r\n            title=\"select-checkbox\"\r\n            accessible-name=\"selection box\"\r\n            ?disabled=\"${this.disabled}\"\r\n            ?checked=\"${live(this.selected)}\"\r\n            ?indeterminate=\"${this.indeterminate}\"\r\n          ></koerber-checkbox>`)}\r\n\r\n      <slot class=\"tree-item__support\" part=\"support\" name=\"support\"></slot>\r\n\r\n      <div class=\"tree-item__content\" part=\"content\">\r\n        ${this.isTextOverflowing\n            ? html `<koerber-tooltip\r\n              class=\"tree-item__tooltip\"\r\n              placement=\"top\"\r\n              hoist\r\n              content=\"${(_a = this.tooltipContent) !== null && _a !== void 0 ? _a : ''}\"\r\n            >\r\n              <div><slot class=\"tree-item__label\" part=\"label\"></slot></div>\r\n            </koerber-tooltip>`\n            : html `<slot class=\"tree-item__label\" part=\"label\"></slot>`}\r\n        <slot class=\"tree-item__hint\" part=\"hint\" name=\"hint\"></slot>\r\n      </div>\r\n\r\n      <div class=\"tree-item__actions\" part=\"actions\">\r\n        <slot class=\"tree-item__actions-slot\" name=\"actions\"></slot>\r\n      </div>\r\n    </div>`;\n        return html `\r\n      <div\r\n        part=\"base\"\r\n        class=\"${classMap({\n            'tree-item': true,\n            'tree-item--open': this.open,\n            'tree-item--selected': this.selected,\n            'tree-item--disabled': this.disabled,\n            'tree-item--leaf': this.isLeaf,\n            'tree-item--has-expand-button': showExpandButton,\n            'tree-item--rtl': this.localize.dir() === 'rtl',\n            [`tree-item--size-${this.size}`]: true\n        })}\"\r\n      >\r\n        ${treeItemContent}\r\n\r\n        <div class=\"tree-item__children\" part=\"children\" role=\"group\">\r\n          <slot name=\"children\" @slotchange=\"${this.handleChildrenSlotChange}\"></slot>\r\n        </div>\r\n      </div>\r\n    `;\n    }\n}\nTreeItem.styles = [componentStyles, styles];\nTreeItem.dependencies = {\n    'koerber-checkbox': Checkbox,\n    'koerber-icon': Icon,\n    'koerber-spinner': Spinner,\n    'koerber-tooltip': Tooltip\n};\nexport default TreeItem;\n__decorate([\n    state()\n], TreeItem.prototype, \"isTextOverflowing\", void 0);\n__decorate([\n    state()\n], TreeItem.prototype, \"indeterminate\", void 0);\n__decorate([\n    state()\n], TreeItem.prototype, \"isLeaf\", void 0);\n__decorate([\n    state()\n], TreeItem.prototype, \"loading\", void 0);\n__decorate([\n    state()\n], TreeItem.prototype, \"selectable\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], TreeItem.prototype, \"open\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], TreeItem.prototype, \"selected\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], TreeItem.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], TreeItem.prototype, \"lazy\", void 0);\n__decorate([\n    property({ reflect: true })\n], TreeItem.prototype, \"size\", void 0);\n__decorate([\n    query('slot:not([name])')\n], TreeItem.prototype, \"defaultSlot\", void 0);\n__decorate([\n    query('slot[name=children]')\n], TreeItem.prototype, \"childrenSlot\", void 0);\n__decorate([\n    query('.tree-item__item')\n], TreeItem.prototype, \"itemElement\", void 0);\n__decorate([\n    query('.tree-item__children')\n], TreeItem.prototype, \"childrenContainer\", void 0);\n__decorate([\n    query('.tree-item__expand-button slot')\n], TreeItem.prototype, \"expandButtonSlot\", void 0);\n__decorate([\n    query('.tree-item__label')\n], TreeItem.prototype, \"labelContentSlot\", void 0);\n__decorate([\n    watch('loading', { waitUntilFirstUpdate: true })\n], TreeItem.prototype, \"handleLoadingChange\", null);\n__decorate([\n    watch('disabled')\n], TreeItem.prototype, \"handleDisabledChange\", null);\n__decorate([\n    watch('selected')\n], TreeItem.prototype, \"handleSelectedChange\", null);\n__decorate([\n    watch('open', { waitUntilFirstUpdate: true })\n], TreeItem.prototype, \"handleOpenChange\", null);\n__decorate([\n    watch('open', { waitUntilFirstUpdate: true })\n], TreeItem.prototype, \"handleExpandAnimation\", null);\n__decorate([\n    watch('lazy', { waitUntilFirstUpdate: true })\n], TreeItem.prototype, \"handleLazyChange\", null);\nsetDefaultAnimation('tree-item.expand', {\n    keyframes: [\n        { height: '0', opacity: '0', overflow: 'hidden' },\n        { height: 'auto', opacity: '1', overflow: 'hidden' }\n    ],\n    options: { duration: 250, easing: 'cubic-bezier(0.4, 0.0, 0.2, 1)' }\n});\nsetDefaultAnimation('tree-item.collapse', {\n    keyframes: [\n        { height: 'auto', opacity: '1', overflow: 'hidden' },\n        { height: '0', opacity: '0', overflow: 'hidden' }\n    ],\n    options: { duration: 200, easing: 'cubic-bezier(0.4, 0.0, 0.2, 1)' }\n});\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { animateTo, shimKeyframesHeightAuto, stopAnimations } from '../../internal/animate';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { getAnimation, setDefaultAnimation } from '../../utilities/animation-registry';\nimport { HasSlotController } from '../../internal/slot';\nimport { html } from 'lit';\nimport { LocalizeController } from '../../utilities/localize';\nimport { property, query } from 'lit/decorators.js';\nimport { waitForEvent } from '../../internal/event';\nimport { watch } from '../../internal/watch';\nimport componentStyles from '../../styles/component.styles';\nimport Icon from '../icon/icon.component';\nimport styles from './accordion.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Accordion show a brief summary and expand to show additional content.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-accordion--docs\n * @status stable\n * @since 2.0\n *\n * @dependency koerber-icon\n *\n * @slot - The accordion' main content.\n * @slot expand-icon - Optional expand icon to use instead of the default. Works best with `<koerber-icon>`.\n * @slot collapse-icon - Optional collapse icon to use instead of the default. Works best with `<koerber-icon>`.\n * @slot prefix - Optional left side of the summary - Summary section.\n * @slot suffix - Optional right side of the summary - Summary section.\n * @slot prefix-content - Optional left side of the content - Body section.\n * @slot suffix-content - Optional right side of the content - Body section.\n * @slot summary - The accordion' summary. Alternatively, you can use the `summary` attribute.\n * @slot subtitle - The accordion' subtitle. Alternatively, you can use the `subtitle` attribute.\n *\n * @event koerber-show - Emitted when the accordion opens.\n * @event koerber-after-show - Emitted after the accordion opens and all animations are complete.\n * @event koerber-hide - Emitted when the accordion closes.\n * @event koerber-after-hide - Emitted after the accordion closes and all animations are complete.\n *\n * @csspart base - The component's base wrapper.\n * @csspart header - The header that wraps both the summary and the expand/collapse icon.\n * @csspart summary - The container that wraps the summary.\n * @csspart summary-icon - The container that wraps the expand/collapse icons.\n * @csspart content - The accordion content.\n *\n * @animation accordion.show - The animation to use when showing accordion. You can use `height: auto` with this animation.\n * @animation accordion.hide - The animation to use when hiding accordion. You can use `height: auto` with this animation.\n */\nclass Accordion extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.localize = new LocalizeController(this);\n        this.hasSlotController = new HasSlotController(this, '[default]', 'prefix-content', 'suffix-content');\n        /**\n         * Indicates whether or not the accordion is open. You can toggle this attribute to show and hide the accordion, or you\n         * can use the `show()` and `hide()` methods and this attribute will reflect the accordion' open state.\n         */\n        this.open = false;\n        /** Disables the accordion so it can't be toggled. */\n        this.disabled = false;\n        /** The size of the accordion header */\n        this.size = 'medium';\n        /** The direction of which the chevron should be displayed in the summary section */\n        this.direction = 'left';\n    }\n    firstUpdated() {\n        this.body.hidden = !this.open;\n        this.body.style.height = this.open ? 'auto' : '0';\n    }\n    handleSummaryClick(event) {\n        const target = event.target;\n        const checkbox = target.closest('koerber-checkbox');\n        // If the user clicked on a checkbox, don't toggle the accordion\n        if (checkbox) {\n            return;\n        }\n        if (!this.disabled) {\n            if (this.open) {\n                this.hide();\n            }\n            else {\n                this.show();\n            }\n            this.header.focus();\n        }\n    }\n    handleSummaryKeyDown(event) {\n        if (event.key === 'Enter' || event.key === ' ') {\n            event.preventDefault();\n            if (this.open) {\n                this.hide();\n            }\n            else {\n                this.show();\n            }\n        }\n        if (event.key === 'ArrowUp' || event.key === 'ArrowLeft') {\n            event.preventDefault();\n            this.hide();\n        }\n        if (event.key === 'ArrowDown' || event.key === 'ArrowRight') {\n            event.preventDefault();\n            this.show();\n        }\n    }\n    async handleOpenChange() {\n        if (this.open) {\n            // Show\n            const koerberShow = this.emit('koerber-show', { cancelable: true });\n            if (koerberShow.defaultPrevented) {\n                this.open = false;\n                return;\n            }\n            await stopAnimations(this.body);\n            this.body.hidden = false;\n            const { keyframes, options } = getAnimation(this, 'accordion.show', { dir: this.localize.dir() });\n            await animateTo(this.body, shimKeyframesHeightAuto(keyframes, this.body.scrollHeight), options);\n            this.body.style.height = 'auto';\n            this.emit('koerber-after-show');\n        }\n        else {\n            // Hide\n            const koerberHide = this.emit('koerber-hide', { cancelable: true });\n            if (koerberHide.defaultPrevented) {\n                this.open = true;\n                return;\n            }\n            await stopAnimations(this.body);\n            const { keyframes, options } = getAnimation(this, 'accordion.hide', { dir: this.localize.dir() });\n            await animateTo(this.body, shimKeyframesHeightAuto(keyframes, this.body.scrollHeight), options);\n            this.body.hidden = true;\n            this.body.style.height = 'auto';\n            this.emit('koerber-after-hide');\n        }\n    }\n    /** Shows the accordion. */\n    async show() {\n        if (this.open || this.disabled) {\n            return undefined;\n        }\n        this.open = true;\n        return waitForEvent(this, 'koerber-after-show');\n    }\n    /** Hides the accordion */\n    async hide() {\n        if (!this.open || this.disabled) {\n            return undefined;\n        }\n        this.open = false;\n        return waitForEvent(this, 'koerber-after-hide');\n    }\n    render() {\n        const isRtl = this.localize.dir() === 'rtl';\n        const summary_icon_part = html `\n      <span part=\"summary-icon\" class=\"accordion__summary-icon\">\n        <slot name=\"expand-icon\">\n          <koerber-icon library=\"system\" name=\"chevron-down\"></koerber-icon>\n        </slot>\n        <slot name=\"collapse-icon\">\n          <koerber-icon library=\"system\" name=\"chevron-down\"></koerber-icon>\n        </slot>\n      </span>\n    `;\n        return html `\n      <div\n        part=\"base\"\n        class=${classMap({\n            accordion: true,\n            'accordion--open': this.open,\n            'accordion--disabled': this.disabled,\n            'accordion--rtl': isRtl,\n            [`accordion--${this.size}`]: true\n        })}\n      >\n        <div\n          part=\"header\"\n          id=\"header\"\n          class=${classMap({\n            accordion__header: true,\n            [`accordion__header--${this.size}`]: true\n        })}\n          role=\"button\"\n          aria-expanded=${this.open ? 'true' : 'false'}\n          aria-controls=\"content\"\n          aria-disabled=${this.disabled ? 'true' : 'false'}\n          aria-label=\"Expand/Collapse\"\n          tabindex=${this.disabled ? '-1' : '0'}\n          @click=${this.handleSummaryClick}\n          @keydown=${this.handleSummaryKeyDown}\n        >\n          ${this.direction === 'left' ? summary_icon_part : ''}\n\n          <slot name=\"prefix\" part=\"prefix-side\" class=\"accordion__title__prefix\"></slot>\n\n          <div part=\"body-summary\" class=\"accordion__body-summary\">\n            <slot name=\"summary\" part=\"summary\" class=\"accordion__summary\">${this.summary}</slot>\n            <slot name=\"subtitle\" part=\"subtitle\" class=\"accordion__subtitle\">${this.subtitle}</slot>\n          </div>\n\n          <slot name=\"suffix\" part=\"suffix-side\" class=\"accordion__title__suffix\"></slot>\n\n          ${this.direction === 'right' ? summary_icon_part : ''}\n        </div>\n\n        <div\n          class=${classMap({\n            accordion__body: true,\n            [`accordion__body--${this.size}`]: true\n        })}\n          role=\"region\"\n          aria-labelledby=\"header\"\n        >\n          <slot name=\"prefix-content\" part=\"prefix-content\" class=\"accordion__body__prefix-content\"></slot>\n          <slot\n            part=\"content\"\n            id=\"content\"\n            class=${classMap({\n            accordion__content: true\n        })}\n          >\n          </slot>\n          ${this.hasSlotController.test('suffix-content')\n            ? html `<div part=\"suffix-content\" class=\"accordion__body__suffix-content\">\n                <slot name=\"suffix-content\"></slot>\n              </div>`\n            : ''}\n        </div>\n      </div>\n    `;\n    }\n}\nAccordion.styles = [componentStyles, styles];\nAccordion.dependencies = { 'koerber-icon': Icon };\nexport default Accordion;\n__decorate([\n    query('.accordion')\n], Accordion.prototype, \"accordion\", void 0);\n__decorate([\n    query('.accordion__header')\n], Accordion.prototype, \"header\", void 0);\n__decorate([\n    query('.accordion__body')\n], Accordion.prototype, \"body\", void 0);\n__decorate([\n    query('.accordion__expand-icon-slot')\n], Accordion.prototype, \"expandIconSlot\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Accordion.prototype, \"open\", void 0);\n__decorate([\n    property()\n], Accordion.prototype, \"summary\", void 0);\n__decorate([\n    property()\n], Accordion.prototype, \"subtitle\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Accordion.prototype, \"disabled\", void 0);\n__decorate([\n    property({ reflect: true })\n], Accordion.prototype, \"size\", void 0);\n__decorate([\n    property({ reflect: true })\n], Accordion.prototype, \"direction\", void 0);\n__decorate([\n    watch('open', { waitUntilFirstUpdate: true })\n], Accordion.prototype, \"handleOpenChange\", null);\nsetDefaultAnimation('accordion.show', {\n    keyframes: [\n        { height: '0', opacity: '0' },\n        { height: 'auto', opacity: '1' }\n    ],\n    options: { duration: 250, easing: 'linear' }\n});\nsetDefaultAnimation('accordion.hide', {\n    keyframes: [\n        { height: 'auto', opacity: '1' },\n        { height: '0', opacity: '0' }\n    ],\n    options: { duration: 250, easing: 'linear' }\n});\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { animateTo, stopAnimations } from '../../internal/animate';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { getAnimation, setDefaultAnimation } from '../../utilities/animation-registry';\nimport { HasSlotController } from '../../internal/slot';\nimport { html } from 'lit';\nimport { LocalizeController } from '@shoelace-style/localize';\nimport { property, query, state } from 'lit/decorators.js';\nimport { waitForEvent } from '../../internal/event';\nimport { watch } from '../../internal/watch';\nimport Button from '../button/button.component';\nimport componentStyles from '../../styles/component.styles';\nimport styles from './alert.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Alert are used to inform or notify important messages inline or inside a container.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-alert--docs\n * @status stable\n * @since 1.0\n *\n * @dependency koerber-icon-button\n *\n * @slot - The alert's main content.\n * @slot action - An button to show in the alert. Works best with `<koerber-button variant=\"ghost\">`.\n *\n * @event koerber-show - Emitted when the alert opens.\n * @event koerber-after-show - Emitted after the alert opens and all animations are complete.\n * @event koerber-hide - Emitted when the alert closes.\n * @event koerber-after-hide - Emitted after the alert closes and all animations are complete.\n *\n * @csspart base - The component's base wrapper.\n * @csspart icon - The container that wraps the optional icon.\n * @csspart message - The container that wraps the alert's main content.\n * @csspart close-button - The close button, an `<koerber-button>`.\n * @csspart close-button__base - The close button's exported `base` part.\n * @csspart label - The snackbar's label.\n *\n * @animation alert.show - The animation to use when showing the alert.\n * @animation alert.hide - The animation to use when hiding the alert.\n */\nconst toastStack = Object.assign(document.createElement('div'), { className: 'koerber-toast-stack' });\nconst toastChildAlert = 'koerber-alert-child';\nclass Alert extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.hasSlotController = new HasSlotController(this, '[default]', 'icon', 'action-primary', 'action-secondary');\n        this.localize = new LocalizeController(this);\n        /** Indicates whether the current text on the alert exceeds its bounds and the maximum number of lines */\n        this.isTextOverflowing = false;\n        /**\n         * Indicates whether or not the alert is open. You can toggle this attribute to show and hide the alert, or you can\n         * use the `show()` and `hide()` methods and this attribute will reflect the alert's open state.\n         */\n        this.open = false;\n        /** Enables a close button that allows the user to dismiss the alert. */\n        this.closable = false;\n        /** The alert's theme variant. */\n        this.variant = 'info';\n        /** Set wether actions should be rendered bottom or inline with main content */\n        this.actionsPlacement = 'inline';\n        /**\n         * The length of time, in milliseconds (ms), the alert will show before closing itself. If the user interacts with\n         * the alert before it closes (e.g. moves the mouse over it), the timer will restart. Defaults to `5000` ms, meaning\n         * the alert will not close after 5 seconds.\n         */\n        this.duration = Infinity;\n    }\n    firstUpdated() {\n        var _a;\n        this.base.hidden = !this.open;\n        const textContainer = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('.multiline');\n        const observer = new ResizeObserver(() => {\n            if (textContainer && textContainer.scrollHeight > textContainer.clientHeight) {\n                this.isTextOverflowing = true;\n                this.emit('koerber-show');\n            }\n            else if (this.isTextOverflowing) {\n                this.isTextOverflowing = false;\n                this.emit('koerber-hide');\n            }\n        });\n        if (textContainer) {\n            observer.observe(textContainer);\n        }\n    }\n    restartAutoHide() {\n        clearTimeout(this.autoHideTimeout);\n        if (this.open && this.duration < Infinity) {\n            this.autoHideTimeout = window.setTimeout(() => this.hide(), this.duration);\n        }\n    }\n    handleCloseClick() {\n        this.hide();\n    }\n    handleMouseMove() {\n        this.restartAutoHide();\n    }\n    /**\n     * Displays the alert as a toast alert. This will move the alert out of its position in the DOM and, when dismissed, it will be removed from the DOM completely. By storing a reference to the alert, you can reuse it by calling this method again. The returned promise will resolve after the alert is hidden.\n     */\n    async toast() {\n        return new Promise(resolve => {\n            var _a;\n            if (this.classList.contains(toastChildAlert)) {\n                // eslint-disable-next-line @typescript-eslint/non-nullable-type-assertion-style\n                const childAlert = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('.alert');\n                childAlert.style.position = 'absolute';\n                childAlert.style.bottom = 'var(--koerber-toast-stack-spacing)';\n                childAlert.style.right = '0';\n                childAlert.style.width = '100%';\n                if (!this.open) {\n                    this.show();\n                }\n                return;\n            }\n            if (toastStack.parentElement === null) {\n                document.body.append(toastStack);\n            }\n            toastStack.appendChild(this);\n            // Wait for the toast stack to render\n            requestAnimationFrame(() => {\n                // eslint-disable-next-line @typescript-eslint/no-unused-expressions -- force a reflow for the initial transition\n                this.clientWidth;\n                this.show();\n            });\n            this.addEventListener('koerber-after-hide', () => {\n                toastStack.removeChild(this);\n                resolve();\n                // Remove the toast stack from the DOM when there are no more alerts\n                if (toastStack.querySelector('koerber-alert') === null) {\n                    toastStack.remove();\n                }\n            }, { once: true });\n        });\n    }\n    async handleOpenChange() {\n        if (this.open) {\n            // Show\n            this.emit('koerber-show');\n            if (this.duration < Infinity) {\n                this.restartAutoHide();\n            }\n            await stopAnimations(this.base);\n            this.base.hidden = false;\n            const { keyframes, options } = getAnimation(this, 'alert.show', { dir: this.localize.dir() });\n            await animateTo(this.base, keyframes, options);\n            this.emit('koerber-after-show');\n        }\n        else {\n            // Hide\n            this.emit('koerber-hide');\n            clearTimeout(this.autoHideTimeout);\n            await stopAnimations(this.base);\n            const { keyframes, options } = getAnimation(this, 'alert.hide', { dir: this.localize.dir() });\n            await animateTo(this.base, keyframes, options);\n            this.base.hidden = true;\n            this.emit('koerber-after-hide');\n        }\n    }\n    handleDurationChange() {\n        this.restartAutoHide();\n    }\n    /** Shows the alert. */\n    async show() {\n        this.open = true;\n        return waitForEvent(this, 'koerber-after-show');\n    }\n    /** Hides the alert */\n    async hide() {\n        this.open = false;\n        return waitForEvent(this, 'koerber-after-hide');\n    }\n    render() {\n        return html `\n      <div\n        part=\"base\"\n        class=${classMap({\n            alert: true,\n            'alert--multiline': this.actionsPlacement === 'footer',\n            'alert--open': this.open,\n            'alert--closable': this.closable,\n            [`alert--${this.variant}`]: true\n        })}\n        role=\"alert\"\n        aria-hidden=${this.open ? 'false' : 'true'}\n        @mousemove=${this.handleMouseMove}\n      >\n        <div\n          class=${classMap({\n            'alert__body-container': true,\n            'alert__body-container-multiline': this.actionsPlacement === 'footer'\n        })}\n        >\n          <div\n            class=${classMap({\n            'alert__content-container': true,\n            'alert__content-container-multiline': this.actionsPlacement === 'footer'\n        })}\n          >\n            ${this.hasSlotController.test('icon')\n            ? html `\n                  <slot\n                    name=\"icon\"\n                    class=${classMap({\n                alert__icon: true,\n                alert__icon__multiline: this.actionsPlacement === 'footer'\n            })}\n                  ></slot>\n                `\n            : ''}\n            <div\n              part=\"message\"\n              class=${classMap({\n            alert__message: true,\n            multiline: true,\n            'footer--active': this.actionsPlacement === 'footer'\n        })}\n              aria-live=\"polite\"\n            >\n              <slot></slot>\n            </div>\n          </div>\n          <div\n            part=\"expand\"\n            class=${classMap({\n            alert__expand: true,\n            alert__expand_multiline: this.actionsPlacement === 'footer'\n        })}\n          >\n            <slot name=\"expand\"></slot>\n          </div>\n          <div\n            part=\"actions\"\n            class=${classMap({\n            alert__actions: true,\n            alert__actions_multiline: this.actionsPlacement === 'footer'\n        })}\n          >\n            <slot name=\"action\"></slot>\n          </div>\n        </div>\n\n        ${this.closable\n            ? html `\n              <koerber-button\n                part=\"close-button\"\n                exportparts=\"base:close-button__base\"\n                class=\"alert__close-button\"\n                aria-label=${this.localize.term('close')}\n                name=${this.localize.term('close')}\n                label=${this.localize.term('close')}\n                @click=${this.handleCloseClick}\n                icon-only\n                variant=\"ghost\"\n                icon=\"close\"\n              >\n                <koerber-icon name=\"close\"></koerber-icon>\n              </koerber-button>\n            `\n            : ''}\n      </div>\n    `;\n    }\n}\nAlert.styles = [componentStyles, styles];\nAlert.dependencies = {\n    'koerber-button': Button\n};\nexport default Alert;\n__decorate([\n    query('[part~=\"base\"]')\n], Alert.prototype, \"base\", void 0);\n__decorate([\n    state()\n], Alert.prototype, \"isTextOverflowing\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Alert.prototype, \"open\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Alert.prototype, \"closable\", void 0);\n__decorate([\n    property({ reflect: true })\n], Alert.prototype, \"variant\", void 0);\n__decorate([\n    property({ attribute: 'actions-placement' })\n], Alert.prototype, \"actionsPlacement\", void 0);\n__decorate([\n    property({ type: Number })\n], Alert.prototype, \"duration\", void 0);\n__decorate([\n    watch('open', { waitUntilFirstUpdate: true })\n], Alert.prototype, \"handleOpenChange\", null);\n__decorate([\n    watch('duration')\n], Alert.prototype, \"handleDurationChange\", null);\nsetDefaultAnimation('alert.show', {\n    keyframes: [\n        { opacity: 0, scale: 0.8 },\n        { opacity: 1, scale: 1 }\n    ],\n    options: { duration: 250, easing: 'ease' }\n});\nsetDefaultAnimation('alert.hide', {\n    keyframes: [\n        { opacity: 1, scale: 1 },\n        { opacity: 0, scale: 0.8 }\n    ],\n    options: { duration: 250, easing: 'ease' }\n});\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { animations } from './animations';\nimport { html } from 'lit';\nimport { property, queryAsync } from 'lit/decorators.js';\nimport { watch } from '../../internal/watch';\nimport componentStyles from '../../styles/component.styles';\nimport styles from './animation.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Animate elements declaratively with nearly 100 baked-in presets, or roll your own with custom keyframes. Powered by the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API).\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net\n * @status stable\n * @since 2.0\n *\n * @event koerber-cancel - Emitted when the animation is canceled.\n * @event koerber-finish - Emitted when the animation finishes.\n * @event koerber-start - Emitted when the animation starts or restarts.\n *\n * @slot - The element to animate. Avoid slotting in more than one element, as subsequent ones will be ignored. To\n *  animate multiple elements, either wrap them in a single container or use multiple `<koerber-animation>` elements.\n */\nclass KoerberAnimation extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.hasStarted = false;\n        /** The name of the built-in animation to use. For custom animations, use the `keyframes` prop. */\n        this.name = 'none';\n        /**\n         * Plays the animation. When omitted, the animation will be paused. This attribute will be automatically removed when\n         * the animation finishes or gets canceled.\n         */\n        this.play = false;\n        /** The number of milliseconds to delay the start of the animation. */\n        this.delay = 0;\n        /**\n         * Determines the direction of playback as well as the behavior when reaching the end of an iteration.\n         * [Learn more](https://developer.mozilla.org/en-US/docs/Web/CSS/animation-direction)\n         */\n        this.direction = 'normal';\n        /** The number of milliseconds each iteration of the animation takes to complete. */\n        this.duration = 1000;\n        /**\n         * The easing function to use for the animation. This can be a Shoelace easing function or a custom easing function\n         * such as `cubic-bezier(0, 1, .76, 1.14)`.\n         */\n        this.easing = 'linear';\n        /** The number of milliseconds to delay after the active period of an animation sequence. */\n        this.endDelay = 0;\n        /** Sets how the animation applies styles to its target before and after its execution. */\n        this.fill = 'auto';\n        /** The number of iterations to run before the animation completes. Defaults to `Infinity`, which loops. */\n        this.iterations = Infinity;\n        /** The offset at which to start the animation, usually between 0 (start) and 1 (end). */\n        this.iterationStart = 0;\n        /**\n         * Sets the animation's playback rate. The default is `1`, which plays the animation at a normal speed. Setting this\n         * to `2`, for example, will double the animation's speed. A negative value can be used to reverse the animation. This\n         * value can be changed without causing the animation to restart.\n         */\n        this.playbackRate = 1;\n    }\n    /** Gets and sets the current animation time. */\n    get currentTime() {\n        var _a, _b;\n        return (_b = (_a = this.animation) === null || _a === void 0 ? void 0 : _a.currentTime) !== null && _b !== void 0 ? _b : 0;\n    }\n    set currentTime(time) {\n        if (this.animation) {\n            this.animation.currentTime = time;\n        }\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.createAnimation();\n        this.handleAnimationCancel = this.handleAnimationCancel.bind(this);\n        this.handleAnimationFinish = this.handleAnimationFinish.bind(this);\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this.destroyAnimation();\n    }\n    handleAnimationFinish() {\n        this.play = false;\n        this.hasStarted = false;\n        this.emit('koerber-finish');\n    }\n    handleAnimationCancel() {\n        this.play = false;\n        this.hasStarted = false;\n        this.emit('koerber-cancel');\n    }\n    handleSlotChange() {\n        this.destroyAnimation();\n        this.createAnimation();\n    }\n    async createAnimation() {\n        var _a, _b;\n        const easing = (_a = animations.easings[this.easing]) !== null && _a !== void 0 ? _a : this.easing;\n        const keyframes = (_b = this.keyframes) !== null && _b !== void 0 ? _b : animations[this.name];\n        const slot = await this.defaultSlot;\n        const element = slot.assignedElements()[0];\n        if (!element || !keyframes) {\n            return false;\n        }\n        this.destroyAnimation();\n        this.animation = element.animate(keyframes, {\n            delay: this.delay,\n            direction: this.direction,\n            duration: this.duration,\n            easing,\n            endDelay: this.endDelay,\n            fill: this.fill,\n            iterationStart: this.iterationStart,\n            iterations: this.iterations\n        });\n        this.animation.playbackRate = this.playbackRate;\n        this.animation.addEventListener('cancel', this.handleAnimationCancel);\n        this.animation.addEventListener('finish', this.handleAnimationFinish);\n        if (this.play) {\n            this.hasStarted = true;\n            this.emit('koerber-start');\n        }\n        else {\n            this.animation.pause();\n        }\n        return true;\n    }\n    destroyAnimation() {\n        if (this.animation) {\n            this.animation.cancel();\n            this.animation.removeEventListener('cancel', this.handleAnimationCancel);\n            this.animation.removeEventListener('finish', this.handleAnimationFinish);\n            this.hasStarted = false;\n        }\n    }\n    handleAnimationChange() {\n        if (!this.hasUpdated) {\n            return;\n        }\n        this.createAnimation();\n    }\n    handlePlayChange() {\n        if (this.animation) {\n            if (this.play && !this.hasStarted) {\n                this.hasStarted = true;\n                this.emit('koerber-start');\n            }\n            if (this.play) {\n                this.animation.play();\n            }\n            else {\n                this.animation.pause();\n            }\n            return true;\n        }\n        return false;\n    }\n    handlePlaybackRateChange() {\n        if (this.animation) {\n            this.animation.playbackRate = this.playbackRate;\n        }\n    }\n    /** Clears all keyframe effects caused by this animation and aborts its playback. */\n    cancel() {\n        var _a;\n        (_a = this.animation) === null || _a === void 0 ? void 0 : _a.cancel();\n    }\n    /** Sets the playback time to the end of the animation corresponding to the current playback direction. */\n    finish() {\n        var _a;\n        (_a = this.animation) === null || _a === void 0 ? void 0 : _a.finish();\n    }\n    render() {\n        return html ` <slot @slotchange=${this.handleSlotChange}></slot> `;\n    }\n}\nKoerberAnimation.styles = [componentStyles, styles];\nexport default KoerberAnimation;\n__decorate([\n    queryAsync('slot')\n], KoerberAnimation.prototype, \"defaultSlot\", void 0);\n__decorate([\n    property()\n], KoerberAnimation.prototype, \"name\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], KoerberAnimation.prototype, \"play\", void 0);\n__decorate([\n    property({ type: Number })\n], KoerberAnimation.prototype, \"delay\", void 0);\n__decorate([\n    property()\n], KoerberAnimation.prototype, \"direction\", void 0);\n__decorate([\n    property({ type: Number })\n], KoerberAnimation.prototype, \"duration\", void 0);\n__decorate([\n    property()\n], KoerberAnimation.prototype, \"easing\", void 0);\n__decorate([\n    property({ attribute: 'end-delay', type: Number })\n], KoerberAnimation.prototype, \"endDelay\", void 0);\n__decorate([\n    property()\n], KoerberAnimation.prototype, \"fill\", void 0);\n__decorate([\n    property({ type: Number })\n], KoerberAnimation.prototype, \"iterations\", void 0);\n__decorate([\n    property({ attribute: 'iteration-start', type: Number })\n], KoerberAnimation.prototype, \"iterationStart\", void 0);\n__decorate([\n    property({ attribute: false })\n], KoerberAnimation.prototype, \"keyframes\", void 0);\n__decorate([\n    property({ attribute: 'playback-rate', type: Number })\n], KoerberAnimation.prototype, \"playbackRate\", void 0);\n__decorate([\n    watch([\n        'name',\n        'delay',\n        'direction',\n        'duration',\n        'easing',\n        'endDelay',\n        'fill',\n        'iterations',\n        'iterationsStart',\n        'keyframes'\n    ])\n], KoerberAnimation.prototype, \"handleAnimationChange\", null);\n__decorate([\n    watch('play')\n], KoerberAnimation.prototype, \"handlePlayChange\", null);\n__decorate([\n    watch('playbackRate')\n], KoerberAnimation.prototype, \"handlePlaybackRateChange\", null);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { classMap } from 'lit/directives/class-map.js';\nimport { HasSlotController } from '../../internal/slot';\nimport { html } from 'lit';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { property, query, state } from 'lit/decorators.js';\nimport componentStyles from '../../styles/component.styles';\nimport styles from './breadcrumb-item.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Breadcrumb Items are used inside [breadcrumbs](/components/breadcrumb) to represent different links.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-breadcrumb-item--docs\n * @status stable\n * @since 2.0\n *\n * @slot - The breadcrumb item's label.\n * @slot prefix - An optional prefix, usually an icon or icon button.\n * @slot suffix - An optional suffix, usually an icon or icon button.\n * @slot separator - The separator to use for the breadcrumb item. This will only change the separator for this item. If\n * you want to change it for all items in the group, set the separator on `<koerber-breadcrumb>` instead.\n *\n * @csspart base - The component's base wrapper.\n * @csspart label - The breadcrumb item's label.\n * @csspart prefix - The container that wraps the prefix.\n * @csspart suffix - The container that wraps the suffix.\n * @csspart separator - The container that wraps the separator.\n */\nclass BreadcrumbItem extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.hasSlotController = new HasSlotController(this, 'prefix', 'suffix');\n        /* Checks if text is overflowing */\n        this.isTextOverflowing = false;\n        /** Indicates the max width of the item text */\n        this.maxWidth = 0;\n        /** The `rel` attribute to use on the link. Only used when `href` is set. */\n        this.rel = 'noreferrer noopener';\n        /** Check if the item is the current Active */\n        this.isActive = false;\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        // observe the changes on current breadcrumb item\n        this.updateComplete.then(() => {\n            this.resizeObserver.observe(this.labelContentSlot);\n        });\n    }\n    updated(_changedProperties) {\n        if (_changedProperties.has('isTextOverflowing')) {\n            this.attachOverflowObserver();\n        }\n    }\n    attachOverflowObserver() {\n        if (this.resizeObserver) {\n            this.resizeObserver.disconnect();\n        }\n        this.resizeObserver = new ResizeObserver(() => this.checkIfTextIsTruncated());\n        this.updateComplete.then(() => {\n            this.resizeObserver.observe(this.labelContentSlot);\n        });\n    }\n    // This function checks if item width exceeds the max width if set\n    checkIfTextIsTruncated() {\n        if (this.labelContentSlot) {\n            if (this.labelContentSlot.scrollWidth > this.labelContentSlot.clientWidth) {\n                this.isTextOverflowing = true;\n            }\n            else {\n                this.isTextOverflowing = false;\n            }\n        }\n        return this.isTextOverflowing;\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this.resizeObserver.disconnect();\n    }\n    // This function will return only the direct text nodes of the custom element, excluding slots.\n    getTextContentExcludingSlots() {\n        const nodes = Array.from(this.childNodes);\n        const filteredTextContent = nodes\n            .filter(node => { var _a; return node.nodeType === Node.TEXT_NODE && ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.trim()) !== ''; })\n            .map(node => { var _a; return (_a = node.textContent) === null || _a === void 0 ? void 0 : _a.trim(); })\n            .join(' ');\n        return filteredTextContent;\n    }\n    render() {\n        const isLink = this.href ? true : false;\n        const textContent = this.getTextContentExcludingSlots();\n        const content = this.isActive\n            ? html `\r\n          <span id=\"breadcrumb-item\" part=\"label\" class=\"breadcrumb-item__label\">\r\n            <slot></slot>\r\n          </span>\r\n        `\n            : isLink\n                ? html `\r\n            <a\r\n              id=\"breadcrumb-item\"\r\n              part=\"label\"\r\n              class=\"breadcrumb-item__label breadcrumb-item__label--link\"\r\n              href=\"${this.href}\"\r\n              target=\"${ifDefined(this.target ? this.target : undefined)}\"\r\n              rel=${ifDefined(this.target ? this.rel : undefined)}\r\n            >\r\n              <slot></slot>\r\n            </a>\r\n          `\n                : html `\r\n            <button\r\n              id=\"breadcrumb-item\"\r\n              part=\"label\"\r\n              type=\"button\"\r\n              class=\"breadcrumb-item__label breadcrumb-item__label--button\"\r\n            >\r\n              <slot></slot>\r\n            </button>\r\n          `;\n        return html `\r\n      <style>\r\n        .breadcrumb-item__label {\r\n          max-width: ${this.maxWidth > 0 ? `${this.maxWidth}px` : `100%`};\r\n        }\r\n      </style>\r\n      <div\r\n        part=\"base\"\r\n        class=${classMap({\n            'breadcrumb-item': true,\n            'breadcrumb-item--has-prefix': this.hasSlotController.test('prefix'),\n            'breadcrumb-item--has-suffix': this.hasSlotController.test('suffix')\n        })}\r\n      >\r\n        ${this.isTextOverflowing\n            ? html ` <koerber-tooltip hoist content=${ifDefined(textContent)}>${content}</koerber-tooltip> `\n            : html ` ${content} `}\r\n\r\n        <slot name=\"separator\" part=\"separator\" class=\"breadcrumb-item__separator\" aria-hidden=\"true\"></slot>\r\n      </div>\r\n    `;\n    }\n}\nBreadcrumbItem.styles = [componentStyles, styles];\nexport default BreadcrumbItem;\n__decorate([\n    state()\n], BreadcrumbItem.prototype, \"isTextOverflowing\", void 0);\n__decorate([\n    property({ type: Number, attribute: 'max-width' })\n], BreadcrumbItem.prototype, \"maxWidth\", void 0);\n__decorate([\n    property()\n], BreadcrumbItem.prototype, \"href\", void 0);\n__decorate([\n    property()\n], BreadcrumbItem.prototype, \"target\", void 0);\n__decorate([\n    property()\n], BreadcrumbItem.prototype, \"rel\", void 0);\n__decorate([\n    property({ type: Boolean, attribute: 'active' })\n], BreadcrumbItem.prototype, \"isActive\", void 0);\n__decorate([\n    query('.breadcrumb-item__label')\n], BreadcrumbItem.prototype, \"labelContentSlot\", void 0);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { html } from 'lit';\nimport { LocalizeController } from '../../utilities/localize';\nimport { property, query } from 'lit/decorators.js';\nimport componentStyles from '../../styles/component.styles';\nimport Icon from '../icon/icon.component';\nimport styles from './breadcrumb.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Breadcrumbs provide a group of links so users can easily navigate a website's hierarchy.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-breadcrumb--docs\n * @status stable\n * @since 2.0\n *\n * @slot - One or more breadcrumb items to display.\n * @slot separator - The separator to use between breadcrumb items. Works best with `<koerber-icon>`.\n *\n * @dependency koerber-icon\n *\n * @csspart base - The component's base wrapper.\n */\nclass Breadcrumb extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.localize = new LocalizeController(this);\n        this.separatorDir = this.localize.dir();\n        /**\n         * The label to use for the breadcrumb control. This will not be shown on the screen, but it will be announced by\n         * screen readers and other assistive devices to provide more context for users.\n         */\n        this.label = '';\n    }\n    // Generates a clone of the separator element to use for each breadcrumb item\n    getSeparator() {\n        const separator = this.separatorSlot.assignedElements({ flatten: true })[0];\n        // Clone it, remove ids, and slot it\n        const clone = separator.cloneNode(true);\n        [clone, ...clone.querySelectorAll('[id]')].forEach(el => el.removeAttribute('id'));\n        clone.setAttribute('data-default', '');\n        clone.slot = 'separator';\n        return clone;\n    }\n    handleSlotChange() {\n        const items = [...this.defaultSlot.assignedElements({ flatten: true })].filter(item => item.tagName.toLowerCase() === 'koerber-breadcrumb-item');\n        items.forEach((item, index) => {\n            // Append separators to each item if they don't already have one\n            const separator = item.querySelector('[slot=\"separator\"]');\n            if (separator === null) {\n                // No separator exists, add one\n                item.append(this.getSeparator());\n            }\n            else if (separator.hasAttribute('data-default')) {\n                // A default separator exists, replace it\n                separator.replaceWith(this.getSeparator());\n            }\n            // The last breadcrumb item is the \"current page\"\n            if (index === items.length - 1) {\n                item.setAttribute('aria-current', 'page');\n            }\n            else {\n                item.removeAttribute('aria-current');\n            }\n        });\n    }\n    render() {\n        // We clone the separator and inject them into breadcrumb items, so we need to regenerate the default ones when\n        // directionality changes. We do this by storing the current separator direction, waiting for render, then calling\n        // the function that regenerates them.\n        if (this.separatorDir !== this.localize.dir()) {\n            this.separatorDir = this.localize.dir();\n            this.updateComplete.then(() => this.handleSlotChange());\n        }\n        return html `\n      <nav part=\"base\" class=\"breadcrumb\" aria-label=${this.label}>\n        <slot @slotchange=${this.handleSlotChange}></slot>\n      </nav>\n\n      <slot name=\"separator\" hidden aria-hidden=\"true\">\n        <koerber-icon\n          name=${this.localize.dir() === 'rtl' ? 'chevron-left' : 'chevron-right'}\n          library=\"system\"\n        ></koerber-icon>\n      </slot>\n    `;\n    }\n}\nBreadcrumb.styles = [componentStyles, styles];\nBreadcrumb.dependencies = { 'koerber-icon': Icon };\nexport default Breadcrumb;\n__decorate([\n    query('slot')\n], Breadcrumb.prototype, \"defaultSlot\", void 0);\n__decorate([\n    query('slot[name=\"separator\"]')\n], Breadcrumb.prototype, \"separatorSlot\", void 0);\n__decorate([\n    property()\n], Breadcrumb.prototype, \"label\", void 0);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { html } from 'lit';\nimport { property, query, state } from 'lit/decorators.js';\nimport componentStyles from '../../styles/component.styles';\nimport styles from './button-group.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Button groups can be used to group related buttons into sections.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net\n * @status stable\n * @since 2.0\n *\n * @slot - One or more `<koerber-button>` elements to display in the button group.\n *\n * @csspart base - The component's base wrapper.\n */\nclass ButtonGroup extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.disableRole = false;\n        /**\n         * A label to use for the button group. This won't be displayed on the screen, but it will be announced by assistive\n         * devices when interacting with the control and is strongly recommended.\n         */\n        this.label = '';\n        this.split = false;\n    }\n    handleFocus(event) {\n        const button = findButton(event.target);\n        button === null || button === void 0 ? void 0 : button.classList.add('koerber-button-group__button--focus');\n    }\n    handleBlur(event) {\n        const button = findButton(event.target);\n        button === null || button === void 0 ? void 0 : button.classList.remove('koerber-button-group__button--focus');\n    }\n    handleMouseOver(event) {\n        const button = findButton(event.target);\n        button === null || button === void 0 ? void 0 : button.classList.add('koerber-button-group__button--hover');\n    }\n    handleMouseOut(event) {\n        const button = findButton(event.target);\n        button === null || button === void 0 ? void 0 : button.classList.remove('koerber-button-group__button--hover');\n    }\n    handleSlotChange() {\n        const slottedElements = [...this.defaultSlot.assignedElements({ flatten: true })];\n        slottedElements.forEach(el => {\n            const index = slottedElements.indexOf(el);\n            const button = findButton(el);\n            if (button !== null) {\n                button.classList.add('koerber-button-group__button');\n                button.classList.toggle('koerber-button-group__button--first', index === 0);\n                button.classList.toggle('koerber-button-group__button--inner', index > 0 && index < slottedElements.length - 1);\n                button.classList.toggle('koerber-button-group__button--split', this.split && index >= 0 && index < slottedElements.length - 1);\n                button.classList.toggle('koerber-button-group__button--last', index === slottedElements.length - 1);\n                button.classList.toggle('koerber-button-group__button--radio', button.tagName.toLowerCase() === 'koerber-radio-button');\n            }\n        });\n    }\n    render() {\n        // eslint-disable-next-line lit-a11y/mouse-events-have-key-events\n        return html `\n      <slot\n        part=\"base\"\n        class=\"button-group\"\n        role=\"${this.disableRole ? 'presentation' : 'group'}\"\n        aria-label=${this.label}\n        @focusout=${this.handleBlur}\n        @focusin=${this.handleFocus}\n        @mouseover=${this.handleMouseOver}\n        @mouseout=${this.handleMouseOut}\n        @slotchange=${this.handleSlotChange}\n      ></slot>\n    `;\n    }\n}\nButtonGroup.styles = [componentStyles, styles];\nexport default ButtonGroup;\n__decorate([\n    query('slot')\n], ButtonGroup.prototype, \"defaultSlot\", void 0);\n__decorate([\n    state()\n], ButtonGroup.prototype, \"disableRole\", void 0);\n__decorate([\n    property()\n], ButtonGroup.prototype, \"label\", void 0);\n__decorate([\n    property({ type: Boolean })\n], ButtonGroup.prototype, \"split\", void 0);\nfunction findButton(el) {\n    var _a;\n    const selector = 'koerber-button, koerber-radio-button';\n    // The button could be the target element or a child of it (e.g. a dropdown or tooltip anchor)\n    return (_a = el.closest(selector)) !== null && _a !== void 0 ? _a : el.querySelector(selector);\n}\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { classMap } from 'lit/directives/class-map.js';\nimport { html } from 'lit';\nimport { live } from 'lit/directives/live.js';\nimport { LocalizeController } from '../../utilities/localize';\nimport { property, query, state } from 'lit/decorators.js';\nimport { watch } from '../../internal/watch';\nimport Button from '../button/button.component';\nimport componentStyles from '../../styles/component.styles';\nimport styles from './chip.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Chips are used as labels to organize things or to indicate a selection.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-chip--docs\n * @status stable\n * @since 2.0\n *\n * @dependency koerber-icon-button\n * @dependency koerber-icon\n *\n * @slot - The chip's content.\n * @slot next-icon - Optional next icon to use instead of the default. Works best with `<koerber-icon>`.\n * @slot previous-icon - Optional previous icon to use instead of the default. Works best with `<koerber-icon>`.\n *\n * @event koerber-click - Emitted when the chip is clicked.\n * @event koerber-remove - Emitted when the remove button is activated.\n * @event koerber-focus - Emitted when the chip gains focus.\n * @event koerber-blur - Emitted when the chip loses focus.\n *\n * @method click - Simulates a click on the chip.\n * @method focus - Sets focus on the chip.\n * @method blur - Removes focus from the chip.\n * @method delete - Removes the chip.\n *\n *\n * @csspart base - The component's base wrapper.\n * @csspart content - The chip's content.\n * @csspart remove-button - The chip's remove button, an `<sl-icon-button>`.\n * @csspart remove-button__base - The remove button's exported `base` part.\n */\nclass Chip extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.localize = new LocalizeController(this);\n        /** The chip's focus state. */\n        this.hasFocus = false;\n        /** The chip's size. */\n        this.size = 'medium';\n        /** The chip's theme variant. */\n        this.variants = 'info';\n        /** Makes the chip removable and shows a remove button. */\n        this.removable = false;\n        /** Disables the chip. */\n        this.disabled = false;\n        /** Draws the chip in a selected state. */\n        this.selected = false;\n        /** Set the prefixIcon name to render */\n        this.prefixIcon = '';\n        /** Set the suffixIcon name to render */\n        this.suffixIcon = '';\n    }\n    /** Methods */\n    /** Simulates a click on the chip. */\n    click() {\n        this.chip.click();\n    }\n    /** Sets focus on the chip. */\n    focus(options) {\n        this.chip.focus(options);\n    }\n    /** Removes focus from the chip. */\n    blur() {\n        this.chip.blur();\n    }\n    /** Removes the chip. */\n    delete() {\n        this.handleDeleteClick();\n    }\n    handleDisabledChange() {\n        this.setAttribute('aria-disabled', this.disabled ? 'true' : 'false');\n    }\n    handleSelectedChange() {\n        this.setAttribute('aria-selected', this.selected ? 'true' : 'false');\n    }\n    /** Events */\n    handleDeleteClick() {\n        this.emit('koerber-remove');\n    }\n    handleClick() {\n        this.emit('koerber-click');\n    }\n    handleFocus() {\n        this.hasFocus = true;\n        this.emit('koerber-focus');\n    }\n    handleBlur() {\n        this.hasFocus = false;\n        this.emit('koerber-blur');\n    }\n    render() {\n        return html `\n      <div part=\"container\" class=\"chip--container\">\n        <span\n          part=\"base\"\n          class=${classMap({\n            chip: true,\n            'chip--primary': this.variants === 'primary',\n            'chip--info': this.variants === 'info',\n            'chip--danger': this.variants === 'danger',\n            'chip--tertiary': this.variants === 'tertiary',\n            'chip--primary-outline': this.variants === 'primary-outline',\n            'chip--info-outline': this.variants === 'info-outline',\n            'chip--danger-outline': this.variants === 'danger-outline',\n            'chip--tertiary-outline': this.variants === 'tertiary-outline',\n            // Sizes\n            'chip--small': this.size === 'small',\n            'chip--medium': this.size === 'medium',\n            'chip--large': this.size === 'large',\n            // Modifiers\n            'chip--removable': this.removable || this.suffixIcon.length > 0,\n            'chip--focused': this.hasFocus,\n            'chip--disabled': this.disabled,\n            'chip--selected': this.selected || this.prefixIcon.length > 0\n        })}\n          ?disabled=${this.disabled}\n          ?checked=\"${live(this.selected)}\"\n          tabindex=${this.disabled ? '-1' : '0'}\n          @click=${this.handleClick}\n          @focus=${this.handleFocus}\n          @blur=${this.handleBlur}\n        >\n          ${this.selected\n            ? html ` <koerber-icon\n                part=\"selected-button\"\n                exportparts=\"base:remove-button__base\"\n                name=\"check-circle\"\n                size=\"medium\"\n                label=${'select'}\n                class=\"chip__selected\"\n                tabindex=\"-1\"\n              ></koerber-icon>`\n            : ''}\n          ${this.prefixIcon\n            ? html ` <koerber-icon part=\"prefix-icon\" class=\"chip__prefix\" name=${this.prefixIcon}></koerber-icon>`\n            : ''}\n\n          <slot part=\"content\" class=\"chip__label\"></slot>\n\n          ${this.suffixIcon\n            ? html ` <koerber-icon part=\"suffix-icon\" class=\"chip__suffix\" name=${this.suffixIcon}></koerber-icon>`\n            : ''}\n          ${this.removable\n            ? html ` <koerber-button\n                variant=\"ghost\"\n                part=\"remove-button\"\n                exportparts=\"base:remove-button__base\"\n                size=\"medium\"\n                label=${this.localize.term('remove')}\n                class=\"chip__remove\"\n                @click=${this.handleDeleteClick}\n                @focus=${this.handleFocus}\n                tabindex=\"-1\"\n                ?disabled=${this.disabled}\n                ><koerber-icon name=\"close\">close</koerber-icon></koerber-button\n              >`\n            : ''}\n\n          <slot part=\"tooltip\"></slot>\n        </span>\n      </div>\n    `;\n    }\n}\nChip.styles = [componentStyles, styles];\nChip.dependencies = { 'koerber-button': Button };\nexport default Chip;\n__decorate([\n    query('.chip')\n], Chip.prototype, \"chip\", void 0);\n__decorate([\n    state()\n], Chip.prototype, \"hasFocus\", void 0);\n__decorate([\n    property({ reflect: true })\n], Chip.prototype, \"size\", void 0);\n__decorate([\n    property({ reflect: true })\n], Chip.prototype, \"variants\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Chip.prototype, \"removable\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Chip.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Chip.prototype, \"selected\", void 0);\n__decorate([\n    property({ type: String, reflect: true, attribute: 'prefix-icon' })\n], Chip.prototype, \"prefixIcon\", void 0);\n__decorate([\n    property({ type: String, reflect: true, attribute: 'suffix-icon' })\n], Chip.prototype, \"suffixIcon\", void 0);\n__decorate([\n    watch('disabled')\n], Chip.prototype, \"handleDisabledChange\", null);\n__decorate([\n    watch('selected')\n], Chip.prototype, \"handleSelectedChange\", null);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { animateTo, stopAnimations } from '../../internal/animate';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { getAnimation, setDefaultAnimation } from '../../utilities/animation-registry';\nimport { getTabbableBoundary } from '../../internal/tabbable';\nimport { html } from 'lit';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { LocalizeController } from '../../utilities/localize';\nimport { property, query } from 'lit/decorators.js';\nimport { waitForEvent } from '../../internal/event';\nimport { watch } from '../../internal/watch';\nimport componentStyles from '../../styles/component.styles';\nimport styles from './dropdown.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Dropdowns expose additional content that \"drops down\" in a panel.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net\n * @status stable\n * @since 2.0\n *\n * @dependency koerber-popup\n *\n * @slot - The dropdown's main content.\n * @slot trigger - The dropdown's trigger, usually a `<koerber-button>` element.\n *\n * @event koerber-show - Emitted when the dropdown opens.\n * @event koerber-after-show - Emitted after the dropdown opens and all animations are complete.\n * @event koerber-hide - Emitted when the dropdown closes.\n * @event koerber-after-hide - Emitted after the dropdown closes and all animations are complete.\n *\n * @csspart base - The component's base wrapper.\n * @csspart trigger - The container that wraps the trigger.\n * @csspart panel - The panel that gets shown when the dropdown is open.\n *\n * @animation dropdown.show - The animation to use when showing the dropdown.\n * @animation dropdown.hide - The animation to use when hiding the dropdown.\n */\nclass Dropdown extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.localize = new LocalizeController(this);\n        /**\n         * Indicates whether or not the dropdown is open. You can toggle this attribute to show and hide the dropdown, or you\n         * can use the `show()` and `hide()` methods and this attribute will reflect the dropdown's open state.\n         */\n        this.open = false;\n        /**\n         * The preferred placement of the dropdown panel. Note that the actual placement may vary as needed to keep the panel\n         * inside of the viewport.\n         */\n        this.placement = 'bottom-start';\n        /** Disables the dropdown so the panel will not open. */\n        this.disabled = false;\n        /**\n         * By default, the dropdown is closed when an item is selected. This attribute will keep it open instead. Useful for\n         * dropdowns that allow for multiple interactions.\n         */\n        this.stayOpenOnSelect = false;\n        /** The distance in pixels from which to offset the panel away from its trigger. */\n        this.distance = 0;\n        /** The distance in pixels from which to offset the panel along its trigger. */\n        this.skidding = 0;\n        /**\n         * Enable this option to prevent the panel from being clipped when the component is placed inside a container with\n         * `overflow: auto|scroll`. Hoisting uses a fixed positioning strategy that works in many, but not all, scenarios.\n         */\n        this.hoist = false;\n        /**\n         * Syncs the popup width or height to that of the trigger element.\n         */\n        this.sync = undefined;\n        this.handleKeyDown = (event) => {\n            // Close when escape is pressed inside an open dropdown. We need to listen on the panel itself and stop propagation\n            // in case any ancestors are also listening for this key.\n            if (this.open && event.key === 'Escape') {\n                event.stopPropagation();\n                this.hide();\n                this.focusOnTrigger();\n            }\n        };\n        this.handleDocumentKeyDown = (event) => {\n            var _a;\n            // Close when escape or tab is pressed\n            if (event.key === 'Escape' && this.open) {\n                event.stopPropagation();\n                this.focusOnTrigger();\n                this.hide();\n                return;\n            }\n            // Handle tabbing\n            if (event.key === 'Tab') {\n                // Tabbing within an open menu should close the dropdown and refocus the trigger\n                if (this.open && ((_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.tagName.toLowerCase()) === 'koerber-menu-item') {\n                    event.preventDefault();\n                    this.hide();\n                    this.focusOnTrigger();\n                    return;\n                }\n                // Tabbing outside of the containing element closes the panel\n                //\n                // If the dropdown is used within a shadow DOM, we need to obtain the activeElement within that shadowRoot,\n                // otherwise `document.activeElement` will only return the name of the parent shadow DOM element.\n                setTimeout(() => {\n                    var _a, _b, _c;\n                    const activeElement = ((_a = this.containingElement) === null || _a === void 0 ? void 0 : _a.getRootNode()) instanceof ShadowRoot\n                        ? (_c = (_b = document.activeElement) === null || _b === void 0 ? void 0 : _b.shadowRoot) === null || _c === void 0 ? void 0 : _c.activeElement\n                        : document.activeElement;\n                    if (!this.containingElement ||\n                        (activeElement === null || activeElement === void 0 ? void 0 : activeElement.closest(this.containingElement.tagName.toLowerCase())) !== this.containingElement) {\n                        this.hide();\n                    }\n                });\n            }\n        };\n        this.handleDocumentMouseDown = (event) => {\n            // Close when clicking outside of the containing element\n            const path = event.composedPath();\n            if (this.containingElement && !path.includes(this.containingElement)) {\n                this.hide();\n            }\n        };\n        this.handlePanelSelect = (event) => {\n            const target = event.target;\n            // Hide the dropdown when a menu item is selected\n            if (!this.stayOpenOnSelect && target.tagName.toLowerCase() === 'koerber-menu') {\n                this.hide();\n                this.focusOnTrigger();\n            }\n        };\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        if (!this.containingElement) {\n            this.containingElement = this;\n        }\n    }\n    firstUpdated() {\n        this.panel.hidden = !this.open;\n        // If the dropdown is visible on init, update its position\n        if (this.open) {\n            this.addOpenListeners();\n            this.popup.active = true;\n        }\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this.removeOpenListeners();\n        this.hide();\n    }\n    focusOnTrigger() {\n        const trigger = this.trigger.assignedElements({ flatten: true })[0];\n        if (typeof (trigger === null || trigger === void 0 ? void 0 : trigger.focus) === 'function') {\n            trigger.focus();\n        }\n    }\n    getMenu() {\n        return this.panel.assignedElements({ flatten: true }).find(el => el.tagName.toLowerCase() === 'koerber-menu');\n    }\n    handleTriggerClick() {\n        if (this.open) {\n            this.hide();\n        }\n        else {\n            this.buttonWidth = `${this.trigger.clientWidth}px`;\n            this.show();\n            this.focusOnTrigger();\n        }\n    }\n    async handleTriggerKeyDown(event) {\n        // When spacebar/enter is pressed, show the panel but don't focus on the menu. This let's the user press the same\n        // key again to hide the menu in case they don't want to make a selection.\n        if ([' ', 'Enter'].includes(event.key)) {\n            event.preventDefault();\n            this.handleTriggerClick();\n            return;\n        }\n        const menu = this.getMenu();\n        if (menu) {\n            const menuItems = menu.getAllItems();\n            const firstMenuItem = menuItems[0];\n            const lastMenuItem = menuItems[menuItems.length - 1];\n            // When up/down is pressed, we make the assumption that the user is familiar with the menu and plans to make a\n            // selection. Rather than toggle the panel, we focus on the menu (if one exists) and activate the first item for\n            // faster navigation.\n            if (['ArrowDown', 'ArrowUp', 'Home', 'End'].includes(event.key)) {\n                event.preventDefault();\n                // Show the menu if it's not already open\n                if (!this.open) {\n                    this.show();\n                    // Wait for the dropdown to open before focusing, but not the animation\n                    await this.updateComplete;\n                }\n                if (menuItems.length > 0) {\n                    // Focus on the first/last menu item after showing\n                    this.updateComplete.then(() => {\n                        if (event.key === 'ArrowDown' || event.key === 'Home') {\n                            menu.setCurrentItem(firstMenuItem);\n                            firstMenuItem.focus();\n                        }\n                        if (event.key === 'ArrowUp' || event.key === 'End') {\n                            menu.setCurrentItem(lastMenuItem);\n                            lastMenuItem.focus();\n                        }\n                    });\n                }\n            }\n        }\n    }\n    handleTriggerKeyUp(event) {\n        // Prevent space from triggering a click event in Firefox\n        if (event.key === ' ') {\n            event.preventDefault();\n        }\n    }\n    handleTriggerSlotChange() {\n        this.updateAccessibleTrigger();\n    }\n    //\n    // Slotted triggers can be arbitrary content, but we need to link them to the dropdown panel with `aria-haspopup` and\n    // `aria-expanded`. These must be applied to the \"accessible trigger\" (the tabbable portion of the trigger element\n    // that gets slotted in) so screen readers will understand them. The accessible trigger could be the slotted element,\n    // a child of the slotted element, or an element in the slotted element's shadow root.\n    //\n    // For example, the accessible trigger of an <koerber-button> is a <button> located inside its shadow root.\n    //\n    // To determine this, we assume the first tabbable element in the trigger slot is the \"accessible trigger.\"\n    //\n    updateAccessibleTrigger() {\n        const assignedElements = this.trigger.assignedElements({ flatten: true });\n        const accessibleTrigger = assignedElements.find(el => getTabbableBoundary(el).start);\n        let target;\n        if (accessibleTrigger) {\n            switch (accessibleTrigger.tagName.toLowerCase()) {\n                // Shoelace buttons have to update the internal button so it's announced correctly by screen readers\n                case 'koerber-button':\n                case 'koerber-icon-button':\n                    target = accessibleTrigger.button;\n                    break;\n                default:\n                    target = accessibleTrigger;\n            }\n            target.setAttribute('aria-haspopup', 'true');\n            target.setAttribute('aria-expanded', this.open ? 'true' : 'false');\n        }\n    }\n    /** Shows the dropdown panel. */\n    async show() {\n        if (this.open) {\n            return undefined;\n        }\n        this.open = true;\n        return waitForEvent(this, 'koerber-after-show');\n    }\n    /** Hides the dropdown panel */\n    async hide() {\n        if (!this.open) {\n            return undefined;\n        }\n        this.open = false;\n        return waitForEvent(this, 'koerber-after-hide');\n    }\n    /**\n     * Instructs the dropdown menu to reposition. Useful when the position or size of the trigger changes when the menu is activated.\n     */\n    reposition() {\n        this.popup.reposition();\n    }\n    addOpenListeners() {\n        this.panel.addEventListener('koerber-select', this.handlePanelSelect);\n        document.addEventListener('keydown', this.handleDocumentKeyDown);\n        document.addEventListener('mousedown', this.handleDocumentMouseDown);\n    }\n    removeOpenListeners() {\n        if (this.panel) {\n            this.panel.removeEventListener('koerber-select', this.handlePanelSelect);\n            this.panel.removeEventListener('keydown', this.handleKeyDown);\n        }\n        document.removeEventListener('keydown', this.handleDocumentKeyDown);\n        document.removeEventListener('mousedown', this.handleDocumentMouseDown);\n    }\n    async handleOpenChange() {\n        if (this.disabled) {\n            this.open = false;\n            return;\n        }\n        this.updateAccessibleTrigger();\n        if (this.open) {\n            // Show\n            this.emit('koerber-show');\n            this.addOpenListeners();\n            await stopAnimations(this);\n            this.panel.hidden = false;\n            this.popup.active = true;\n            const { keyframes, options } = getAnimation(this, 'dropdown.show', { dir: this.localize.dir() });\n            await animateTo(this.popup.popup, keyframes, options);\n            this.emit('koerber-after-show');\n        }\n        else {\n            // Hide\n            this.emit('koerber-hide');\n            this.removeOpenListeners();\n            await stopAnimations(this);\n            const { keyframes, options } = getAnimation(this, 'dropdown.hide', { dir: this.localize.dir() });\n            await animateTo(this.popup.popup, keyframes, options);\n            this.panel.hidden = true;\n            this.popup.active = false;\n            this.emit('koerber-after-hide');\n        }\n    }\n    render() {\n        return html `\r\n      <koerber-popup\r\n        part=\"base\"\r\n        id=\"dropdown\"\r\n        placement=${this.placement}\r\n        distance=${this.distance}\r\n        skidding=${this.skidding}\r\n        strategy=${this.hoist ? 'fixed' : 'absolute'}\r\n        flip\r\n        shift\r\n        auto-size=\"vertical\"\r\n        auto-size-padding=\"10\"\r\n        sync=${ifDefined(this.sync ? this.sync : undefined)}\r\n        class=${classMap({\n            dropdown: true,\n            'dropdown--open': this.open\n        })}\r\n      >\r\n        <slot\r\n          name=\"trigger\"\r\n          slot=\"anchor\"\r\n          part=\"trigger\"\r\n          class=\"dropdown__trigger\"\r\n          @click=${this.handleTriggerClick}\r\n          @keydown=${this.handleTriggerKeyDown}\r\n          @keyup=${this.handleTriggerKeyUp}\r\n          @slotchange=${this.handleTriggerSlotChange}\r\n        ></slot>\r\n\r\n        <div aria-hidden=${this.open ? 'false' : 'true'} aria-labelledby=\"dropdown\">\r\n          <slot part=\"panel\" class=\"dropdown__panel\" style=\"--width: ${this.buttonWidth}\"></slot>\r\n        </div>\r\n      </koerber-popup>\r\n    `;\n    }\n}\nDropdown.styles = [componentStyles, styles];\nexport default Dropdown;\n__decorate([\n    query('.dropdown')\n], Dropdown.prototype, \"popup\", void 0);\n__decorate([\n    query('.dropdown__trigger')\n], Dropdown.prototype, \"trigger\", void 0);\n__decorate([\n    query('.dropdown__panel')\n], Dropdown.prototype, \"panel\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Dropdown.prototype, \"open\", void 0);\n__decorate([\n    property({ reflect: true })\n], Dropdown.prototype, \"placement\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Dropdown.prototype, \"disabled\", void 0);\n__decorate([\n    property({ attribute: 'stay-open-on-select', type: Boolean, reflect: true })\n], Dropdown.prototype, \"stayOpenOnSelect\", void 0);\n__decorate([\n    property({ attribute: false })\n], Dropdown.prototype, \"containingElement\", void 0);\n__decorate([\n    property({ type: Number })\n], Dropdown.prototype, \"distance\", void 0);\n__decorate([\n    property({ type: Number })\n], Dropdown.prototype, \"skidding\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Dropdown.prototype, \"hoist\", void 0);\n__decorate([\n    property({ reflect: true })\n], Dropdown.prototype, \"sync\", void 0);\n__decorate([\n    watch('open', { waitUntilFirstUpdate: true })\n], Dropdown.prototype, \"handleOpenChange\", null);\nsetDefaultAnimation('dropdown.show', {\n    keyframes: [\n        { opacity: 0, scale: 0.9 },\n        { opacity: 1, scale: 1 }\n    ],\n    options: { duration: 100, easing: 'ease' }\n});\nsetDefaultAnimation('dropdown.hide', {\n    keyframes: [\n        { opacity: 1, scale: 1 },\n        { opacity: 0, scale: 0.9 }\n    ],\n    options: { duration: 100, easing: 'ease' }\n});\n","import { __decorate } from 'tslib';\nimport { customElement, property } from 'lit/decorators.js';\nimport { html } from 'lit';\nimport { requestInclude } from './request';\nimport { watch } from '../../internal/watch';\nimport UIKitElement from '../../internal/uikit-element';\nimport styles from './include.styles';\nlet Include = class SlInclude extends UIKitElement {\n  constructor(...args) {\n    super(...args);\n    this.mode = 'cors';\n    this.allowScripts = false;\n  }\n  executeScript(script) {\n    const newScript = document.createElement('script');\n    [...script.attributes].forEach(attr => newScript.setAttribute(attr.name, attr.value));\n    newScript.textContent = script.textContent;\n    script.parentNode.replaceChild(newScript, script);\n  }\n  async handleSrcChange() {\n    try {\n      const src = this.src;\n      const file = await requestInclude(src, this.mode);\n      if (src !== this.src) {\n        return;\n      }\n      if (!file.ok) {\n        this.emit('koerber-error', { detail: { status: file.status } });\n        return;\n      }\n      this.innerHTML = file.html;\n      if (this.allowScripts) {\n        [...this.querySelectorAll('script')].forEach(script => this.executeScript(script));\n      }\n      this.emit('koerber-load');\n    } catch (_a) {\n      this.emit('koerber-error', { detail: { status: -1 } });\n    }\n  }\n  render() {\n    return html`<slot></slot>`;\n  }\n};\nInclude.styles = styles;\n__decorate([property()], Include.prototype, 'src', void 0);\n__decorate([property()], Include.prototype, 'mode', void 0);\n__decorate([property({ attribute: 'allow-scripts', type: Boolean })], Include.prototype, 'allowScripts', void 0);\n__decorate([watch('src')], Include.prototype, 'handleSrcChange', null);\nInclude = __decorate([customElement('koerber-include')], Include);\nexport default Include;\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { classMap } from 'lit/directives/class-map.js';\nimport { html } from 'lit';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { property, query, state } from 'lit/decorators.js';\nimport { watch } from '../../internal/watch';\nimport componentStyles from '../../styles/component.styles';\nimport Icon from '../icon/icon.component';\nimport styles from './link.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Links are used as navigational elements.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net\n *\n * @dependency koerber-icon\n *\n * @event koerber-blur - Emitted when the link loses focus.\n * @event koerber-focus - Emitted when the link gains focus.\n *\n * @slot - The link's label.\n *\n * @csspart base - The component's base wrapper.\n * @csspart prefix - The container that wraps the prefix.\n * @csspart label - The button's label.\n * @csspart suffix - The container that wraps the suffix.\n * @csspart caret - The button's caret icon, an `<koerber-icon>` element.\n */\nclass Link extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.href = '';\n        /** Tells the browser where to open the link. Only used when `href` is set. */\n        this.target = '_blank';\n        /** The `rel` attribute to use on the link. Only used when `href` is set. */\n        this.rel = 'noreferrer noopener';\n        this.title = '';\n        /** The link's size. */\n        this.size = 'medium';\n        /** Disables the link. */\n        this.disabled = false;\n        this.underline = false;\n        /** Shows the Icon */\n        this.showIcon = false;\n        this.hasFocus = false;\n        this.handleHostClick = (event) => {\n            // Prevent the click event from being emitted when the link is disabled\n            if (this.disabled) {\n                event.preventDefault();\n                event.stopImmediatePropagation();\n            }\n        };\n    }\n    handleBlur() {\n        this.hasFocus = false;\n        this.emit('koerber-blur');\n    }\n    handleFocus() {\n        this.hasFocus = true;\n        this.emit('koerber-focus');\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.addEventListener('click', this.handleHostClick);\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this.removeEventListener('click', this.handleHostClick);\n    }\n    handleDisabledChange() {\n        this.setAttribute('aria-disabled', this.disabled ? 'true' : 'false');\n    }\n    /** Simulates a click on the link. */\n    click() {\n        this.link.click();\n    }\n    /** Sets focus on the link. */\n    focus(options) {\n        this.link.focus(options);\n    }\n    /** Removes focus from the link. */\n    blur() {\n        this.link.blur();\n    }\n    render() {\n        let iconContent;\n        if (this.showIcon) {\n            iconContent = html ` <div part=\"icon\" class=\"link__icon\" aria-hidden=\"true\">\n        <koerber-icon name=\"arrow-down\" size=${this.size}></koerber-icon>\n      </div>`;\n        }\n        return html `\n      <a\n        id=\"link\"\n        part=\"label\"\n        class=${classMap({\n            link: true,\n            'link--small': this.size === 'small',\n            'link--medium': this.size === 'medium',\n            'link--large': this.size === 'large',\n            'link--disabled': this.disabled,\n            'link--underline': this.underline,\n            'link--focused': this.hasFocus\n        })}\n        ?disabled=${this.disabled}\n        role=${ifDefined('link')}\n        aria-disabled=${this.disabled ? 'true' : 'false'}\n        tabindex=${this.disabled ? '-1' : '0'}\n        @blur=${this.handleBlur}\n        @focus=${this.handleFocus}\n        @click=${this.disabled ? undefined : this.handleHostClick}\n        href=\"${this.href}\"\n        target=\"${ifDefined(this.target ? this.target : undefined)}\"\n        rel=${ifDefined(this.target ? this.rel : undefined)}\n        title=${this.title}\n      >\n        <slot></slot>\n        ${iconContent}\n      </a>\n    `;\n    }\n}\nLink.styles = [componentStyles, styles];\nLink.dependencies = {\n    'koerber-icon': Icon\n};\nexport default Link;\n__decorate([\n    property({ type: String, reflect: true })\n], Link.prototype, \"href\", void 0);\n__decorate([\n    property({ reflect: true })\n], Link.prototype, \"target\", void 0);\n__decorate([\n    property()\n], Link.prototype, \"rel\", void 0);\n__decorate([\n    property({ type: String, reflect: true })\n], Link.prototype, \"title\", void 0);\n__decorate([\n    property({ reflect: true })\n], Link.prototype, \"size\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Link.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Link.prototype, \"underline\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Link.prototype, \"showIcon\", void 0);\n__decorate([\n    query('.link')\n], Link.prototype, \"link\", void 0);\n__decorate([\n    state()\n], Link.prototype, \"hasFocus\", void 0);\n__decorate([\n    watch('disabled')\n], Link.prototype, \"handleDisabledChange\", null);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { classMap } from 'lit/directives/class-map.js';\nimport { HasSlotController } from '../../internal/slot';\nimport { html } from 'lit/static-html.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { property, query, state } from 'lit/decorators.js';\nimport { watch } from '../../internal/watch';\nimport buttonStyles from '../button/button.styles';\nimport styles from './radio-button.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Radios buttons allow the user to select a single option from a group using a button-like control.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net\n * @status stable\n * @since 2.0\n *\n * @slot - The radio button's label.\n * @slot prefix - A presentational prefix icon or similar element.\n * @slot suffix - A presentational suffix icon or similar element.\n *\n * @event koerber-blur - Emitted when the button loses focus.\n * @event koerber-focus - Emitted when the button gains focus.\n *\n * @csspart base - The component's base wrapper.\n * @csspart button - The internal `<button>` element.\n * @csspart button--checked - The internal button element when the radio button is checked.\n * @csspart prefix - The container that wraps the prefix.\n * @csspart label - The container that wraps the radio button's label.\n * @csspart suffix - The container that wraps the suffix.\n */\nclass RadioButton extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.hasSlotController = new HasSlotController(this, '[default]', 'prefix', 'suffix');\n        this.hasFocus = false;\n        /**\n         * @internal The radio button's checked state. This is exposed as an \"internal\" attribute so we can reflect it, making\n         * it easier to style in button groups.\n         */\n        this.checked = false;\n        /** Disables the radio button. */\n        this.disabled = false;\n        /**\n         * The radio button's size. When used inside a radio group, the size will be determined by the radio group's size so\n         * this attribute can typically be omitted.\n         */\n        this.size = 'medium';\n        /** Indicates en error on the component */\n        this.error = false;\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.setAttribute('role', 'presentation');\n    }\n    handleBlur() {\n        this.hasFocus = false;\n        this.emit('koerber-blur');\n    }\n    handleClick(e) {\n        if (this.disabled) {\n            e.preventDefault();\n            e.stopPropagation();\n            return;\n        }\n        this.checked = true;\n    }\n    handleFocus() {\n        this.hasFocus = true;\n        this.emit('koerber-focus');\n    }\n    handleDisabledChange() {\n        this.setAttribute('aria-disabled', this.disabled ? 'true' : 'false');\n    }\n    /** Sets focus on the radio button. */\n    focus(options) {\n        this.input.focus(options);\n    }\n    /** Removes focus from the radio button. */\n    blur() {\n        this.input.blur();\n    }\n    render() {\n        const radioButtonContent = html `\r\n      ${this.hasSlotController.test('prefix')\n            ? html `<slot name=\"prefix\" part=\"prefix\" class=\"button__prefix\"></slot>`\n            : ''}\r\n      ${this.hasSlotController.test('[default]') ? html `<slot part=\"label\" class=\"button__label\"></slot>` : ''}\r\n      ${this.hasSlotController.test('suffix')\n            ? html `<slot name=\"suffix\" part=\"suffix\" class=\"button__suffix\"></slot>`\n            : ''}\r\n    `;\n        return html `\r\n      <div part=\"base\" role=\"presentation\">\r\n        <button\r\n          part=\"${`button${this.checked ? ' button--checked' : ''}`}\"\r\n          role=\"radio\"\r\n          aria-checked=\"${this.checked}\"\r\n          class=${classMap({\n            button: true,\n            'button--default': true,\n            'button--small': this.size === 'small',\n            'button--medium': this.size === 'medium',\n            'button--large': this.size === 'large',\n            'button--checked': this.checked,\n            'button--disabled': this.disabled,\n            'button--focused': this.hasFocus,\n            'button--has-label': this.hasSlotController.test('[default]'),\n            'button--has-prefix': this.hasSlotController.test('prefix'),\n            'button--has-suffix': this.hasSlotController.test('suffix')\n        })}\r\n          aria-disabled=${this.disabled}\r\n          type=\"button\"\r\n          value=${ifDefined(this.value)}\r\n          tabindex=\"${this.checked ? '0' : '-1'}\"\r\n          @blur=${this.handleBlur}\r\n          @focus=${this.handleFocus}\r\n          @click=${this.handleClick}\r\n        >\r\n          ${radioButtonContent}\r\n        </button>\r\n      </div>\r\n    `;\n    }\n}\nRadioButton.styles = [buttonStyles, styles];\nexport default RadioButton;\n__decorate([\n    query('.button')\n], RadioButton.prototype, \"input\", void 0);\n__decorate([\n    query('.hidden-input')\n], RadioButton.prototype, \"hiddenInput\", void 0);\n__decorate([\n    state()\n], RadioButton.prototype, \"hasFocus\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], RadioButton.prototype, \"checked\", void 0);\n__decorate([\n    property()\n], RadioButton.prototype, \"value\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], RadioButton.prototype, \"disabled\", void 0);\n__decorate([\n    property({ reflect: true })\n], RadioButton.prototype, \"size\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], RadioButton.prototype, \"error\", void 0);\n__decorate([\n    watch('disabled', { waitUntilFirstUpdate: true })\n], RadioButton.prototype, \"handleDisabledChange\", null);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\nimport { classMap } from 'lit/directives/class-map.js';\nimport { html } from 'lit';\nimport { property, query, state } from 'lit/decorators.js';\nimport { watch } from '../../internal/watch';\nimport ButtonGroup from '../button-group/button-group.component';\nimport componentStyles from '../../styles/component.styles';\nimport formControlStyles from '../../styles/form-control.styles';\nimport styles from './radio-group.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Radio groups are used to group multiple [radios](/components/radio) or [radio buttons](/components/radio-button) so they function as a single form control.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net\n * @status stable\n * @since 2.0\n *\n * @dependency koerber-button-group\n *\n * @slot - The default slot where `<koerber-radio>` or `<koerber-radio-button>` elements are placed.\n *  attribute.\n *\n * @event koerber-change - Emitted when the radio group's selected value changes.\n * @event koerber-input - Emitted when the radio group receives user input.\n *\n * @csspart button-group - The button group that wraps radio buttons.\n * @csspart button-group__base - The button group's `base` part.\n */\nclass RadioGroup extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.hasButtonGroup = false;\n        this.defaultValue = '';\n        /** The name of the radio group, submitted as a name/value pair with form data. */\n        this.name = 'option';\n        /** The current value of the radio group, submitted as a name/value pair with form data. */\n        this.value = '';\n        /** The radio group's size. This size will be applied to all child radios and radio buttons. */\n        this.size = 'medium';\n        /** Ensures a child radio is checked before allowing the containing form to submit. */\n        this.required = false;\n        /** set layout horizontal/vertical. */\n        this.horizontal = false;\n        /** Disables all child radio buttons. */\n        this.disabled = false;\n        /** Put the checked item to error state - indicating an error to the user. */\n        this.error = false;\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.defaultValue = this.value;\n    }\n    getAllRadios() {\n        return [...this.querySelectorAll('koerber-radio, koerber-radio-button')];\n    }\n    handleRadioClick(event) {\n        const target = event.target.closest('koerber-radio, koerber-radio-button');\n        const radios = this.getAllRadios();\n        const oldValue = this.value;\n        if (target.disabled) {\n            return;\n        }\n        this.value = target.value;\n        radios.forEach(radio => (radio.checked = radio === target));\n        if (this.value !== oldValue) {\n            this.emit('koerber-change');\n            this.emit('koerber-input');\n        }\n    }\n    handleKeyDown(event) {\n        var _a;\n        if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(event.key)) {\n            return;\n        }\n        const radios = this.getAllRadios().filter(radio => !radio.disabled);\n        const checkedRadio = (_a = radios.find(radio => radio.checked)) !== null && _a !== void 0 ? _a : radios[0];\n        const incr = event.key === ' ' ? 0 : ['ArrowUp', 'ArrowLeft'].includes(event.key) ? -1 : 1;\n        const oldValue = this.value;\n        let index = radios.indexOf(checkedRadio) + incr;\n        if (index < 0) {\n            index = radios.length - 1;\n        }\n        if (index > radios.length - 1) {\n            index = 0;\n        }\n        this.getAllRadios().forEach(radio => {\n            radio.checked = false;\n            if (!this.hasButtonGroup) {\n                radio.tabIndex = -1;\n            }\n        });\n        this.value = radios[index].value;\n        radios[index].checked = true;\n        if (!this.hasButtonGroup) {\n            radios[index].tabIndex = 0;\n            radios[index].focus();\n        }\n        else {\n            radios[index].shadowRoot.querySelector('button').focus();\n        }\n        if (this.value !== oldValue) {\n            this.emit('koerber-change');\n            this.emit('koerber-input');\n        }\n        event.preventDefault();\n    }\n    async syncRadioElements() {\n        var _a, _b;\n        const radios = this.getAllRadios();\n        await Promise.all(\n        // Sync the checked state and size\n        radios.map(async (radio) => {\n            await radio.updateComplete;\n            radio.checked = radio.value === this.value;\n            radio.size = this.size;\n        }));\n        this.hasButtonGroup = radios.some(radio => radio.tagName.toLowerCase() === 'koerber-radio-button');\n        if (!radios.some(radio => radio.checked)) {\n            if (this.hasButtonGroup) {\n                const buttonRadio = (_a = radios[0].shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('button');\n                if (buttonRadio) {\n                    buttonRadio.tabIndex = 0;\n                }\n            }\n            else {\n                radios[0].tabIndex = 0;\n            }\n        }\n        if (this.hasButtonGroup) {\n            const buttonGroup = (_b = this.shadowRoot) === null || _b === void 0 ? void 0 : _b.querySelector('koerber-button-group');\n            if (buttonGroup) {\n                buttonGroup.disableRole = true;\n            }\n        }\n    }\n    syncRadios() {\n        if (customElements.get('koerber-radio') && customElements.get('koerber-radio-button')) {\n            this.syncRadioElements();\n            return;\n        }\n        if (customElements.get('koerber-radio')) {\n            this.syncRadioElements();\n        }\n        else {\n            customElements.whenDefined('koerber-radio').then(() => this.syncRadios());\n        }\n        if (customElements.get('koerber-radio-button')) {\n            this.syncRadioElements();\n        }\n        else {\n            // Rerun this handler when <koerber-radio> or <koerber-radio-button> is registered\n            customElements.whenDefined('koerber-radio-button').then(() => this.syncRadios());\n        }\n    }\n    updateCheckedRadio() {\n        const radios = this.getAllRadios();\n        radios.forEach(radio => (radio.checked = radio.value === this.value));\n    }\n    handleSizeChange() {\n        this.syncRadios();\n    }\n    handleValueChange() {\n        if (this.hasUpdated) {\n            this.updateCheckedRadio();\n        }\n    }\n    handleDisabledChange() {\n        if (this.disabled) {\n            this.getAllRadios().forEach(radio => (radio.disabled = this.disabled));\n        }\n    }\n    handleErrorChange() {\n        if (this.error) {\n            this.getAllRadios().forEach(radio => {\n                radio.error = true;\n            });\n        }\n        else {\n            this.getAllRadios().forEach(radio => {\n                radio.error = false;\n            });\n        }\n    }\n    focus() {\n        const radios = this.getAllRadios();\n        const checked = radios.find(radio => radio.checked);\n        const radioToFocus = checked || radios[0];\n        // Move focus to the checked radio (or the first one if none are checked) when clicking the label\n        if (radioToFocus) {\n            radioToFocus.focus();\n        }\n    }\n    blur() {\n        const radios = this.getAllRadios();\n        radios.forEach(radio => radio.blur());\n    }\n    render() {\n        const defaultSlot = html `\r\n      <slot\r\n        @click=${this.handleRadioClick}\r\n        @keydown=${this.handleKeyDown}\r\n        @slotchange=${this.syncRadios}\r\n        role=\"presentation\"\r\n      ></slot>\r\n    `;\n        return html `\r\n      <fieldset\r\n        part=\"form-control\"\r\n        class=${classMap({\n            'form-control': true,\n            'form-control--small': this.size === 'small',\n            'form-control--medium': this.size === 'medium',\n            'form-control--large': this.size === 'large',\n            'form-control--radio-group': true\n        })}\r\n        role=\"radiogroup\"\r\n      >\r\n        <div\r\n          part=\"form-control-input\"\r\n          class=${classMap({\n            'form-control-input': true,\n            'radio-group--horizontal': this.horizontal\n        })}\r\n        >\r\n          ${this.hasButtonGroup\n            ? html `\r\n                <koerber-button-group part=\"button-group\" exportparts=\"base:button-group__base\">\r\n                  ${defaultSlot}\r\n                </koerber-button-group>\r\n              `\n            : defaultSlot}\r\n        </div>\r\n      </fieldset>\r\n    `;\n        /* eslint-enable lit-a11y/click-events-have-key-events */\n    }\n}\nRadioGroup.styles = [componentStyles, formControlStyles, styles];\nRadioGroup.dependencies = { 'koerber-button-group': ButtonGroup };\nexport default RadioGroup;\n__decorate([\n    query('slot:not([name])')\n], RadioGroup.prototype, \"defaultSlot\", void 0);\n__decorate([\n    state()\n], RadioGroup.prototype, \"hasButtonGroup\", void 0);\n__decorate([\n    state()\n], RadioGroup.prototype, \"defaultValue\", void 0);\n__decorate([\n    property()\n], RadioGroup.prototype, \"name\", void 0);\n__decorate([\n    property({ reflect: true })\n], RadioGroup.prototype, \"value\", void 0);\n__decorate([\n    property({ reflect: true })\n], RadioGroup.prototype, \"size\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], RadioGroup.prototype, \"required\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], RadioGroup.prototype, \"horizontal\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], RadioGroup.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], RadioGroup.prototype, \"error\", void 0);\n__decorate([\n    watch('size', { waitUntilFirstUpdate: true })\n], RadioGroup.prototype, \"handleSizeChange\", null);\n__decorate([\n    watch('value')\n], RadioGroup.prototype, \"handleValueChange\", null);\n__decorate([\n    watch('disabled')\n], RadioGroup.prototype, \"handleDisabledChange\", null);\n__decorate([\n    watch('error')\n], RadioGroup.prototype, \"handleErrorChange\", null);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { classMap } from 'lit/directives/class-map.js';\nimport { html } from 'lit';\nimport { property, state } from 'lit/decorators.js';\nimport { watch } from '../../internal/watch';\nimport componentStyles from '../../styles/component.styles';\nimport Icon from '../icon/icon.component';\nimport styles from './radio.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Radios allow the user to select a single option from a group.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net\n * @status stable\n * @since 2.0\n *\n * @dependency koerber-icon\n *\n * @slot - The radio's label.\n *\n * @event koerber-blur - Emitted when the control loses focus.\n * @event koerber-focus - Emitted when the control gains focus.\n * @event koerber-input - Emitted when the control receives user input.\n * @event koerber-change - Emitted when the control's checked state changes.\n *\n * @csspart base - The component's base wrapper.\n * @csspart control - The circular container that wraps the radio's checked state.\n * @csspart control--checked - The radio control when the radio is checked.\n * @csspart checked-icon - The checked icon, an `<koerber-icon>` element.\n * @csspart label - The container that wraps the radio's label.\n */\nclass Radio extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.checked = false;\n        this.hasFocus = false;\n        /**\n         * The radio's size. When used inside a radio group, the size will be determined by the radio group's size so this\n         * attribute can typically be omitted.\n         */\n        this.size = 'standard';\n        /** Disables the radio. */\n        this.disabled = false;\n        this.error = false;\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.handleBlur = this.handleBlur.bind(this);\n        this.handleClick = this.handleClick.bind(this);\n        this.handleFocus = this.handleFocus.bind(this);\n        this.setInitialAttributes();\n        this.addEventListeners();\n    }\n    disconnectedCallback() {\n        this.removeEventListeners();\n    }\n    addEventListeners() {\n        this.addEventListener('blur', this.handleBlur);\n        this.addEventListener('click', this.handleClick);\n        this.addEventListener('focus', this.handleFocus);\n    }\n    removeEventListeners() {\n        this.removeEventListener('blur', this.handleBlur);\n        this.removeEventListener('click', this.handleClick);\n        this.removeEventListener('focus', this.handleFocus);\n    }\n    handleClick() {\n        var _a;\n        if (!this.disabled) {\n            const parentElementName = (_a = this.parentElement) === null || _a === void 0 ? void 0 : _a.tagName.toLowerCase();\n            if (parentElementName === 'koerber-radio-group') {\n                return;\n            }\n            if (!this.checked) {\n                this.emit('koerber-input');\n                this.emit('koerber-change');\n            }\n            this.checked = true;\n        }\n    }\n    handleBlur() {\n        this.hasFocus = false;\n        this.emit('koerber-blur');\n    }\n    handleFocus() {\n        this.hasFocus = true;\n        this.emit('koerber-focus');\n    }\n    setInitialAttributes() {\n        this.setAttribute('role', 'radio');\n        this.setAttribute('tabindex', '-1');\n        this.setAttribute('aria-disabled', this.disabled ? 'true' : 'false');\n        if (this.accessibleName) {\n            this.setAttribute('aria-label', this.accessibleName);\n        }\n        if (this.accessibleDescription) {\n            this.setAttribute('aria-description', this.accessibleDescription);\n        }\n    }\n    handleCheckedChange() {\n        this.setAttribute('aria-checked', this.checked ? 'true' : 'false');\n        this.setAttribute('tabindex', this.checked ? '0' : '-1');\n    }\n    handleDisabledChange() {\n        this.setAttribute('aria-disabled', this.disabled ? 'true' : 'false');\n    }\n    render() {\n        return html `\r\n      <span\r\n        part=\"base\"\r\n        class=${classMap({\n            radio: true,\n            'radio--checked': this.checked,\n            'radio--disabled': this.disabled,\n            'radio--error': this.error,\n            'radio--focused': this.hasFocus,\n            'radio--standard': this.size === 'standard',\n            'radio--comfortable': this.size === 'comfortable'\n        })}\r\n      >\r\n        <span part=\"${`control${this.checked ? ' control--checked' : ''}`}\" class=\"radio__control\">\r\n          ${this.checked\n            ? html `\r\n                <koerber-icon\r\n                  part=\"checked-icon\"\r\n                  size=\"medium\"\r\n                  class=${classMap({\n                'radio__checked-icon': true,\n                'icon--medium': true\n            })}\r\n                  library=\"system\"\r\n                  name=\"circle\"\r\n                ></koerber-icon>\r\n              `\n            : ''}\r\n        </span>\r\n\r\n        <slot part=\"label\" class=\"radio__label\">\r\n          <koerber-form-field-label label=\"${this.label}\"></koerber-form-field-label>\r\n        </slot>\r\n      </span>\r\n    `;\n    }\n}\nRadio.styles = [componentStyles, styles];\nRadio.dependencies = { 'koerber-icon': Icon };\nexport default Radio;\n__decorate([\n    state()\n], Radio.prototype, \"checked\", void 0);\n__decorate([\n    state()\n], Radio.prototype, \"hasFocus\", void 0);\n__decorate([\n    property()\n], Radio.prototype, \"value\", void 0);\n__decorate([\n    property()\n], Radio.prototype, \"label\", void 0);\n__decorate([\n    property({ reflect: true })\n], Radio.prototype, \"size\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Radio.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Radio.prototype, \"error\", void 0);\n__decorate([\n    property({ attribute: 'accessible-name', reflect: true })\n], Radio.prototype, \"accessibleName\", void 0);\n__decorate([\n    property({ attribute: 'accessible-description', reflect: true })\n], Radio.prototype, \"accessibleDescription\", void 0);\n__decorate([\n    watch('checked')\n], Radio.prototype, \"handleCheckedChange\", null);\n__decorate([\n    watch('disabled', { waitUntilFirstUpdate: true })\n], Radio.prototype, \"handleDisabledChange\", null);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { classMap } from 'lit/directives/class-map.js';\nimport { html } from 'lit';\nimport { LocalizeController } from '../../utilities/localize';\nimport { property, query, state } from 'lit/decorators.js';\nimport { watch } from '../../internal/watch';\nimport componentStyles from '../../styles/component.styles';\nimport styles from './search-option.styles';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Search Options define the selectable options within the Search Component.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-search-option--docs\n * @status stable\n * @since 2.0\n *\n * @slot - The search option's label.\n * @slot suffix - Used to append an icon or similar element to the search option.\n *\n * @csspart base - The component's base wrapper.\n * @csspart label - The search option's label.\n * @csspart prefix - The container that wraps the prefix.\n * @csspart suffix - The container that wraps the suffix.\n */\nclass SearchOption extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        // @ts-expect-error - Controller is currently unused\n        this.localize = new LocalizeController(this);\n        this.current = false; // the user has keyed into the search-option, but hasn't selected it yet (shows a highlight)\n        this.selected = false; // the search-option is selected and has aria-selected=\"true\"\n        this.hasHover = false; // we need this because Safari doesn't honor :hover styles while dragging\n        /**\n         * The search-option's value. When selected, the containing form control will receive this value. The value must be unique\n         * from other search-options in the same group.\n         */\n        this.value = '';\n        /** Draws the search-option in a disabled state, preventing selection. */\n        this.disabled = false;\n        this.size = 'medium';\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.setAttribute('role', 'option');\n        this.setAttribute('aria-selected', 'false');\n    }\n    handleMouseEnter() {\n        this.hasHover = true;\n    }\n    handleMouseLeave() {\n        this.hasHover = false;\n    }\n    handleDisabledChange() {\n        this.setAttribute('aria-disabled', this.disabled ? 'true' : 'false');\n    }\n    handleSelectedChange() {\n        this.setAttribute('aria-selected', this.selected ? 'true' : 'false');\n    }\n    handleValueChange() {\n        // Ensure the value is a string. This ensures the next line doesn't error and allows framework users to pass numbers\n        // instead of requiring them to cast the value to a string.\n        if (typeof this.value !== 'string') {\n            this.value = String(this.value);\n        }\n        if (this.value.includes(' ')) {\n            // For now we will allow spaces - only we are going to send a console warning\n            console.warn(`search-option values preferably should not include spaces.`, this);\n            // For now we will allow spaces\n            // this.value = this.value.replace(/ /g, '_');\n        }\n    }\n    /** Returns a plain text label based on the search-option's content. */\n    getTextLabel() {\n        const nodes = this.childNodes;\n        let label = '';\n        [...nodes].forEach(node => {\n            if (node.nodeType === Node.ELEMENT_NODE) {\n                if (!node.hasAttribute('slot')) {\n                    label += node.textContent;\n                }\n            }\n            if (node.nodeType === Node.TEXT_NODE) {\n                label += node.textContent;\n            }\n        });\n        return label.trim();\n    }\n    render() {\n        return html `\r\n      <div\r\n        part=\"base\"\r\n        class=${classMap({\n            'search-option': true,\n            'search-option--current': this.current,\n            'search-option--disabled': this.disabled,\n            'search-option--selected': this.selected,\n            'search-option--hover': this.hasHover,\n            [`search-option--${this.size}`]: true\n        })}\r\n        @mouseenter=${this.handleMouseEnter}\r\n        @mouseleave=${this.handleMouseLeave}\r\n      >\r\n        <!-- Hide prefix slot instead of removing it entirely -->\r\n        <!-- <slot part=\"prefix\" name=\"prefix\" class=\"search-option__prefix\"></slot> -->\r\n        <span part=\"label\" class=\"search-option__label\">${this.value}</span>\r\n        <slot part=\"suffix\" name=\"suffix\" class=\"search-option__suffix\"></slot>\r\n      </div>\r\n    `;\n    }\n}\nSearchOption.styles = [componentStyles, styles];\nexport default SearchOption;\n__decorate([\n    query('.search-option__label')\n], SearchOption.prototype, \"defaultSlot\", void 0);\n__decorate([\n    state()\n], SearchOption.prototype, \"current\", void 0);\n__decorate([\n    state()\n], SearchOption.prototype, \"selected\", void 0);\n__decorate([\n    state()\n], SearchOption.prototype, \"hasHover\", void 0);\n__decorate([\n    property({ reflect: true })\n], SearchOption.prototype, \"value\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], SearchOption.prototype, \"disabled\", void 0);\n__decorate([\n    property({ reflect: true })\n], SearchOption.prototype, \"size\", void 0);\n__decorate([\n    watch('disabled')\n], SearchOption.prototype, \"handleDisabledChange\", null);\n__decorate([\n    watch('selected')\n], SearchOption.prototype, \"handleSelectedChange\", null);\n__decorate([\n    watch('value')\n], SearchOption.prototype, \"handleValueChange\", null);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/** Exception due eslint doesn't support WAI-ARIA 1.3 that supports aria-description attr */\n/* eslint-disable lit-a11y/aria-attrs */\nimport { animateTo, stopAnimations } from '../../internal/animate';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { defaultValue } from '../../internal/default-value';\nimport { getAnimation, setDefaultAnimation } from '../../utilities/animation-registry';\nimport { html } from 'lit';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { live } from 'lit/directives/live.js';\nimport { LocalizeController } from '../../utilities/localize';\nimport { property, query, state } from 'lit/decorators.js';\nimport { scrollIntoView } from '../../internal/scroll';\nimport { waitForEvent } from '../../internal/event';\nimport { watch } from '../../internal/watch';\nimport componentStyles from '../../styles/component.styles';\nimport formControlStyles from '../../styles/form-control.styles';\nimport Icon from '../icon/icon.component';\nimport Popup from '../popup/popup.component';\nimport Spinner from '../spinner/spinner.component';\nimport styles from './search.styles';\nimport Tag from '../tag/tag.component';\nimport UIKitElement from '../../internal/uikit-element';\n/**\n * @summary Search allow you to choose items from a menu of predefined options.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-search--docs\n * @status stable\n * @since 2.0\n *\n * @dependency koerber-icon\n * @dependency koerber-popup\n * @dependency koerber-tag\n *\n * @slot - The listbox options. Must be `<koerber-search-option>` elements.\n * @slot prefix - Used to prepend a presentational icon or similar element to the combobox.\n * @slot clear-icon - An icon to use in lieu of the default clear icon.\n * @slot search-icon - The icon to show when the control is expanded and collapsed. Rotates on open and close.\n *\n * @event koerber-change - Emitted when the control's value changes.\n * @event koerber-clear - Emitted when the control's value is cleared.\n * @event koerber-input - Emitted when the control receives input.\n * @event koerber-focus - Emitted when the control gains focus.\n * @event koerber-blur - Emitted when the control loses focus.\n * @event koerber-show - Emitted when the search's menu opens.\n * @event koerber-after-show - Emitted after the search's menu opens and all animations are complete.\n * @event koerber-hide - Emitted when the search's menu closes.\n * @event koerber-after-hide - Emitted after the search's menu closes and all animations are complete.\n *\n * @csspart combobox - The container the wraps the prefix, combobox, clear icon, and expand button.\n * @csspart prefix - The container that wraps the prefix slot.\n * @csspart display-input - The element that displays the selected option's label, an `<input>` element.\n * @csspart listbox - The listbox container where options are slotted.\n * @csspart tag__base - The tag's base part.\n * @csspart tag__content - The tag's content part.\n * @csspart tag__remove-button - The tag's remove button.\n * @csspart tag__remove-button__base - The tag's remove button base part.\n * @csspart search-button - The search button or clear it depends.\n * @csspart search__icon - The container that wraps the expand icon.\n * @csspart form-control-error-message - The error's message wrapper.\n */\nclass Search extends UIKitElement {\n    constructor() {\n        super(...arguments);\n        this.localize = new LocalizeController(this);\n        this.hasFocus = false;\n        this.selectedOptions = [];\n        this.minLengthMessage = '';\n        this.searchResults = 0;\n        /** The name of the search, submitted as a name/value pair with form data. */\n        this.name = '';\n        /**\n         * The current value of the search, submitted as a name/value pair with form data.\n         */\n        this.value = '';\n        /** The default value of the form control. Primarily used for resetting the form control. */\n        this.defaultValue = '';\n        /** Placeholder text to show as a hint when the search is empty. */\n        this.placeholder = '';\n        /** The search's size. */\n        this.size = 'medium';\n        /** Adds a loader/spinner in the suffix of the search control */\n        this.loading = false;\n        /** Displays loading message when loading flag set to true */\n        this.loadingMessage = 'Disabled while loading';\n        /**\n         * Sets the maximum height for the dropdown box before the scrollbar appears.\n         */\n        this.maxHeight = 0;\n        /** Sets the minimum length of the search input before the search is triggered., zero by default (deactivated) */\n        this.minLength = 0;\n        /** Disables the search control. */\n        this.disabled = false;\n        /**\n         * Indicates whether or not the search is open. You can toggle this attribute to show and hide the menu, or you can\n         * use the `show()` and `hide()` methods and this attribute will reflect the search's open state.\n         */\n        this.open = false;\n        /**\n         * Enable this option to prevent the listbox from being clipped when the component is placed inside a container with\n         * `overflow: auto|scroll`. Hoisting uses a fixed positioning strategy that works in many, but not all, scenarios.\n         */\n        this.hoist = false;\n        /**\n         * The preferred placement of the search's menu. Note that the actual placement may vary as needed to keep the listbox\n         * inside of the viewport.\n         */\n        this.placement = 'bottom';\n        /** The search's required attribute. */\n        this.required = false;\n        /**\n         * Used to indicate that the input has some error based on some rule.\n         */\n        this.error = false;\n        this.handleDocumentFocusIn = (event) => {\n            // Close when focusing out of the search\n            const path = event.composedPath();\n            if (this && !path.includes(this)) {\n                this.hide();\n            }\n        };\n        this.handleDocumentKeyDown = (event) => {\n            // Close when pressing escape\n            if (event.key === 'Escape' && this.open) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.hide();\n                this.displayInput.focus({ preventScroll: true });\n            }\n            // Handle enter and space. When pressing space, we allow for type to search behaviors so if there's anything in the\n            // buffer we _don't_ close it.\n            if (event.key === 'Enter') {\n                event.preventDefault();\n                event.stopImmediatePropagation();\n                // If it's not open, open it\n                if (!this.open) {\n                    this.show();\n                    return;\n                }\n                // If it is open, update the value based on the current selection and close it\n                if (this.currentOption && !this.currentOption.disabled) {\n                    this.setSelectedOptions(this.currentOption);\n                    // Emit after updating\n                    this.updateComplete.then(() => {\n                        this.emit('koerber-input');\n                        this.emit('koerber-change');\n                    });\n                    this.hide();\n                    this.displayInput.focus({ preventScroll: true });\n                }\n                return;\n            }\n            // Navigate options\n            if (['ArrowUp', 'ArrowDown', 'Home', 'End'].includes(event.key)) {\n                const allOptions = this.getAllOptions();\n                const currentIndex = allOptions.indexOf(this.currentOption);\n                let newIndex = Math.max(0, currentIndex);\n                // Prevent scrolling\n                event.preventDefault();\n                // Open it\n                if (!this.open) {\n                    this.show();\n                    // If an option is already selected, stop here because we want that one to remain highlighted when the listbox\n                    // opens for the first time\n                    if (this.currentOption) {\n                        return;\n                    }\n                }\n                if (event.key === 'ArrowDown') {\n                    newIndex = currentIndex + 1;\n                    if (newIndex > allOptions.length - 1)\n                        newIndex = 0;\n                }\n                else if (event.key === 'ArrowUp') {\n                    newIndex = currentIndex - 1;\n                    if (newIndex < 0)\n                        newIndex = allOptions.length - 1;\n                }\n                else if (event.key === 'Home') {\n                    newIndex = 0;\n                }\n                else if (event.key === 'End') {\n                    newIndex = allOptions.length - 1;\n                }\n                this.setCurrentOption(allOptions[newIndex]);\n            }\n            // All other \"printable\" keys trigger type to search\n            if (event.key.length === 1 || event.key === 'Backspace') {\n                // Don't block important key combos like CMD+R\n                if (event.metaKey || event.ctrlKey || event.altKey) {\n                    return;\n                }\n                // Open, unless the key that triggered is backspace\n                if (!this.open) {\n                    if (event.key === 'Backspace') {\n                        return;\n                    }\n                    this.show();\n                }\n                // When search has empty value, no searches should be displayed\n                if (event.key === 'Backspace' && this.value.length === 0) {\n                    this.hide();\n                }\n                this.setCurrentOption(this.currentOption);\n                if (this.currentOption) {\n                    scrollIntoView(this.currentOption, this.listbox, 'vertical', 'auto');\n                }\n            }\n        };\n        this.handleDocumentMouseDown = (event) => {\n            // Close when clicking outside of the search\n            const path = event.composedPath();\n            if (this && !path.includes(this)) {\n                this.hide();\n            }\n        };\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        // Because this is a form control, it shouldn't be opened initially\n        this.open = false;\n    }\n    firstUpdated() {\n        // We need to check if items are provided at the beginning\n        this.handleDefaultSlotChange();\n    }\n    addOpenListeners() {\n        document.addEventListener('focusin', this.handleDocumentFocusIn);\n        document.addEventListener('keydown', this.handleDocumentKeyDown);\n        document.addEventListener('mousedown', this.handleDocumentMouseDown);\n    }\n    removeOpenListeners() {\n        document.removeEventListener('focusin', this.handleDocumentFocusIn);\n        document.removeEventListener('keydown', this.handleDocumentKeyDown);\n        document.removeEventListener('mousedown', this.handleDocumentMouseDown);\n    }\n    async handleAnimations(previousValue) {\n        // Add animations when label input changes - we need in both since icons get rendered every time the input changes\n        const { keyframes, options } = getAnimation(this, 'search.icon.show', { dir: this.localize.dir() });\n        if (previousValue.length === 0 && this.value.length > 0) {\n            await animateTo(this.searchButton, keyframes, options);\n        }\n        else if (this.value.length === 0) {\n            await animateTo(this.searchButton, keyframes, options);\n        }\n    }\n    handleInput() {\n        const previousValue = this.value;\n        this.value = this.displayInput.value;\n        this.handleAnimations(previousValue);\n        if (this.value.length >= this.minLength) {\n            this.emit('koerber-change');\n        }\n        this.emit('koerber-input');\n    }\n    handleChange() {\n        const previousValue = this.value;\n        this.value = this.displayInput.value;\n        this.handleAnimations(previousValue);\n        this.emit('koerber-change');\n    }\n    handleFocus() {\n        this.hasFocus = true;\n        this.emit('koerber-focus');\n    }\n    handleBlur() {\n        this.hasFocus = false;\n        this.emit('koerber-blur');\n    }\n    handleComboboxClick(event) {\n        const path = event.composedPath();\n        const isIconButton = path.some(el => el instanceof Element && el.tagName.toLowerCase() === 'koerber-icon-button');\n        // Ignore disabled controls, clicks on tags (remove buttons) and empty values\n        if (this.disabled || isIconButton || this.value.length === 0) {\n            return;\n        }\n        event.preventDefault();\n        if (!this.open) {\n            this.show();\n        }\n        this.displayInput.focus({ preventScroll: true });\n    }\n    handleComboboxKeyDown(event) {\n        event.stopPropagation();\n        // Wait for keyboard rendered is done and value updated\n        requestAnimationFrame(() => {\n            this.handleDocumentKeyDown(event);\n        });\n    }\n    handleClearClick(event) {\n        event.stopPropagation();\n        this.value = '';\n        this.displayInput.focus({ preventScroll: true });\n        this.hide();\n        // Emit after update\n        this.updateComplete.then(() => {\n            this.emit('koerber-clear');\n            this.emit('koerber-input');\n            this.emit('koerber-change');\n        });\n    }\n    handleClearMouseDown(event) {\n        // Don't lose focus or propagate events when clicking the clear button\n        event.stopPropagation();\n        event.preventDefault();\n    }\n    handleOptionClick(event) {\n        const target = event.target;\n        const option = target.closest('koerber-search-option');\n        const oldValue = this.value;\n        if (option && !option.disabled) {\n            this.setSelectedOptions(option);\n            // Set focus after updating so the value is announced by screen readers\n            this.updateComplete.then(() => this.displayInput.focus({ preventScroll: true }));\n            if (this.value !== oldValue) {\n                // Emit after updating\n                this.updateComplete.then(() => {\n                    this.emit('koerber-input');\n                    this.emit('koerber-change');\n                });\n            }\n            this.hide();\n            this.displayInput.focus({ preventScroll: true });\n        }\n    }\n    handleDefaultSlotChange() {\n        const allOptions = this.getAllOptions();\n        this.searchResults = allOptions.length;\n    }\n    // Gets an array of all <koerber-search-option> elements\n    getAllOptions() {\n        return [...this.querySelectorAll('koerber-search-option')];\n    }\n    // Gets the first <koerber-search-option> element\n    getFirstOption() {\n        return this.querySelector('koerber-search-option');\n    }\n    // Sets the current option, which is the option the user is currently interacting with (e.g. via keyboard). Only one\n    // option may be \"current\" at a time.\n    setCurrentOption(option) {\n        const allOptions = this.getAllOptions();\n        // Clear selection\n        allOptions.forEach(el => {\n            el.current = false;\n            el.tabIndex = -1;\n        });\n        // Select the target option\n        if (option) {\n            this.currentOption = option;\n            option.current = true;\n            option.tabIndex = 0;\n        }\n    }\n    // Sets the selected option(s)\n    setSelectedOptions(option) {\n        const allOptions = this.getAllOptions();\n        const newSelectedOptions = [option];\n        // Clear existing selection\n        allOptions.forEach(el => (el.selected = false));\n        // Set the new selection\n        if (newSelectedOptions.length) {\n            newSelectedOptions.forEach(el => (el.selected = true));\n        }\n        // Update selection, value, and display label\n        this.selectionChanged();\n    }\n    // This method must be called whenever the selection changes. It will update the selected options cache, the current\n    // value, and the display value\n    selectionChanged() {\n        // Update selected options cache\n        this.selectedOptions = this.getAllOptions().filter(el => el.selected);\n        // Update the value and display label\n        this.value = this.selectedOptions[0].value;\n    }\n    async updateMessage() {\n        await this.updateComplete;\n        if (this.searchResults <= 0) {\n            this.minLengthMessage = 'No Results';\n        }\n        if (this.value.length < this.minLength) {\n            this.minLengthMessage = `No Results - Minimum Characters Required: ${this.minLength}`;\n        }\n    }\n    async syncOptions() {\n        const options = this.getAllOptions();\n        await Promise.all(\n        // Sync the checked state and size\n        options.map(async (option) => {\n            option.size = this.size;\n            await option.updateComplete;\n        }));\n    }\n    handleSizeChange() {\n        this.syncOptions();\n    }\n    handleDisabledChange() {\n        // Close the listbox when the control is disabled\n        if (this.disabled) {\n            this.open = false;\n            this.handleOpenChange();\n        }\n    }\n    handleValueChange() {\n        // This to ensure if a no-result message is needed\n        this.updateMessage();\n    }\n    handleMinLengthChange() {\n        this.updateMessage();\n    }\n    async handleOpenChange() {\n        if (this.open && !this.disabled && !this.loading) {\n            // Set the maximum height of the dropdown box\n            if (this.maxHeight > 0) {\n                this.listbox.style.setProperty('max-height', `${this.maxHeight}px`);\n            }\n            this.handleSizeChange();\n            // Reset the current option\n            this.setCurrentOption(this.selectedOptions[0] || this.getFirstOption());\n            // Show\n            this.emit('koerber-show');\n            this.addOpenListeners();\n            await stopAnimations(this);\n            this.listbox.hidden = false;\n            this.popup.active = true;\n            // Select the appropriate option based on value after the listbox opens\n            requestAnimationFrame(() => {\n                this.setCurrentOption(this.currentOption);\n            });\n            const { keyframes, options } = getAnimation(this, 'search.show', { dir: this.localize.dir() });\n            await animateTo(this.popup.popup, keyframes, options);\n            // Make sure the current option is scrolled into view (required for Safari)\n            if (this.currentOption) {\n                scrollIntoView(this.currentOption, this.listbox, 'vertical', 'auto');\n            }\n            this.emit('koerber-after-show');\n            this.displayInput.focus({ preventScroll: true });\n        }\n        else {\n            // Hide\n            this.emit('koerber-hide');\n            this.removeOpenListeners();\n            await stopAnimations(this);\n            const { keyframes, options } = getAnimation(this, 'search.hide', { dir: this.localize.dir() });\n            await animateTo(this.popup.popup, keyframes, options);\n            this.listbox.hidden = true;\n            this.popup.active = false;\n            this.emit('koerber-after-hide');\n        }\n    }\n    /** Shows the listbox. */\n    async show() {\n        if (this.open || this.disabled || this.loading) {\n            return undefined;\n        }\n        this.open = true;\n        return waitForEvent(this, 'koerber-after-show');\n    }\n    /** Hides the listbox. */\n    async hide() {\n        if (!this.open || this.disabled || this.loading) {\n            return undefined;\n        }\n        this.open = false;\n        return waitForEvent(this, 'koerber-after-hide');\n    }\n    /** Sets focus on the control. */\n    focus(options) {\n        this.displayInput.focus(options);\n    }\n    /** Removes focus from the control. */\n    blur() {\n        this.displayInput.blur();\n    }\n    render() {\n        const isResultEmpty = this.minLength > this.value.length || this.searchResults <= 0;\n        const noResultHTML = html `\r\n      <div class=\"search__listbox-min-length\">\r\n        <koerber-icon name=\"alert-circle\"></koerber-icon>\r\n        <span class=\"message\">${this.minLengthMessage}</span>\r\n      </div>\r\n    `;\n        return html `\r\n      <div\r\n        part=\"form-control\"\r\n        class=${classMap({\n            'form-control': true,\n            'form-control--small': this.size === 'small',\n            'form-control--medium': this.size === 'medium',\n            'form-control--large': this.size === 'large',\n            'form-control__label--disabled': this.disabled\n        })}\r\n      >\r\n        <div part=\"form-control-input\" class=\"form-control-input\">\r\n          <koerber-popup\r\n            class=${classMap({\n            search: true,\n            'search--standard': true,\n            'search--open': this.open && !this.loading,\n            'search--disabled': this.disabled,\n            'search--focused': this.hasFocus,\n            'search--placeholder': this.value.length === 0,\n            'search--top': this.placement === 'top',\n            'search--bottom': this.placement === 'bottom',\n            'search--small': this.size === 'small',\n            'search--medium': this.size === 'medium',\n            'search--large': this.size === 'large',\n            'search--loading': this.loading,\n            'search--error': this.error\n        })}\r\n            placement=${this.placement}\r\n            strategy=${this.hoist ? 'fixed' : 'absolute'}\r\n            flip\r\n            shift\r\n            sync=\"width\"\r\n            auto-size=\"vertical\"\r\n            auto-size-padding=\"10\"\r\n          >\r\n            <div\r\n              part=\"combobox\"\r\n              class=\"search__combobox\"\r\n              slot=\"anchor\"\r\n              @keydown=${this.handleComboboxKeyDown}\r\n              @click=${this.handleComboboxClick}\r\n            >\r\n              <slot part=\"prefix\" name=\"prefix\" class=\"search__prefix\"></slot>\r\n\r\n              <input\r\n                part=\"display-input\"\r\n                class=${classMap({\n            'search__display-input': true,\n            'search--small': this.size === 'small',\n            'search--medium': this.size === 'medium',\n            'search--large': this.size === 'large'\n        })}\r\n                type=\"text\"\r\n                placeholder=${this.placeholder}\r\n                .disabled=${this.disabled || this.loading}\r\n                .value=${live(this.value)}\r\n                autocomplete=\"off\"\r\n                spellcheck=\"false\"\r\n                autocapitalize=\"off\"\r\n                aria-label=${ifDefined(this.accessibleName)}\r\n                aria-description=${ifDefined(this.accessibleDescription)}\r\n                aria-controls=\"listbox\"\r\n                aria-expanded=${this.open ? 'true' : 'false'}\r\n                aria-haspopup=\"listbox\"\r\n                aria-labelledby=\"label\"\r\n                aria-disabled=${this.disabled || this.loading}\r\n                role=\"combobox\"\r\n                tabindex=\"0\"\r\n                @input=${this.handleInput}\r\n                @change=${this.handleChange}\r\n                @focus=${this.handleFocus}\r\n                @blur=${this.handleBlur}\r\n              />\r\n\r\n              <slot name=\"search-icon\" part=\"search__icon\" class=\"search__icon\">\r\n                ${this.value && this.value.length > 0\n            ? html `\r\n                      <button\r\n                        part=\"clear-button\"\r\n                        class=\"search__clear\"\r\n                        type=\"button\"\r\n                        aria-label=${this.localize.term('clearEntry')}\r\n                        @mousedown=${this.handleClearMouseDown}\r\n                        @click=${this.handleClearClick}\r\n                        ?disabled=${this.disabled || this.loading}\r\n                        tabindex=\"-1\"\r\n                      >\r\n                        <koerber-icon name=\"close\" library=\"system\"></koerber-icon>\r\n                      </button>\r\n                    `\n            : html ` <koerber-icon name=\"magnify\"></koerber-icon> `}\r\n              </slot>\r\n            </div>\r\n\r\n            <div\r\n              id=\"listbox\"\r\n              role=\"listbox\"\r\n              aria-expanded=${this.open ? 'true' : 'false'}\r\n              part=\"listbox\"\r\n              class=\"search__listbox\"\r\n              tabindex=\"-1\"\r\n              @mouseup=${this.handleOptionClick}\r\n              @slotchange=${this.handleDefaultSlotChange}\r\n            >\r\n              ${isResultEmpty ? html ` ${noResultHTML} ` : ''}\r\n\r\n              <slot class=\"${classMap({ options: true, 'options--hidden': isResultEmpty })}\"> </slot>\r\n\r\n              <slot></slot>\r\n            </div>\r\n          </koerber-popup>\r\n        </div>\r\n      </div>\r\n    `;\n    }\n}\nSearch.styles = [componentStyles, formControlStyles, styles];\nSearch.dependencies = {\n    'koerber-icon': Icon,\n    'koerber-popup': Popup,\n    'koerber-tag': Tag,\n    'koerber-spinner': Spinner\n};\nexport default Search;\n__decorate([\n    query('.search')\n], Search.prototype, \"popup\", void 0);\n__decorate([\n    query('.search__display-input')\n], Search.prototype, \"displayInput\", void 0);\n__decorate([\n    query('.search__listbox')\n], Search.prototype, \"listbox\", void 0);\n__decorate([\n    query('.search__icon')\n], Search.prototype, \"searchButton\", void 0);\n__decorate([\n    state()\n], Search.prototype, \"hasFocus\", void 0);\n__decorate([\n    state()\n], Search.prototype, \"currentOption\", void 0);\n__decorate([\n    state()\n], Search.prototype, \"selectedOptions\", void 0);\n__decorate([\n    state()\n], Search.prototype, \"minLengthMessage\", void 0);\n__decorate([\n    state()\n], Search.prototype, \"searchResults\", void 0);\n__decorate([\n    property()\n], Search.prototype, \"name\", void 0);\n__decorate([\n    property({ reflect: true })\n], Search.prototype, \"value\", void 0);\n__decorate([\n    defaultValue()\n], Search.prototype, \"defaultValue\", void 0);\n__decorate([\n    property()\n], Search.prototype, \"placeholder\", void 0);\n__decorate([\n    property({ reflect: true })\n], Search.prototype, \"size\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Search.prototype, \"loading\", void 0);\n__decorate([\n    property({ type: String })\n], Search.prototype, \"loadingMessage\", void 0);\n__decorate([\n    property({ attribute: 'max-height', type: Number })\n], Search.prototype, \"maxHeight\", void 0);\n__decorate([\n    property({ type: Number, reflect: true, attribute: 'min-length' })\n], Search.prototype, \"minLength\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Search.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Search.prototype, \"open\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Search.prototype, \"hoist\", void 0);\n__decorate([\n    property({ reflect: true })\n], Search.prototype, \"placement\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Search.prototype, \"required\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Search.prototype, \"error\", void 0);\n__decorate([\n    property({ attribute: 'accessible-name', reflect: true })\n], Search.prototype, \"accessibleName\", void 0);\n__decorate([\n    property({ attribute: 'accessible-description', reflect: true })\n], Search.prototype, \"accessibleDescription\", void 0);\n__decorate([\n    watch('disabled', { waitUntilFirstUpdate: true })\n], Search.prototype, \"handleDisabledChange\", null);\n__decorate([\n    watch('value', { waitUntilFirstUpdate: true })\n], Search.prototype, \"handleValueChange\", null);\n__decorate([\n    watch('minLength')\n], Search.prototype, \"handleMinLengthChange\", null);\n__decorate([\n    watch('open', { waitUntilFirstUpdate: true })\n], Search.prototype, \"handleOpenChange\", null);\nsetDefaultAnimation('search.show', {\n    keyframes: [\n        { opacity: 0, scale: 0.9 },\n        { opacity: 1, scale: 1 }\n    ],\n    options: { duration: 100, easing: 'ease' }\n});\nsetDefaultAnimation('search.hide', {\n    keyframes: [\n        { opacity: 1, scale: 1 },\n        { opacity: 0, scale: 0.9 }\n    ],\n    options: { duration: 100, easing: 'ease' }\n});\nsetDefaultAnimation('search.icon.show', {\n    keyframes: [\n        { opacity: 0, scale: 0.9 },\n        { opacity: 1, scale: 1 }\n    ],\n    options: { duration: 250, easing: 'ease' }\n});\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { clamp } from '../../internal/math';\nimport { html } from 'lit';\nimport { LocalizeController } from '../../utilities/localize';\nimport { query, state } from 'lit/decorators.js';\nimport { watch } from '../../internal/watch';\nimport componentStyles from '../../styles/component.styles';\nimport styles from './tree.styles';\nimport TreeItem from '../tree-item/tree-item.component';\nimport UIKitElement from '../../internal/uikit-element';\nfunction syncCheckboxes(changedTreeItem, initialSync = false) {\n    function syncParentItem(treeItem) {\n        const children = treeItem.getChildrenItems({ includeDisabled: false });\n        if (children.length) {\n            const allChecked = children.every(item => item.selected);\n            const allUnchecked = children.every(item => !item.selected && !item.indeterminate);\n            treeItem.selected = allChecked;\n            treeItem.indeterminate = !allChecked && !allUnchecked;\n        }\n    }\n    function syncAncestors(treeItem) {\n        const parentItem = treeItem.parentElement;\n        if (TreeItem.isTreeItem(parentItem)) {\n            syncParentItem(parentItem);\n            syncAncestors(parentItem);\n        }\n    }\n    function syncDescendants(treeItem) {\n        for (const childItem of treeItem.getChildrenItems()) {\n            childItem.selected = initialSync\n                ? treeItem.selected || childItem.selected\n                : !childItem.disabled && treeItem.selected;\n            syncDescendants(childItem);\n        }\n        if (initialSync) {\n            syncParentItem(treeItem);\n        }\n    }\n    syncDescendants(changedTreeItem);\n    syncAncestors(changedTreeItem);\n}\n/**\n * @summary Trees allow you to display a hierarchical list of selectable [tree items](/components/tree-item). Items with children can be expanded and collapsed as desired by the user.\n * @documentation https://kind-desert-0fb80550f.5.azurestaticapps.net/?path=/docs/components-tree--docs\n * @status stable\n * @since 2.0\n *\n * @event {{ selection: TreeItem[] }} koerber-selection-change - Emitted when a tree item is selected or deselected.\n *\n * @slot - The default slot.\n * @slot expand-icon - The icon to show when the tree item is expanded. Works best with `<koerber-icon>`.\n * @slot collapse-icon - The icon to show when the tree item is collapsed. Works best with `<koerber-icon>`.\n *\n * @csspart base - The component's base wrapper.\n *\n * @cssproperty [--indent-size=var(--koerber-spacing-s)] - The size of the indentation for nested items.\n * @cssproperty [--indent-guide-color=var(--koerber-color-neutral-200)] - The color of the indentation line.\n * @cssproperty [--indent-guide-offset=0] - The amount of vertical spacing to leave between the top and bottom of the\n *  indentation line's starting position.\n * @cssproperty [--indent-guide-style=solid] - The style of the indentation line, e.g. solid, dotted, dashed.\n * @cssproperty [--indent-guide-width=0] - The width of the indentation line.\n */\nclass Tree extends UIKitElement {\n    constructor() {\n        super();\n        /**\n         * The selection behavior of the tree. Single selection allows only one node to be selected at a time. Multiple\n         * displays checkboxes and allows more than one node to be selected. Leaf allows only leaf nodes to be selected.\n         */\n        this.selection = 'multiple';\n        this.localize = new LocalizeController(this);\n        this.clickTarget = null;\n        // Initializes new items by setting the `selectable` property and the expanded/collapsed icons if any\n        this.initTreeItem = (item) => {\n            item.selectable = this.selection === 'multiple';\n            ['expand', 'collapse']\n                .filter(status => !!this.querySelector(`[slot=\"${status}-icon\"]`))\n                .forEach((status) => {\n                const existingIcon = item.querySelector(`[slot=\"${status}-icon\"]`);\n                if (existingIcon === null) {\n                    // No separator exists, add one\n                    item.append(this.getExpandButtonIcon(status));\n                }\n                else if (existingIcon.hasAttribute('data-default')) {\n                    // A default separator exists, replace it\n                    existingIcon.replaceWith(this.getExpandButtonIcon(status));\n                }\n                else {\n                    // The user provided a custom icon, leave it alone\n                }\n            });\n        };\n        this.handleTreeChanged = (mutations) => {\n            for (const mutation of mutations) {\n                const addedNodes = [...mutation.addedNodes].filter(TreeItem.isTreeItem);\n                const removedNodes = [...mutation.removedNodes].filter(TreeItem.isTreeItem);\n                addedNodes.forEach(this.initTreeItem);\n                // If the focused item has been removed form the DOM, move the focus to the first focusable item\n                if (removedNodes.includes(this.lastFocusedItem)) {\n                    this.focusItem(this.getFocusableItems()[0]);\n                }\n            }\n        };\n        this.handleFocusOut = (event) => {\n            const relatedTarget = event.relatedTarget;\n            // If the element that got the focus is not in the tree\n            if (!relatedTarget || !this.contains(relatedTarget)) {\n                this.tabIndex = 0;\n            }\n        };\n        this.handleFocusIn = (event) => {\n            const target = event.target;\n            // If the tree has been focused, move the focus to the last focused item\n            if (event.target === this) {\n                this.focusItem(this.lastFocusedItem || this.getAllTreeItems()[0]);\n            }\n            // If the target is a tree item, update the tabindex\n            if (TreeItem.isTreeItem(target) && !target.disabled) {\n                if (this.lastFocusedItem) {\n                    this.lastFocusedItem.tabIndex = -1;\n                }\n                this.lastFocusedItem = target;\n                this.tabIndex = -1;\n                target.tabIndex = 0;\n            }\n        };\n        this.addEventListener('focusin', this.handleFocusIn);\n        this.addEventListener('focusout', this.handleFocusOut);\n        this.addEventListener('koerber-lazy-change', this.handleSlotChange);\n    }\n    async connectedCallback() {\n        super.connectedCallback();\n        this.setAttribute('role', 'tree');\n        this.setAttribute('tabindex', '0');\n        await this.updateComplete;\n        this.mutationObserver = new MutationObserver(this.handleTreeChanged);\n        this.mutationObserver.observe(this, { childList: true, subtree: true });\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this.mutationObserver.disconnect();\n    }\n    // Generates a clone of the expand icon element to use for each tree item\n    getExpandButtonIcon(status) {\n        const slot = status === 'expand' ? this.expandedIconSlot : this.collapsedIconSlot;\n        const icon = slot.assignedElements({ flatten: true })[0];\n        // Clone it, remove ids, and slot it\n        if (icon) {\n            const clone = icon.cloneNode(true);\n            [clone, ...clone.querySelectorAll('[id]')].forEach(el => el.removeAttribute('id'));\n            clone.setAttribute('data-default', '');\n            clone.slot = `${status}-icon`;\n            return clone;\n        }\n        return null;\n    }\n    syncTreeItems(selectedItem) {\n        const items = this.getAllTreeItems();\n        if (this.selection === 'multiple') {\n            syncCheckboxes(selectedItem);\n        }\n        else {\n            for (const item of items) {\n                if (item !== selectedItem) {\n                    item.selected = false;\n                }\n            }\n        }\n    }\n    selectItem(selectedItem) {\n        const previousSelection = [...this.selectedItems];\n        if (this.selection === 'multiple') {\n            selectedItem.selected = !selectedItem.selected;\n            if (selectedItem.lazy) {\n                selectedItem.open = true;\n            }\n            this.syncTreeItems(selectedItem);\n        }\n        else if (this.selection === 'single' || selectedItem.isLeaf) {\n            selectedItem.selected = true;\n            this.syncTreeItems(selectedItem);\n        }\n        else if (this.selection === 'leaf') {\n            selectedItem.open = !selectedItem.open;\n        }\n        const nextSelection = this.selectedItems;\n        if (previousSelection.length !== nextSelection.length ||\n            nextSelection.some(item => !previousSelection.includes(item))) {\n            // Wait for the tree items' DOM to update before emitting\n            Promise.all(nextSelection.map(el => el.updateComplete)).then(() => {\n                this.emit('koerber-selection-change', { detail: { selection: nextSelection } });\n            });\n        }\n    }\n    getAllTreeItems() {\n        return [...this.querySelectorAll('koerber-tree-item')];\n    }\n    focusItem(item) {\n        item === null || item === void 0 ? void 0 : item.focus();\n    }\n    handleKeyDown(event) {\n        if (!['ArrowDown', 'ArrowUp', 'ArrowRight', 'ArrowLeft', 'Home', 'End', 'Enter', ' '].includes(event.key)) {\n            return;\n        }\n        const items = this.getFocusableItems();\n        const isLtr = this.localize.dir() === 'ltr';\n        const isRtl = this.localize.dir() === 'rtl';\n        if (items.length > 0) {\n            event.preventDefault();\n            const activeItemIndex = items.findIndex(item => item.matches(':focus'));\n            const activeItem = items[activeItemIndex];\n            const focusItemAt = (index) => {\n                const item = items[clamp(index, 0, items.length - 1)];\n                this.focusItem(item);\n            };\n            const toggleExpand = (open) => {\n                activeItem.open = open;\n            };\n            if (event.key === 'ArrowDown') {\n                // Moves focus to the next node that is focusable without opening or closing a node.\n                focusItemAt(activeItemIndex + 1);\n            }\n            else if (event.key === 'ArrowUp') {\n                // Moves focus to the next node that is focusable without opening or closing a node.\n                focusItemAt(activeItemIndex - 1);\n            }\n            else if ((isLtr && event.key === 'ArrowRight') || (isRtl && event.key === 'ArrowLeft')) {\n                //\n                // When focus is on a closed node, opens the node; focus does not move.\n                // When focus is on a open node, moves focus to the first child node.\n                // When focus is on an end node (a tree item with no children), does nothing.\n                //\n                if (!activeItem || activeItem.disabled || activeItem.open || (activeItem.isLeaf && !activeItem.lazy)) {\n                    focusItemAt(activeItemIndex + 1);\n                }\n                else {\n                    toggleExpand(true);\n                }\n            }\n            else if ((isLtr && event.key === 'ArrowLeft') || (isRtl && event.key === 'ArrowRight')) {\n                //\n                // When focus is on an open node, closes the node.\n                // When focus is on a child node that is also either an end node or a closed node, moves focus to its parent node.\n                // When focus is on a closed `tree`, does nothing.\n                //\n                if (!activeItem || activeItem.disabled || activeItem.isLeaf || !activeItem.open) {\n                    focusItemAt(activeItemIndex - 1);\n                }\n                else {\n                    toggleExpand(false);\n                }\n            }\n            else if (event.key === 'Home') {\n                // Moves focus to the first node in the tree without opening or closing a node.\n                focusItemAt(0);\n            }\n            else if (event.key === 'End') {\n                // Moves focus to the last node in the tree that is focusable without opening the node.\n                focusItemAt(items.length - 1);\n            }\n            else if (event.key === 'Enter' || event.key === ' ') {\n                // Selects the focused node.\n                if (!activeItem.disabled) {\n                    this.selectItem(activeItem);\n                }\n            }\n        }\n    }\n    handleClick(event) {\n        const target = event.target;\n        const treeItem = target.closest('koerber-tree-item');\n        const isExpandButton = event\n            .composedPath()\n            .some((el) => { var _a; return (_a = el === null || el === void 0 ? void 0 : el.classList) === null || _a === void 0 ? void 0 : _a.contains('tree-item__expand-button'); });\n        const isAction = event.composedPath().some((el) => { var _a; return (_a = el === null || el === void 0 ? void 0 : el.classList) === null || _a === void 0 ? void 0 : _a.contains('tree-item__actions'); });\n        const isCheckbox = event.composedPath().some((el) => { var _a; return (_a = el === null || el === void 0 ? void 0 : el.classList) === null || _a === void 0 ? void 0 : _a.contains('tree-item__checkbox'); });\n        //\n        // Don't Do anything if there's no tree item, if it's disabled, or if the click doesn't match the initial target\n        // from mousedown. The latter case prevents the user from starting a click on one item and ending it on another,\n        // causing the parent node to collapse.\n        //\n        // See https://github.com/shoelace-style/shoelace/issues/1082\n        //\n        if (!treeItem || treeItem.disabled || target !== this.clickTarget) {\n            return;\n        }\n        if (isExpandButton) {\n            treeItem.open = !treeItem.open;\n        }\n        else if (this.selection === 'multiple' && !isAction) {\n            this.selectItem(treeItem);\n        }\n        else if (this.selection === 'single' || this.selection === 'leaf') {\n            this.selectItem(treeItem);\n        }\n        /* prevent default click twice on checkbox */\n        if (isCheckbox) {\n            event.preventDefault();\n        }\n    }\n    handleMouseDown(event) {\n        // Record the click target so we know which item the click initially targeted\n        this.clickTarget = event.target;\n    }\n    handleSlotChange() {\n        const items = this.getAllTreeItems();\n        items.forEach(this.initTreeItem);\n    }\n    async handleSelectionChange() {\n        const isSelectionMultiple = this.selection === 'multiple';\n        const items = this.getAllTreeItems();\n        this.setAttribute('aria-multiselectable', isSelectionMultiple ? 'true' : 'false');\n        for (const item of items) {\n            item.selectable = isSelectionMultiple;\n        }\n        if (isSelectionMultiple) {\n            await this.updateComplete;\n            [...this.querySelectorAll(':scope > koerber-tree-item')].forEach((treeItem) => syncCheckboxes(treeItem, true));\n        }\n    }\n    /** @internal Returns the list of tree items that are selected in the tree. */\n    get selectedItems() {\n        const items = this.getAllTreeItems();\n        const isSelected = (item) => item.selected;\n        return items.filter(isSelected);\n    }\n    /** @internal Gets focusable tree items in the tree. */\n    getFocusableItems() {\n        const items = this.getAllTreeItems();\n        const collapsedItems = new Set();\n        return items.filter(item => {\n            var _a;\n            // Exclude disabled elements\n            if (item.disabled)\n                return false;\n            // Exclude those whose parent is collapsed or loading\n            const parent = (_a = item.parentElement) === null || _a === void 0 ? void 0 : _a.closest('[role=treeitem]');\n            if (parent && (!parent.open || parent.loading || collapsedItems.has(parent))) {\n                collapsedItems.add(item);\n            }\n            return !collapsedItems.has(item);\n        });\n    }\n    render() {\n        return html `\n      <div\n        part=\"base\"\n        class=\"tree\"\n        @click=${this.handleClick}\n        @keydown=${this.handleKeyDown}\n        @mousedown=${this.handleMouseDown}\n      >\n        <slot @slotchange=${this.handleSlotChange}></slot>\n        <slot name=\"expand-icon\" hidden aria-hidden=\"true\"> </slot>\n        <slot name=\"collapse-icon\" hidden aria-hidden=\"true\"> </slot>\n      </div>\n    `;\n    }\n}\nTree.styles = [componentStyles, styles];\nexport default Tree;\n__decorate([\n    query('slot:not([name])')\n], Tree.prototype, \"defaultSlot\", void 0);\n__decorate([\n    query('slot[name=expand-icon]')\n], Tree.prototype, \"expandedIconSlot\", void 0);\n__decorate([\n    query('slot[name=collapse-icon]')\n], Tree.prototype, \"collapsedIconSlot\", void 0);\n__decorate([\n    state()\n], Tree.prototype, \"selection\", void 0);\n__decorate([\n    watch('selection')\n], Tree.prototype, \"handleSelectionChange\", null);\n"],"names":[],"sourceRoot":""}